<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qpid Proton C++ API: container</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classproton_1_1container.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classproton_1_1container-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">container</div>  </div>
</div><!--header-->
<div class="contents">

<p>A top-level container of connections, sessions, senders, and receivers.  
 <a href="classproton_1_1container.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="container_8hpp_source.html">container.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a45bac9751911de6fbcd3115ff13914"><td class="memItemLeft" align="right" valign="top"><a id="a4a45bac9751911de6fbcd3115ff13914"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a4a45bac9751911de6fbcd3115ff13914">container</a> (<a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> &amp;h, const std::string &amp;<a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677">id</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:a4a45bac9751911de6fbcd3115ff13914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a container. <br /></td></tr>
<tr class="separator:a4a45bac9751911de6fbcd3115ff13914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73c3a48d397b513182a2d90ba5ab686"><td class="memItemLeft" align="right" valign="top"><a id="aa73c3a48d397b513182a2d90ba5ab686"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#aa73c3a48d397b513182a2d90ba5ab686">container</a> (const std::string &amp;<a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677">id</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:aa73c3a48d397b513182a2d90ba5ab686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a container. <br /></td></tr>
<tr class="separator:aa73c3a48d397b513182a2d90ba5ab686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c64e64cedfa36303be53f0f581d1d24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a7c64e64cedfa36303be53f0f581d1d24">~container</a> ()</td></tr>
<tr class="memdesc:a7c64e64cedfa36303be53f0f581d1d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a container.  <a href="#a7c64e64cedfa36303be53f0f581d1d24">More...</a><br /></td></tr>
<tr class="separator:a7c64e64cedfa36303be53f0f581d1d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd13bc7f337ccd7029f5eb22a758fe59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1connection.html">connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#afd13bc7f337ccd7029f5eb22a758fe59">connect</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;)</td></tr>
<tr class="memdesc:afd13bc7f337ccd7029f5eb22a758fe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to <code>url</code> and send an open request to the remote peer.  <a href="#afd13bc7f337ccd7029f5eb22a758fe59">More...</a><br /></td></tr>
<tr class="separator:afd13bc7f337ccd7029f5eb22a758fe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719c90ac57522bc2c830e2ff5335796c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1connection.html">connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a719c90ac57522bc2c830e2ff5335796c">connect</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>)</td></tr>
<tr class="memdesc:a719c90ac57522bc2c830e2ff5335796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to <code>url</code> and send an open request to the remote peer.  <a href="#a719c90ac57522bc2c830e2ff5335796c">More...</a><br /></td></tr>
<tr class="separator:a719c90ac57522bc2c830e2ff5335796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e939e030a7d5185dc4274df0b365b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1listener.html">listener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a22e939e030a7d5185dc4274df0b365b1">listen</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, <a class="el" href="classproton_1_1listen__handler.html">listen_handler</a> &amp;lh)</td></tr>
<tr class="memdesc:a22e939e030a7d5185dc4274df0b365b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start listening on url.  <a href="#a22e939e030a7d5185dc4274df0b365b1">More...</a><br /></td></tr>
<tr class="separator:a22e939e030a7d5185dc4274df0b365b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61376bc6412f82706e8ab7f8a6f3f3ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1listener.html">listener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a61376bc6412f82706e8ab7f8a6f3f3ea">listen</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;)</td></tr>
<tr class="memdesc:a61376bc6412f82706e8ab7f8a6f3f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen with a fixed set of options for all accepted connections.  <a href="#a61376bc6412f82706e8ab7f8a6f3f3ea">More...</a><br /></td></tr>
<tr class="separator:a61376bc6412f82706e8ab7f8a6f3f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab268bad0bd121444c60cde3a25c39f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1listener.html">listener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ab268bad0bd121444c60cde3a25c39f78">listen</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>)</td></tr>
<tr class="memdesc:ab268bad0bd121444c60cde3a25c39f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start listening on URL.  <a href="#ab268bad0bd121444c60cde3a25c39f78">More...</a><br /></td></tr>
<tr class="separator:ab268bad0bd121444c60cde3a25c39f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a43e6d814de94978c515cb084873b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1">run</a> ()</td></tr>
<tr class="memdesc:a13a43e6d814de94978c515cb084873b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the container in this thread.  <a href="#a13a43e6d814de94978c515cb084873b1">More...</a><br /></td></tr>
<tr class="separator:a13a43e6d814de94978c515cb084873b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af1685196fb40ea6e1e5182d9964d44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a5af1685196fb40ea6e1e5182d9964d44">auto_stop</a> (bool)</td></tr>
<tr class="memdesc:a5af1685196fb40ea6e1e5182d9964d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, stop the container when all active connections and listeners are closed.  <a href="#a5af1685196fb40ea6e1e5182d9964d44">More...</a><br /></td></tr>
<tr class="separator:a5af1685196fb40ea6e1e5182d9964d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade42a19caab198f0fd1d28e03cf9ba0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ade42a19caab198f0fd1d28e03cf9ba0e">stop</a> (const <a class="el" href="classproton_1_1error__condition.html">error_condition</a> &amp;err)</td></tr>
<tr class="memdesc:ade42a19caab198f0fd1d28e03cf9ba0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Experimental</b> - Stop the container with an <a class="el" href="classproton_1_1error__condition.html" title="Describes an endpoint error state. ">error_condition</a> err.  <a href="#ade42a19caab198f0fd1d28e03cf9ba0e">More...</a><br /></td></tr>
<tr class="separator:ade42a19caab198f0fd1d28e03cf9ba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c528baf37154d347366083f0f816846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a8c528baf37154d347366083f0f816846">stop</a> ()</td></tr>
<tr class="memdesc:a8c528baf37154d347366083f0f816846"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Experimental</b> - Stop the container with an empty error condition.  <a href="#a8c528baf37154d347366083f0f816846">More...</a><br /></td></tr>
<tr class="separator:a8c528baf37154d347366083f0f816846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0511cbc22f76a538465b9c93d91ccf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1sender.html">sender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ae0511cbc22f76a538465b9c93d91ccf9">open_sender</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>)</td></tr>
<tr class="memdesc:ae0511cbc22f76a538465b9c93d91ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and sender for <code>url</code>.  <a href="#ae0511cbc22f76a538465b9c93d91ccf9">More...</a><br /></td></tr>
<tr class="separator:ae0511cbc22f76a538465b9c93d91ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86afe9e853d5324dd9d01674572c3449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1sender.html">sender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a86afe9e853d5324dd9d01674572c3449">open_sender</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, const <a class="el" href="classproton_1_1sender__options.html">proton::sender_options</a> &amp;o)</td></tr>
<tr class="memdesc:a86afe9e853d5324dd9d01674572c3449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and sender for <code>url</code>.  <a href="#a86afe9e853d5324dd9d01674572c3449">More...</a><br /></td></tr>
<tr class="separator:a86afe9e853d5324dd9d01674572c3449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde74a2c056d5cad5fb14767b4fd9c75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1sender.html">sender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#adde74a2c056d5cad5fb14767b4fd9c75">open_sender</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;c)</td></tr>
<tr class="memdesc:adde74a2c056d5cad5fb14767b4fd9c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and sender for <code>url</code>.  <a href="#adde74a2c056d5cad5fb14767b4fd9c75">More...</a><br /></td></tr>
<tr class="separator:adde74a2c056d5cad5fb14767b4fd9c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f1b213827e9ba6a32bf66bff6edb02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1sender.html">sender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a93f1b213827e9ba6a32bf66bff6edb02">open_sender</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, const <a class="el" href="classproton_1_1sender__options.html">proton::sender_options</a> &amp;o, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;c)</td></tr>
<tr class="memdesc:a93f1b213827e9ba6a32bf66bff6edb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and sender for <code>url</code>.  <a href="#a93f1b213827e9ba6a32bf66bff6edb02">More...</a><br /></td></tr>
<tr class="separator:a93f1b213827e9ba6a32bf66bff6edb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f8ffaa917c20c8c89106948c2a19c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1receiver.html">receiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ac4f8ffaa917c20c8c89106948c2a19c3">open_receiver</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>)</td></tr>
<tr class="memdesc:ac4f8ffaa917c20c8c89106948c2a19c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and receiver for <code>url</code>.  <a href="#ac4f8ffaa917c20c8c89106948c2a19c3">More...</a><br /></td></tr>
<tr class="separator:ac4f8ffaa917c20c8c89106948c2a19c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f92b1288cbd47f693cfc5f742de597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1receiver.html">receiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#af2f92b1288cbd47f693cfc5f742de597">open_receiver</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, const <a class="el" href="classproton_1_1receiver__options.html">proton::receiver_options</a> &amp;o)</td></tr>
<tr class="memdesc:af2f92b1288cbd47f693cfc5f742de597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and receiver for <code>url</code>.  <a href="#af2f92b1288cbd47f693cfc5f742de597">More...</a><br /></td></tr>
<tr class="separator:af2f92b1288cbd47f693cfc5f742de597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b9dd1681102bfab62b466e360d120f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1receiver.html">receiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ad1b9dd1681102bfab62b466e360d120f">open_receiver</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;c)</td></tr>
<tr class="memdesc:ad1b9dd1681102bfab62b466e360d120f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and receiver for <code>url</code>.  <a href="#ad1b9dd1681102bfab62b466e360d120f">More...</a><br /></td></tr>
<tr class="separator:ad1b9dd1681102bfab62b466e360d120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954c0a6f120b8f714af1b660373a4c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1receiver.html">receiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a954c0a6f120b8f714af1b660373a4c7d">open_receiver</a> (const std::string &amp;<a class="el" href="classproton_1_1url.html">url</a>, const <a class="el" href="classproton_1_1receiver__options.html">proton::receiver_options</a> &amp;o, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;c)</td></tr>
<tr class="memdesc:a954c0a6f120b8f714af1b660373a4c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and receiver for <code>url</code>.  <a href="#a954c0a6f120b8f714af1b660373a4c7d">More...</a><br /></td></tr>
<tr class="separator:a954c0a6f120b8f714af1b660373a4c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5cdd8165762b000c6518db56830677"><td class="memItemLeft" align="right" valign="top"><a id="a4c5cdd8165762b000c6518db56830677"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677">id</a> () const</td></tr>
<tr class="memdesc:a4c5cdd8165762b000c6518db56830677"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique identifier for the container. <br /></td></tr>
<tr class="separator:a4c5cdd8165762b000c6518db56830677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0c01788d99926296d620a23fa22d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#aca0c01788d99926296d620a23fa22d0c">client_connection_options</a> (const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;)</td></tr>
<tr class="memdesc:aca0c01788d99926296d620a23fa22d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection options that will be to outgoing connections.  <a href="#aca0c01788d99926296d620a23fa22d0c">More...</a><br /></td></tr>
<tr class="separator:aca0c01788d99926296d620a23fa22d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0986a84403bdf62da9649c5de123d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1connection__options.html">connection_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a8d0986a84403bdf62da9649c5de123d3">client_connection_options</a> () const</td></tr>
<tr class="memdesc:a8d0986a84403bdf62da9649c5de123d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection options that will be to outgoing connections.  <a href="#a8d0986a84403bdf62da9649c5de123d3">More...</a><br /></td></tr>
<tr class="separator:a8d0986a84403bdf62da9649c5de123d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2d04a8b161f33eeae661b673ac2749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a0c2d04a8b161f33eeae661b673ac2749">server_connection_options</a> (const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;)</td></tr>
<tr class="memdesc:a0c2d04a8b161f33eeae661b673ac2749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection options that will be applied to incoming connections.  <a href="#a0c2d04a8b161f33eeae661b673ac2749">More...</a><br /></td></tr>
<tr class="separator:a0c2d04a8b161f33eeae661b673ac2749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7a536b46ab843775da5390754c9bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1connection__options.html">connection_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a0e7a536b46ab843775da5390754c9bf6">server_connection_options</a> () const</td></tr>
<tr class="memdesc:a0e7a536b46ab843775da5390754c9bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection options that will be applied to incoming connections.  <a href="#a0e7a536b46ab843775da5390754c9bf6">More...</a><br /></td></tr>
<tr class="separator:a0e7a536b46ab843775da5390754c9bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7321836daba07f766f48ba65cec6ca2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a7321836daba07f766f48ba65cec6ca2e">sender_options</a> (const class <a class="el" href="classproton_1_1sender__options.html">sender_options</a> &amp;)</td></tr>
<tr class="memdesc:a7321836daba07f766f48ba65cec6ca2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sender options applied to senders created by this container.  <a href="#a7321836daba07f766f48ba65cec6ca2e">More...</a><br /></td></tr>
<tr class="separator:a7321836daba07f766f48ba65cec6ca2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bfc8d811be7f6be17be6cf15e35b4a"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classproton_1_1sender__options.html">sender_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ae7bfc8d811be7f6be17be6cf15e35b4a">sender_options</a> () const</td></tr>
<tr class="memdesc:ae7bfc8d811be7f6be17be6cf15e35b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for creating a sender.  <a href="#ae7bfc8d811be7f6be17be6cf15e35b4a">More...</a><br /></td></tr>
<tr class="separator:ae7bfc8d811be7f6be17be6cf15e35b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb619b02f3b5725a4b0e9f5adcc16f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#adb619b02f3b5725a4b0e9f5adcc16f4d">receiver_options</a> (const class <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> &amp;)</td></tr>
<tr class="memdesc:adb619b02f3b5725a4b0e9f5adcc16f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receiver options applied to receivers created by this container.  <a href="#adb619b02f3b5725a4b0e9f5adcc16f4d">More...</a><br /></td></tr>
<tr class="separator:adb619b02f3b5725a4b0e9f5adcc16f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099ddaa3cfcd6a8ae14401bbbfb4b660"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a099ddaa3cfcd6a8ae14401bbbfb4b660">receiver_options</a> () const</td></tr>
<tr class="memdesc:a099ddaa3cfcd6a8ae14401bbbfb4b660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for creating a receiver.  <a href="#a099ddaa3cfcd6a8ae14401bbbfb4b660">More...</a><br /></td></tr>
<tr class="separator:a099ddaa3cfcd6a8ae14401bbbfb4b660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f1870572a4547a197b5b1c5c3ac28b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ab3f1870572a4547a197b5b1c5c3ac28b">schedule</a> (<a class="el" href="classproton_1_1duration.html">duration</a>, <a class="el" href="classproton_1_1work.html">work</a>)</td></tr>
<tr class="memdesc:ab3f1870572a4547a197b5b1c5c3ac28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a piece of work to happen after the duration: The piece of work can be created from a function object.  <a href="#ab3f1870572a4547a197b5b1c5c3ac28b">More...</a><br /></td></tr>
<tr class="separator:ab3f1870572a4547a197b5b1c5c3ac28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa7a43d870c5b99d019a6eab9c300296f"><td class="memItemLeft" align="right" valign="top"><a id="aa7a43d870c5b99d019a6eab9c300296f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>connection_options</b></td></tr>
<tr class="separator:aa7a43d870c5b99d019a6eab9c300296f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9e3893ade63dfd20a74b5a3985be2a"><td class="memItemLeft" align="right" valign="top"><a id="add9e3893ade63dfd20a74b5a3985be2a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>session_options</b></td></tr>
<tr class="separator:add9e3893ade63dfd20a74b5a3985be2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aa12bc6d06f8de10eb34738504e155"><td class="memItemLeft" align="right" valign="top"><a id="aa7aa12bc6d06f8de10eb34738504e155"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>receiver_options</b></td></tr>
<tr class="separator:aa7aa12bc6d06f8de10eb34738504e155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98743e39eb07d1cbac557e8b82668c1"><td class="memItemLeft" align="right" valign="top"><a id="ac98743e39eb07d1cbac557e8b82668c1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>sender_options</b></td></tr>
<tr class="separator:ac98743e39eb07d1cbac557e8b82668c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca87a5536bfa138b1a6fbfdeb9a54654"><td class="memItemLeft" align="right" valign="top"><a id="aca87a5536bfa138b1a6fbfdeb9a54654"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>work_queue</b></td></tr>
<tr class="separator:aca87a5536bfa138b1a6fbfdeb9a54654"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A top-level container of connections, sessions, senders, and receivers. </p>
<p>A container gives a unique identity to each communicating peer. It is often a process-level object.</p>
<p>It serves as an entry point to the API, allowing connections, senders, and receivers to be established. It can be supplied with an event handler in order to intercept important messaging events, such as newly received messages or newly issued credit for sending messages. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="broker_8cpp-example.html#_a10">broker.cpp</a>, <a class="el" href="client_8cpp-example.html#_a6">client.cpp</a>, <a class="el" href="direct_recv_8cpp-example.html#_a3">direct_recv.cpp</a>, <a class="el" href="direct_send_8cpp-example.html#_a3">direct_send.cpp</a>, <a class="el" href="helloworld_8cpp-example.html#_a3">helloworld.cpp</a>, <a class="el" href="helloworld_direct_8cpp-example.html#_a3">helloworld_direct.cpp</a>, <a class="el" href="multithreaded_client_8cpp-example.html#_a9">multithreaded_client.cpp</a>, <a class="el" href="multithreaded_client_flow_control_8cpp-example.html#_a3">multithreaded_client_flow_control.cpp</a>, <a class="el" href="scheduled_send_8cpp-example.html#_a6">scheduled_send.cpp</a>, <a class="el" href="scheduled_send_03_8cpp-example.html#_a5">scheduled_send_03.cpp</a>, <a class="el" href="server_8cpp-example.html#_a4">server.cpp</a>, <a class="el" href="server_direct_8cpp-example.html#_a2">server_direct.cpp</a>, <a class="el" href="service_bus_8cpp-example.html#_a8">service_bus.cpp</a>, <a class="el" href="simple_recv_8cpp-example.html#_a3">simple_recv.cpp</a>, and <a class="el" href="simple_send_8cpp-example.html#_a3">simple_send.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c64e64cedfa36303be53f0f581d1d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c64e64cedfa36303be53f0f581d1d24">&#9670;&nbsp;</a></span>~container()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classproton_1_1container.html">container</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a container. </p>
<p>Note that you may not delete a container from within any of the threads running any of the container's messaging_handlers. Specifically if you delete the container from within a handler you cause a deadlock or a crash.</p>
<p>The only safe place to delete a container is after all of the threads running a container have finished and all of the run functions have returned. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5af1685196fb40ea6e1e5182d9964d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af1685196fb40ea6e1e5182d9964d44">&#9670;&nbsp;</a></span>auto_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void auto_stop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, stop the container when all active connections and listeners are closed. </p>
<p>If false the container will keep running till <a class="el" href="classproton_1_1container.html#a8c528baf37154d347366083f0f816846" title="Experimental - Stop the container with an empty error condition. ">stop()</a> is called.</p>
<p>auto_stop is set by default when a new container is created. </p>

</div>
</div>
<a id="aca0c01788d99926296d620a23fa22d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0c01788d99926296d620a23fa22d0c">&#9670;&nbsp;</a></span>client_connection_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void client_connection_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection options that will be to outgoing connections. </p>
<p>These are applied first and overriden by options provided in <a class="el" href="classproton_1_1container.html#afd13bc7f337ccd7029f5eb22a758fe59" title="Connect to url and send an open request to the remote peer. ">connect()</a> and <a class="el" href="classproton_1_1messaging__handler.html#a16ba022e899957b2e25b9561b1f53968" title="The remote peer opened the connection. ">messaging_handler::on_connection_open()</a>. </p>

</div>
</div>
<a id="a8d0986a84403bdf62da9649c5de123d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0986a84403bdf62da9649c5de123d3">&#9670;&nbsp;</a></span>client_connection_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1connection__options.html">connection_options</a> client_connection_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection options that will be to outgoing connections. </p>
<p>These are applied first and overriden by options provided in <a class="el" href="classproton_1_1container.html#afd13bc7f337ccd7029f5eb22a758fe59" title="Connect to url and send an open request to the remote peer. ">connect()</a> and <a class="el" href="classproton_1_1messaging__handler.html#a16ba022e899957b2e25b9561b1f53968" title="The remote peer opened the connection. ">messaging_handler::on_connection_open()</a>. </p>

</div>
</div>
<a id="afd13bc7f337ccd7029f5eb22a758fe59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd13bc7f337ccd7029f5eb22a758fe59">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1connection.html">connection</a>&gt; connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to <code>url</code> and send an open request to the remote peer. </p>
<p>Options are applied to the connection as follows, values in later options override earlier ones:</p>
<ol type="1">
<li><a class="el" href="classproton_1_1container.html#aca0c01788d99926296d620a23fa22d0c" title="Connection options that will be to outgoing connections. ">client_connection_options()</a></li>
<li>options passed to <a class="el" href="classproton_1_1container.html#afd13bc7f337ccd7029f5eb22a758fe59" title="Connect to url and send an open request to the remote peer. ">connect()</a></li>
</ol>
<p>The handler in the composed options is used to call <a class="el" href="classproton_1_1messaging__handler.html#a16ba022e899957b2e25b9561b1f53968" title="The remote peer opened the connection. ">proton::messaging_handler::on_connection_open()</a> when the remote peer's open response is received.</p>
<dl class="section return"><dt>Returns</dt><dd>A returned&lt;connection&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="helloworld_8cpp-example.html#a4">helloworld.cpp</a>, <a class="el" href="multithreaded_client_8cpp-example.html#a10">multithreaded_client.cpp</a>, <a class="el" href="server_8cpp-example.html#a5">server.cpp</a>, and <a class="el" href="service_bus_8cpp-example.html#a11">service_bus.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a719c90ac57522bc2c830e2ff5335796c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719c90ac57522bc2c830e2ff5335796c">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1connection.html">connection</a>&gt; connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to <code>url</code> and send an open request to the remote peer. </p>
<dl class="section return"><dt>Returns</dt><dd>A returned&lt;connection&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>

</div>
</div>
<a id="a22e939e030a7d5185dc4274df0b365b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e939e030a7d5185dc4274df0b365b1">&#9670;&nbsp;</a></span>listen() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1listener.html">listener</a> listen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproton_1_1listen__handler.html">listen_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>lh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start listening on url. </p>
<p>Calls to the <a class="el" href="classproton_1_1listen__handler.html">listen_handler</a> are serialized for this listener, but handlers attached to separate listeners may be called concurrently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>identifies a listening url. </td></tr>
    <tr><td class="paramname">lh</td><td>handles listening events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>listener lets you stop listening </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="broker_8cpp-example.html#a26">broker.cpp</a>, <a class="el" href="direct_recv_8cpp-example.html#a4">direct_recv.cpp</a>, <a class="el" href="direct_send_8cpp-example.html#a4">direct_send.cpp</a>, <a class="el" href="helloworld_direct_8cpp-example.html#a4">helloworld_direct.cpp</a>, and <a class="el" href="server_direct_8cpp-example.html#a3">server_direct.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a61376bc6412f82706e8ab7f8a6f3f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61376bc6412f82706e8ab7f8a6f3f3ea">&#9670;&nbsp;</a></span>listen() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1listener.html">listener</a> listen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen with a fixed set of options for all accepted connections. </p>
<p>See <a class="el" href="classproton_1_1container.html#a22e939e030a7d5185dc4274df0b365b1" title="Start listening on url. ">listen(const std::string&amp;, listen_handler&amp;)</a> </p>

</div>
</div>
<a id="ab268bad0bd121444c60cde3a25c39f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab268bad0bd121444c60cde3a25c39f78">&#9670;&nbsp;</a></span>listen() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1listener.html">listener</a> listen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start listening on URL. </p>
<p>New connections will use the handler from <a class="el" href="classproton_1_1container.html#a0c2d04a8b161f33eeae661b673ac2749" title="Connection options that will be applied to incoming connections. ">server_connection_options()</a> </p>

</div>
</div>
<a id="ac4f8ffaa917c20c8c89106948c2a19c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f8ffaa917c20c8c89106948c2a19c3">&#9670;&nbsp;</a></span>open_receiver() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1receiver.html">receiver</a>&gt; open_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and receiver for <code>url</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A returned&lt;receiver&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multithreaded_client_flow_control_8cpp-example.html#a18">multithreaded_client_flow_control.cpp</a>, and <a class="el" href="simple_recv_8cpp-example.html#a7">simple_recv.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="af2f92b1288cbd47f693cfc5f742de597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f92b1288cbd47f693cfc5f742de597">&#9670;&nbsp;</a></span>open_receiver() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1receiver.html">receiver</a>&gt; open_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1receiver__options.html">proton::receiver_options</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and receiver for <code>url</code>. </p>
<p>Supplied receiver options will override the container's template options.</p>
<dl class="section return"><dt>Returns</dt><dd>A returned&lt;receiver&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>

</div>
</div>
<a id="ad1b9dd1681102bfab62b466e360d120f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b9dd1681102bfab62b466e360d120f">&#9670;&nbsp;</a></span>open_receiver() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1receiver.html">receiver</a>&gt; open_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and receiver for <code>url</code>. </p>
<p>Supplied receiver or connection options will override the container's template options.</p>
<dl class="section return"><dt>Returns</dt><dd>A returned&lt;receiver&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>

</div>
</div>
<a id="a954c0a6f120b8f714af1b660373a4c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954c0a6f120b8f714af1b660373a4c7d">&#9670;&nbsp;</a></span>open_receiver() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1receiver.html">receiver</a>&gt; open_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1receiver__options.html">proton::receiver_options</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and receiver for <code>url</code>. </p>
<p>Supplied receiver or connection options will override the container's template options.</p>
<dl class="section return"><dt>Returns</dt><dd>A returned&lt;receiver&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>

</div>
</div>
<a id="ae0511cbc22f76a538465b9c93d91ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0511cbc22f76a538465b9c93d91ccf9">&#9670;&nbsp;</a></span>open_sender() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1sender.html">sender</a>&gt; open_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and sender for <code>url</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A returned&lt;sender&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="client_8cpp-example.html#a7">client.cpp</a>, <a class="el" href="helloworld_direct_8cpp-example.html#a5">helloworld_direct.cpp</a>, <a class="el" href="multithreaded_client_flow_control_8cpp-example.html#a4">multithreaded_client_flow_control.cpp</a>, <a class="el" href="scheduled_send_8cpp-example.html#a7">scheduled_send.cpp</a>, <a class="el" href="scheduled_send_03_8cpp-example.html#a6">scheduled_send_03.cpp</a>, <a class="el" href="service_bus_8cpp-example.html#a24">service_bus.cpp</a>, and <a class="el" href="simple_send_8cpp-example.html#a7">simple_send.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a86afe9e853d5324dd9d01674572c3449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86afe9e853d5324dd9d01674572c3449">&#9670;&nbsp;</a></span>open_sender() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1sender.html">sender</a>&gt; open_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1sender__options.html">proton::sender_options</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and sender for <code>url</code>. </p>
<p>Supplied sender options will override the container's template options. </p><dl class="section return"><dt>Returns</dt><dd>A returned&lt;sender&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>

</div>
</div>
<a id="adde74a2c056d5cad5fb14767b4fd9c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde74a2c056d5cad5fb14767b4fd9c75">&#9670;&nbsp;</a></span>open_sender() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1sender.html">sender</a>&gt; open_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and sender for <code>url</code>. </p>
<p>Supplied connection options will override the container's template options. </p><dl class="section return"><dt>Returns</dt><dd>A returned&lt;sender&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>

</div>
</div>
<a id="a93f1b213827e9ba6a32bf66bff6edb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f1b213827e9ba6a32bf66bff6edb02">&#9670;&nbsp;</a></span>open_sender() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1sender.html">sender</a>&gt; open_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1sender__options.html">proton::sender_options</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and sender for <code>url</code>. </p>
<p>Supplied sender or connection options will override the container's template options.</p>
<dl class="section return"><dt>Returns</dt><dd>A returned&lt;sender&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned value is <em>thread-unsafe</em>. A single-threaded application can assign the returned&lt;T&gt; value to a plain T. A multi-threaded application <em>must</em> ignore the returned value, as it may already be invalid by the time the function returns. Multi-threaded applications can access the value in <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </dd></dl>

</div>
</div>
<a id="a099ddaa3cfcd6a8ae14401bbbfb4b660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099ddaa3cfcd6a8ae14401bbbfb4b660">&#9670;&nbsp;</a></span>receiver_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for creating a receiver. </p>
<p>Options can be "chained" like this:</p>
<div class="fragment"><div class="line">l = <a class="code" href="classproton_1_1container.html#a4a45bac9751911de6fbcd3115ff13914">container</a>.create_receiver(url, <a class="code" href="classproton_1_1container.html#a099ddaa3cfcd6a8ae14401bbbfb4b660">receiver_options</a>().handler(h).auto_settle(<span class="keyword">true</span>));</div></div><!-- fragment --><p>You can also create an options object with common settings and use it as a base for different connections that have mostly the same settings:</p>
<div class="fragment"><div class="line"><a class="code" href="classproton_1_1container.html#a099ddaa3cfcd6a8ae14401bbbfb4b660">receiver_options</a> opts;</div><div class="line">opts.<a class="code" href="classproton_1_1receiver__options.html#af313abfa8d5b19e4b61c779907eb9980">auto_settle</a>(<span class="keyword">true</span>);</div><div class="line">c2 = <a class="code" href="classproton_1_1container.html#a4a45bac9751911de6fbcd3115ff13914">container</a>.open_receiver(url2, opts.handler(h2));</div></div><!-- fragment --><p>Normal value semantics: copy or assign creates a separate copy of the options. </p>

</div>
</div>
<a id="adb619b02f3b5725a4b0e9f5adcc16f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb619b02f3b5725a4b0e9f5adcc16f4d">&#9670;&nbsp;</a></span>receiver_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receiver options applied to receivers created by this container. </p>
<p>They are applied before <a class="el" href="classproton_1_1messaging__handler.html#a768b0a50669aa1d512d12e9d68af14cd" title="The remote peer opened the link. ">messaging_handler::on_receiver_open()</a> and can be overridden. </p>

</div>
</div>
<a id="a13a43e6d814de94978c515cb084873b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a43e6d814de94978c515cb084873b1">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the container in this thread. </p>
<p>Returns when the container stops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classproton_1_1container.html#a5af1685196fb40ea6e1e5182d9964d44" title="If true, stop the container when all active connections and listeners are closed. ...">auto_stop()</a> and <a class="el" href="classproton_1_1container.html#a8c528baf37154d347366083f0f816846" title="Experimental - Stop the container with an empty error condition. ">stop()</a>.</dd></dl>
<p>If you are using C++11 or later you may use a multithreaded container. In this case you may call <a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in this thread. ">run()</a> in multiple threads to create a thread pool. Or aternatively call run with an integer parameter specifying the number of threads for the thread pool. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="broker_8cpp-example.html#a27">broker.cpp</a>, <a class="el" href="multithreaded_client_8cpp-example.html#a21">multithreaded_client.cpp</a>, and <a class="el" href="multithreaded_client_flow_control_8cpp-example.html#a22">multithreaded_client_flow_control.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ab3f1870572a4547a197b5b1c5c3ac28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f1870572a4547a197b5b1c5c3ac28b">&#9670;&nbsp;</a></span>schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproton_1_1duration.html">duration</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproton_1_1work.html">work</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a piece of work to happen after the duration: The piece of work can be created from a function object. </p>
<p>for C++11 and on use a std::function&lt;void()&gt; type; for C++03 compatibility you can use <a class="el" href="classproton_1_1void__function0.html" title="A C++03 compatible void no-argument callback function object. ">void_function0</a>&amp; </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="scheduled_send_8cpp-example.html#a11">scheduled_send.cpp</a>, and <a class="el" href="service_bus_8cpp-example.html#a17">service_bus.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a7321836daba07f766f48ba65cec6ca2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7321836daba07f766f48ba65cec6ca2e">&#9670;&nbsp;</a></span>sender_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classproton_1_1sender__options.html">sender_options</a> </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classproton_1_1sender__options.html">sender_options</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sender options applied to senders created by this container. </p>
<p>They are applied before <a class="el" href="classproton_1_1messaging__handler.html#a0b5d066e5463d3365f662c8a7dc52661" title="The remote peer opened the link. ">messaging_handler::on_sender_open()</a> and can be overridden. </p>

</div>
</div>
<a id="ae7bfc8d811be7f6be17be6cf15e35b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bfc8d811be7f6be17be6cf15e35b4a">&#9670;&nbsp;</a></span>sender_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classproton_1_1sender__options.html">sender_options</a> <a class="el" href="classproton_1_1sender__options.html">sender_options</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for creating a sender. </p>
<p>Options can be "chained" like this:</p>
<div class="fragment"><div class="line">l = <a class="code" href="classproton_1_1container.html#a4a45bac9751911de6fbcd3115ff13914">container</a>.create_sender(url, <a class="code" href="classproton_1_1container.html#ae7bfc8d811be7f6be17be6cf15e35b4a">sender_options</a>().handler(h).auto_settle(<span class="keyword">false</span>));</div></div><!-- fragment --><p>You can also create an options object with common settings and use it as a base for different connections that have mostly the same settings:</p>
<div class="fragment"><div class="line"><a class="code" href="classproton_1_1container.html#ae7bfc8d811be7f6be17be6cf15e35b4a">sender_options</a> opts;</div><div class="line">opts.browsing(<span class="keyword">true</span>);</div><div class="line">l1 = <a class="code" href="classproton_1_1container.html#a4a45bac9751911de6fbcd3115ff13914">container</a>.open_sender(url1, opts.handler(h1));</div><div class="line">c2 = <a class="code" href="classproton_1_1container.html#a4a45bac9751911de6fbcd3115ff13914">container</a>.open_receiver(url2, opts.handler(h2));</div></div><!-- fragment --><p>Normal value semantics: copy or assign creates a separate copy of the options. </p>

</div>
</div>
<a id="a0c2d04a8b161f33eeae661b673ac2749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2d04a8b161f33eeae661b673ac2749">&#9670;&nbsp;</a></span>server_connection_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void server_connection_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection options that will be applied to incoming connections. </p>
<p>These are applied first and overridden by options provided in <a class="el" href="classproton_1_1container.html#a22e939e030a7d5185dc4274df0b365b1" title="Start listening on url. ">listen()</a>, <a class="el" href="classproton_1_1listen__handler.html#a0936d46edbbecedf7eed44a19677b39b" title="Called for each accepted connection. ">listen_handler::on_accept()</a> and <a class="el" href="classproton_1_1messaging__handler.html#a16ba022e899957b2e25b9561b1f53968" title="The remote peer opened the connection. ">messaging_handler::on_connection_open()</a>. </p>

</div>
</div>
<a id="a0e7a536b46ab843775da5390754c9bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7a536b46ab843775da5390754c9bf6">&#9670;&nbsp;</a></span>server_connection_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1connection__options.html">connection_options</a> server_connection_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection options that will be applied to incoming connections. </p>
<p>These are applied first and overridden by options provided in <a class="el" href="classproton_1_1container.html#a22e939e030a7d5185dc4274df0b365b1" title="Start listening on url. ">listen()</a>, <a class="el" href="classproton_1_1listen__handler.html#a0936d46edbbecedf7eed44a19677b39b" title="Called for each accepted connection. ">listen_handler::on_accept()</a> and <a class="el" href="classproton_1_1messaging__handler.html#a16ba022e899957b2e25b9561b1f53968" title="The remote peer opened the connection. ">messaging_handler::on_connection_open()</a>. </p>

</div>
</div>
<a id="ade42a19caab198f0fd1d28e03cf9ba0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade42a19caab198f0fd1d28e03cf9ba0e">&#9670;&nbsp;</a></span>stop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1error__condition.html">error_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Experimental</b> - Stop the container with an <a class="el" href="classproton_1_1error__condition.html" title="Describes an endpoint error state. ">error_condition</a> err. </p>
<ul>
<li>Abort all open connections and listeners.</li>
<li>Process final handler events and injected functions</li>
<li>If <code>!err.empty()</code>, handlers will receive on_transport_error</li>
<li><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in this thread. ">run()</a> will return in all threads. </li>
</ul>

</div>
</div>
<a id="a8c528baf37154d347366083f0f816846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c528baf37154d347366083f0f816846">&#9670;&nbsp;</a></span>stop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Experimental</b> - Stop the container with an empty error condition. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classproton_1_1container.html#ade42a19caab198f0fd1d28e03cf9ba0e" title="Experimental - Stop the container with an error_condition err. ">stop(const error_condition&amp;)</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>proton/<a class="el" href="container_8hpp_source.html">container.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceproton.html">proton</a></li><li class="navelem"><a class="el" href="classproton_1_1container.html">container</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
