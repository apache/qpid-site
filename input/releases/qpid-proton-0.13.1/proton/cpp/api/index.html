<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Qpid Proton C++ API: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">0.13.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the C++ API for the Proton AMQP protocol engine. It allows you to write client and server applications that send and receive AMQP messages.</p>
<p>The best way to start is with the <a class="el" href="tutorial.html">Tutorial</a>.</p>
<h2>An overview of the AMQP model</h2>
<p>Messages are transferred between connected peers over <em>links</em>. The sending end of a link is a <code><a class="el" href="classproton_1_1sender.html" title="A channel for sending messages. ">proton::sender</a></code>, and the receiving end is a <code><a class="el" href="classproton_1_1receiver.html" title="A channel for receiving messages. ">proton::receiver</a></code>. Links have named 'source' and 'target' addresses. See "Sources and Targets" below for more information.</p>
<p>Links are grouped in a <code><a class="el" href="classproton_1_1session.html" title="A container of senders and receivers. ">proton::session</a></code>. Messages for links in the same session are sent sequentially. Messages on different sessions can be interleaved, so a large message being sent on one session does not block messages being sent on other sessions.</p>
<p>Sessions are created over a <code><a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer. ">proton::connection</a></code>, which represents the network connection. You can create links directly on a connection using its default session if you don't need multiple sessions.</p>
<p><code><a class="el" href="classproton_1_1message.html" title="An AMQP message. ">proton::message</a></code> represents the message: the body (content), properties, headers, and annotations. A <code><a class="el" href="classproton_1_1delivery.html" title="A received message. ">proton::delivery</a></code> represents a message being received over a link. The receiver acknowledges the delivery by accepting or rejecting it. The corresponding message sender uses a <code><a class="el" href="classproton_1_1tracker.html" title="A tracker for a sent message. ">proton::tracker</a></code> to follow the state of the delivery.</p>
<p>The delivery is <em>settled</em> when both ends are done with it. Different settlement methods give different levels of reliability: <em>at-most-once</em>, <em>at-least-once</em>, and <em>exactly-once</em>. See "Delivery
Guarantees" below for details.</p>
<h2>Sources and targets</h2>
<p>Every link has two addresses, <em>source</em> and <em>target</em>. The most common pattern for using these addresses is as follows:</p>
<p>When a client creates a <em>receiver</em> link, it sets the <em>source</em> address. This means "I want to receive messages from this source." This is often referred to as "subscribing" to the source. When a client creates a <em>sender</em> link, it sets the <em>target</em> address. This means "I want to send to this target."</p>
<p>In the case of a broker, the source or target usually refers to a queue or topic. In general they can refer to any AMQP-capable node.</p>
<p>In the <em>request-response</em> pattern, a request message carries a <em>reply-to</em> address for the response message. This can be any AMQP address, but it is often useful to create a temporary address for just the response message.</p>
<p>The most common approach is for the client to create a <em>receiver</em> for the response with the <em>dynamic</em> flag set. This asks the server to generate a unique <em>source</em> address automatically and discard it when the link closes. The client uses this "dynamic" source address as the reply-to when it sends the request, and the response is delivered to the client's dynamic receiver.</p>
<p>In the case of a broker, a dynamic address usually corresponds to a temporary queue, but any AMQP request-response server can use this technique. The <a class="el" href="server_direct_8cpp-example.html">server_direct.cpp</a> example illustrates how to implement a queueless request-response server.</p>
<h2>Delivery guarantees</h2>
<p>Proton offers three levels of message delivery guarantee: <em>at-most-once</em>, <em>at-least-once</em>, and <em>exactly-once</em>.</p>
<p>For <em>at-most-once</em>, the sender settles the message as soon as it sends it. If the connection is lost before the message is received by the receiver, the message will not be delivered.</p>
<p>For <em>at-least-once</em>, the receiver accepts and settles the message on receipt. If the connection is lost before the sender is informed of the settlement, then the delivery is considered in-doubt and should be retried. This will ensure it eventually gets delivered (provided of course the connection and link can be reestablished). It may mean that it is delivered multiple times, however.</p>
<p>Finally, for <em>exactly-once</em>, the receiver accepts the message but doesn't settle it. The sender settles once it is aware that the receiver accepted it. In this way the receiver retains knowledge of an accepted message until it is sure the sender knows it has been accepted. If the connection is lost before settlement, the receiver informs the sender of all the unsettled deliveries it knows about, and from this the sender can deduce which need to be redelivered. The sender likewise informs the receiver which deliveries it knows about, from which the receiver can deduce which have already been settled.</p>
<h2>Anatomy of a Proton application</h2>
<p>To send AMQP commands, call methods on classes like <code><a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer. ">proton::connection</a></code>, <code><a class="el" href="classproton_1_1sender.html" title="A channel for sending messages. ">proton::sender</a></code>, <code><a class="el" href="classproton_1_1receiver.html" title="A channel for receiving messages. ">proton::receiver</a></code>, or <code><a class="el" href="classproton_1_1delivery.html" title="A received message. ">proton::delivery</a></code>.</p>
<p>To handle incoming commands, subclass the <code><a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a></code> interface. The handler member functions are called when AMQP protocol events occur on a connection. For example <code><a class="el" href="classproton_1_1messaging__handler.html#a96879b0b0b7ade11f98d3f450abd4c46" title="A message is received. ">proton::messaging_handler::on_message</a></code> is called when a message is received.</p>
<p>Messages are represented by <code><a class="el" href="classproton_1_1message.html" title="An AMQP message. ">proton::message</a></code>. AMQP defines a type encoding that you can use for interoperability, but you can also use any encoding you wish and pass binary data as the <code><a class="el" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae" title="Set the body. Equivalent to body() = x. ">proton::message::body</a></code>. <code><a class="el" href="classproton_1_1value.html" title="A holder for any AMQP value, simple or complex. ">proton::value</a></code> and <code><a class="el" href="classproton_1_1scalar.html" title="A holder for an instance of any scalar AMQP type. ">proton::scalar</a></code> provide conversion between AMQP and C++ data types.</p>
<p>There are several ways to manage handlers and AMQP objects, for different types of application. All of them use the same <code><a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a></code> subclasses so code can be re-used if you change your approach.</p>
<h3>proton::default_container - Easy single-threaded applications</h3>
<p><code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers. ">proton::container</a></code> is the top-level object in a proton application. Use <a class="el" href="classproton_1_1container.html#ae8b4eb94c7de3a287665156a768de8dd" title="Connect to url and send an open request to the remote peer. ">proton::container::connect()</a> and <a class="el" href="classproton_1_1container.html#a27d60b6665f37220d9be70f11ab69654" title="Start listening on url. ">proton::container::listen()</a> to create connections. The container polls multiple connections and calls protocol events on your <code><a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a></code> subclasses.</p>
<p>The default container implementation is created using <code><a class="el" href="classproton_1_1default__container.html" title="A single-threaded container. ">proton::default_container</a></code>.</p>
<p>You can implement your own container to integrate proton with any IO provider using the <code><a class="el" href="classproton_1_1io_1_1connection__engine.html" title="Experimental - An AMQP protocol engine for a single connection. ">proton::io::connection_engine</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="io_page.html">IO integration</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
