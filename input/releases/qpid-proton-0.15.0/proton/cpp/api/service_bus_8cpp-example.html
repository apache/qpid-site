<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Qpid Proton C++ API: service_bus.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">0.15.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('service_bus_8cpp-example.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">service_bus.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>A working example for accessing Service Bus session-enabled queues.Also provides some general notes on Service Bus usage.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one</span></div>
<div class="line"><span class="comment"> * or more contributor license agreements.  See the NOTICE file</span></div>
<div class="line"><span class="comment"> * distributed with this work for additional information</span></div>
<div class="line"><span class="comment"> * regarding copyright ownership.  The ASF licenses this file</span></div>
<div class="line"><span class="comment"> * to you under the Apache License, Version 2.0 (the</span></div>
<div class="line"><span class="comment"> * &quot;License&quot;); you may not use this file except in compliance</span></div>
<div class="line"><span class="comment"> * with the License.  You may obtain a copy of the License at</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing,</span></div>
<div class="line"><span class="comment"> * software distributed under the License is distributed on an</span></div>
<div class="line"><span class="comment"> * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></div>
<div class="line"><span class="comment"> * KIND, either express or implied.  See the License for the</span></div>
<div class="line"><span class="comment"> * specific language governing permissions and limitations</span></div>
<div class="line"><span class="comment"> * under the License.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Service Bus example.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This is an example of using &quot;Service Bus sessions&quot; (not the same thing as an</span></div>
<div class="line"><span class="comment"> * AMQP session) to selectively retrieve messages from a queue.  The queue must</span></div>
<div class="line"><span class="comment"> * be configured within Service Bus to support sessions.  Service Bus uses the</span></div>
<div class="line"><span class="comment"> * AMQP group_id message property to associate messages with a particular</span></div>
<div class="line"><span class="comment"> * Service Bus session.  It uses AMQP filters to specify which session is</span></div>
<div class="line"><span class="comment"> * associated with a receiver.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The mechanics for sending and receiving to other types of service bus queue</span></div>
<div class="line"><span class="comment"> * are broadly the same, as long as the step using the</span></div>
<div class="line"><span class="comment"> * receiver.source().filters() is omitted.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Other Service Bus notes: There is no drain support, hence the need to to use</span></div>
<div class="line"><span class="comment"> * timeouts in this example to detect the end of the message stream.  There is</span></div>
<div class="line"><span class="comment"> * no browse support when setting the AMQP link distribution mode to COPY.</span></div>
<div class="line"><span class="comment"> * Service Bus claims to support browsing, but it is unclear how to manage that</span></div>
<div class="line"><span class="comment"> * with an AMQP client.  Maximum message sizes (for body and headers) vary</span></div>
<div class="line"><span class="comment"> * between queue types and fee tier ranging from 64KB to 1MB.  Due to the</span></div>
<div class="line"><span class="comment"> * distributed nature of Service Bus, queues do not automatically preserve FIFO</span></div>
<div class="line"><span class="comment"> * order of messages unless the user takes steps to force the message stream to</span></div>
<div class="line"><span class="comment"> * a single partition of the queue or creates the queue with partitioning disabled.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This example shows use of the simpler SAS (Shared Access Signature)</span></div>
<div class="line"><span class="comment"> * authentication scheme where the credentials are supplied on the connection.</span></div>
<div class="line"><span class="comment"> * Service Bus does not actually check these credentials when setting up the</span></div>
<div class="line"><span class="comment"> * connection, it merely caches the SAS key and policy (AKA key name) for later</span></div>
<div class="line"><span class="comment"> * access authorization when creating senders and receivers.  There is a second</span></div>
<div class="line"><span class="comment"> * authentication scheme that allows for multiple tokens and even updating them</span></div>
<div class="line"><span class="comment"> * within a long-lived connection which uses special management request-response</span></div>
<div class="line"><span class="comment"> * queues in Service Bus.  The format of this exchange may be documented</span></div>
<div class="line"><span class="comment"> * somewhere but is also available by working through the CbsAsyncExample.cs</span></div>
<div class="line"><span class="comment"> * program in the Amqp.Net Lite project.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The sample output for this program is:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   sent message: message 0 in service bus session &quot;red&quot;</span></div>
<div class="line"><span class="comment">   sent message: message 1 in service bus session &quot;green&quot;</span></div>
<div class="line"><span class="comment">   sent message: message 2 in service bus session &quot;blue&quot;</span></div>
<div class="line"><span class="comment">   sent message: message 3 in service bus session &quot;red&quot;</span></div>
<div class="line"><span class="comment">   sent message: message 4 in service bus session &quot;black&quot;</span></div>
<div class="line"><span class="comment">   sent message: message 5 in service bus session &quot;blue&quot;</span></div>
<div class="line"><span class="comment">   sent message: message 6 in service bus session &quot;yellow&quot;</span></div>
<div class="line"><span class="comment">receiving messages with session identifier &quot;green&quot; from queue ses_q1</span></div>
<div class="line"><span class="comment">   received message: message 1 in service bus session &quot;green&quot;</span></div>
<div class="line"><span class="comment">receiving messages with session identifier &quot;red&quot; from queue ses_q1</span></div>
<div class="line"><span class="comment">   received message: message 0 in service bus session &quot;red&quot;</span></div>
<div class="line"><span class="comment">   received message: message 3 in service bus session &quot;red&quot;</span></div>
<div class="line"><span class="comment">receiving messages with session identifier &quot;blue&quot; from queue ses_q1</span></div>
<div class="line"><span class="comment">   received message: message 2 in service bus session &quot;blue&quot;</span></div>
<div class="line"><span class="comment">   received message: message 5 in service bus session &quot;blue&quot;</span></div>
<div class="line"><span class="comment">receiving messages with session identifier &quot;black&quot; from queue ses_q1</span></div>
<div class="line"><span class="comment">   received message: message 4 in service bus session &quot;black&quot;</span></div>
<div class="line"><span class="comment">receiving messages with session identifier &quot;yellow&quot; from queue ses_q1</span></div>
<div class="line"><span class="comment">   received message: message 6 in service bus session &quot;yellow&quot;</span></div>
<div class="line"><span class="comment">Done. No more messages.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;options.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;proton/connection.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;proton/connection_options.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;proton/default_container.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;proton/messaging_handler.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;proton/sender.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;proton/tracker.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;proton/delivery.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;proton/url.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;proton/source_options.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;fake_cpp11.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> <a name="_a0"></a><a class="code" href="classproton_1_1source__options.html" title="Options for creating a source node for a sender or receiver.">proton::source_options</a>;</div>
<div class="line"><span class="keyword">using</span> <a name="_a1"></a><a class="code" href="classproton_1_1connection__options.html" title="Options for creating a connection.">proton::connection_options</a>;</div>
<div class="line"><span class="keyword">using</span> <a name="_a2"></a><a class="code" href="classproton_1_1sender__options.html" title="Options for creating a sender.">proton::sender_options</a>;</div>
<div class="line"><span class="keyword">using</span> <a name="_a3"></a><a class="code" href="classproton_1_1receiver__options.html" title="Options for creating a receiver.">proton::receiver_options</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> do_next_sequence();</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"><span class="keywordtype">void</span> check_arg(<span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;name) {</div>
<div class="line">    <span class="keywordflow">if</span> (value.empty())</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;missing argument for \&quot;&quot;</span> + name + <span class="stringliteral">&quot;\&quot;&quot;</span>);</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>session_receiver : <span class="keyword">public</span> <a name="_a4"></a><a class="code" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events.">proton::messaging_handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> std::string &amp;connection_url;</div>
<div class="line">    <span class="keyword">const</span> std::string &amp;entity;</div>
<div class="line">    <a name="_a5"></a><a class="code" href="classproton_1_1value.html" title="A holder for any AMQP value, simple or complex.">proton::value</a> session_identifier; <span class="comment">// AMQP null type by default, matches any Service Bus sequence identifier</span></div>
<div class="line">    <span class="keywordtype">int</span> message_count;</div>
<div class="line">    <span class="keywordtype">bool</span> closed;</div>
<div class="line">    <a name="_a6"></a><a class="code" href="classproton_1_1duration.html" title="A span of time in milliseconds.">proton::duration</a> read_timeout;</div>
<div class="line">    <a name="_a7"></a><a class="code" href="classproton_1_1timestamp.html" title="A 64-bit timestamp in milliseconds since the Unix epoch.">proton::timestamp</a> last_read;</div>
<div class="line">    <a name="_a8"></a><a class="code" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers.">proton::container</a> *container;</div>
<div class="line">    <a name="_a9"></a><a class="code" href="classproton_1_1receiver.html" title="A channel for receiving messages.">proton::receiver</a> receiver;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span>process_timeout_fn : <span class="keyword">public</span> <a name="_a10"></a><a class="code" href="classproton_1_1void__function0.html" title="A C++03 compatible void no-argument callback function object, used by container::schedule() and event...">proton::void_function0</a> {</div>
<div class="line">        session_receiver&amp; parent;</div>
<div class="line">        process_timeout_fn(session_receiver&amp; sr) : parent(sr) {}</div>
<div class="line">        <span class="keywordtype">void</span> operator()() { parent.process_timeout(); }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    process_timeout_fn do_process_timeout;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    session_receiver(<span class="keyword">const</span> std::string &amp;c, <span class="keyword">const</span> std::string &amp;e,</div>
<div class="line">                     <span class="keyword">const</span> <span class="keywordtype">char</span> *sid) : connection_url(c), entity(e), message_count(0), closed(false), read_timeout(5000),</div>
<div class="line">                                               last_read(0), container(0), do_process_timeout(*this) {</div>
<div class="line">        <span class="keywordflow">if</span> (sid)</div>
<div class="line">            session_identifier = std::string(sid);</div>
<div class="line">        <span class="comment">// session_identifier is now either empty/null or an AMQP string type.</span></div>
<div class="line">        <span class="comment">// If null, Service Bus will pick the first available message and create</span></div>
<div class="line">        <span class="comment">// a filter at its end with that message&#39;s session identifier.</span></div>
<div class="line">        <span class="comment">// Technically, an AMQP string is not a valid filter-set value unless it</span></div>
<div class="line">        <span class="comment">// is annotated as an AMQP described type, so this may change.</span></div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> run (<a class="code" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers.">proton::container</a> &amp;c) {</div>
<div class="line">        message_count = 0;</div>
<div class="line">        closed = <span class="keyword">false</span>;</div>
<div class="line">        c.<a name="a11"></a><a class="code" href="classproton_1_1container.html#ae8b4eb94c7de3a287665156a768de8dd" title="Connect to url and send an open request to the remote peer.">connect</a>(connection_url, connection_options().handler(*<span class="keyword">this</span>));</div>
<div class="line">        container = &amp;c;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a name="a12"></a><a class="code" href="classproton_1_1messaging__handler.html#a16ba022e899957b2e25b9561b1f53968" title="The remote peer opened the connection.">on_connection_open</a>(<a name="_a13"></a><a class="code" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer.">proton::connection</a> &amp;connection) OVERRIDE {</div>
<div class="line">        <a name="_a14"></a><a class="code" href="classproton_1_1source_1_1filter__map.html" title="Experimental - A map of AMQP symbol keys and filter specifiers.">proton::source::filter_map</a> sb_filter_map;</div>
<div class="line">        <a name="_a15"></a><a class="code" href="classproton_1_1symbol.html" title="A std::string that represents the AMQP symbol type.">proton::symbol</a> key(<span class="stringliteral">&quot;com.microsoft:session-filter&quot;</span>);</div>
<div class="line">        sb_filter_map.put(key, session_identifier);</div>
<div class="line">        receiver = connection.open_receiver(entity, receiver_options().source(source_options().filters(sb_filter_map)));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Start timeout processing here.  If Service Bus has no pending</span></div>
<div class="line">        <span class="comment">// messages, it may defer completing the receiver open until a message</span></div>
<div class="line">        <span class="comment">// becomes available (e.g. to be able to set the actual session</span></div>
<div class="line">        <span class="comment">// identifier if none was specified).</span></div>
<div class="line">        last_read = <a name="a16"></a><a class="code" href="classproton_1_1timestamp.html#a8a432817c74685a518a08ede48d1db34" title="The current wall-clock time.">proton::timestamp::now</a>();</div>
<div class="line">        <span class="comment">// Call this-&gt;process_timeout after read_timeout.</span></div>
<div class="line">        container-&gt;schedule(read_timeout, do_process_timeout);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a name="a17"></a><a class="code" href="classproton_1_1messaging__handler.html#a768b0a50669aa1d512d12e9d68af14cd" title="The remote peer opened the link.">on_receiver_open</a>(<a class="code" href="classproton_1_1receiver.html" title="A channel for receiving messages.">proton::receiver</a> &amp;r) OVERRIDE {</div>
<div class="line">        <span class="keywordflow">if</span> (closed) <span class="keywordflow">return</span>; <span class="comment">// PROTON-1264</span></div>
<div class="line">        <a class="code" href="classproton_1_1value.html" title="A holder for any AMQP value, simple or complex.">proton::value</a> actual_session_id = r.source().filters().<a name="a18"></a><a class="code" href="classproton_1_1value.html#a051c12c4c7efc82a5f268d4f64e15b54" title="Get a contained value of type T. ">get</a>(<span class="stringliteral">&quot;com.microsoft:session-filter&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;receiving messages with session identifier \&quot;&quot;</span> &lt;&lt; actual_session_id</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;\&quot; from queue &quot;</span> &lt;&lt; entity &lt;&lt; std::endl;</div>
<div class="line">        last_read = <a class="code" href="classproton_1_1timestamp.html#a8a432817c74685a518a08ede48d1db34" title="The current wall-clock time.">proton::timestamp::now</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a name="a19"></a><a class="code" href="classproton_1_1messaging__handler.html#a96879b0b0b7ade11f98d3f450abd4c46" title="A message is received.">on_message</a>(<a name="_a20"></a><a class="code" href="classproton_1_1delivery.html" title="A received message.">proton::delivery</a> &amp;, <a name="_a21"></a><a class="code" href="classproton_1_1message.html" title="An AMQP message.">proton::message</a> &amp;m) OVERRIDE {</div>
<div class="line">        message_count++;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   received message: &quot;</span> &lt;&lt; m.body() &lt;&lt; std::endl;</div>
<div class="line">        last_read = <a class="code" href="classproton_1_1timestamp.html#a8a432817c74685a518a08ede48d1db34" title="The current wall-clock time.">proton::timestamp::now</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> process_timeout() {</div>
<div class="line">        <a class="code" href="classproton_1_1timestamp.html" title="A 64-bit timestamp in milliseconds since the Unix epoch.">proton::timestamp</a> deadline = last_read + read_timeout;</div>
<div class="line">        <a class="code" href="classproton_1_1timestamp.html" title="A 64-bit timestamp in milliseconds since the Unix epoch.">proton::timestamp</a> now = <a class="code" href="classproton_1_1timestamp.html#a8a432817c74685a518a08ede48d1db34" title="The current wall-clock time.">proton::timestamp::now</a>();</div>
<div class="line">        <span class="keywordflow">if</span> (now &gt;= deadline) {</div>
<div class="line">            receiver.close();</div>
<div class="line">            closed = <span class="keyword">true</span>;</div>
<div class="line">            receiver.connection().close();</div>
<div class="line">            <span class="keywordflow">if</span> (message_count)</div>
<div class="line">                do_next_sequence();</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Done. No more messages.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <a class="code" href="classproton_1_1duration.html" title="A span of time in milliseconds.">proton::duration</a> next = deadline - now;</div>
<div class="line">            container-&gt;schedule(next, do_process_timeout);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>session_sender : <span class="keyword">public</span> <a class="code" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events.">proton::messaging_handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> std::string &amp;connection_url;</div>
<div class="line">    <span class="keyword">const</span> std::string &amp;entity;</div>
<div class="line">    <span class="keywordtype">int</span> msg_count;</div>
<div class="line">    <span class="keywordtype">int</span> total;</div>
<div class="line">    <span class="keywordtype">int</span> accepts;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    session_sender(<span class="keyword">const</span> std::string &amp;c, <span class="keyword">const</span> std::string &amp;e) : connection_url(c), entity(e),</div>
<div class="line">                                                                 msg_count(0), total(7), accepts(0) {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> run(<a class="code" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers.">proton::container</a> &amp;c) {</div>
<div class="line">        c.<a name="a22"></a><a class="code" href="classproton_1_1container.html#ab9c389caac0c3fff4fb14626082a9a2c" title="Open a connection and sender for url.">open_sender</a>(connection_url + <span class="stringliteral">&quot;/&quot;</span> + entity, sender_options(), connection_options().handler(*<span class="keyword">this</span>));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> send_remaining_messages(<a name="_a23"></a><a class="code" href="classproton_1_1sender.html" title="A channel for sending messages.">proton::sender</a> &amp;s) {</div>
<div class="line">        std::string gid;</div>
<div class="line">        <span class="keywordflow">for</span> (; msg_count &lt; total &amp;&amp; s.<a name="a24"></a><a class="code" href="classproton_1_1link.html#a75360c7515b9f569871c5ea953286649" title="Credit available on the link.">credit</a>() &gt; 0; msg_count++) {</div>
<div class="line">            <span class="keywordflow">switch</span> (msg_count) {</div>
<div class="line">            <span class="keywordflow">case</span> 0: gid = <span class="stringliteral">&quot;red&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> 1: gid = <span class="stringliteral">&quot;green&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> 2: gid = <span class="stringliteral">&quot;blue&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> 3: gid = <span class="stringliteral">&quot;red&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> 4: gid = <span class="stringliteral">&quot;black&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> 5: gid = <span class="stringliteral">&quot;blue&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> 6: gid = <span class="stringliteral">&quot;yellow&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            std::ostringstream mbody;</div>
<div class="line">            mbody &lt;&lt; <span class="stringliteral">&quot;message &quot;</span> &lt;&lt; msg_count &lt;&lt; <span class="stringliteral">&quot; in service bus session \&quot;&quot;</span> &lt;&lt; gid &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;</div>
<div class="line">            <a class="code" href="classproton_1_1message.html" title="An AMQP message.">proton::message</a> m(mbody.str());</div>
<div class="line">            m.<a name="a25"></a><a class="code" href="classproton_1_1message.html#a914482152fd66b188e63a4066ef87586" title="Set the message group ID.">group_id</a>(gid);  <span class="comment">// Service Bus uses the group_id property to as the session identifier.</span></div>
<div class="line">            s.<a name="a26"></a><a class="code" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830" title="Send a message on the sender.">send</a>(m);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;   sent message: &quot;</span> &lt;&lt; m.body() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a name="a27"></a><a class="code" href="classproton_1_1messaging__handler.html#aa24f522a68cdf382762702cece7790e7" title="A message can be sent.">on_sendable</a>(<a class="code" href="classproton_1_1sender.html" title="A channel for sending messages.">proton::sender</a> &amp;s) OVERRIDE {</div>
<div class="line">        send_remaining_messages(s);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a name="a28"></a><a class="code" href="classproton_1_1messaging__handler.html#a003afbb57c00ce404a863152db7867ad" title="The receiving peer accepted a transfer.">on_tracker_accept</a>(<a name="_a29"></a><a class="code" href="classproton_1_1tracker.html" title="A tracker for a sent message.">proton::tracker</a> &amp;t) OVERRIDE {</div>
<div class="line">        accepts++;</div>
<div class="line">        <span class="keywordflow">if</span> (accepts == total) {</div>
<div class="line">            <span class="comment">// upload complete</span></div>
<div class="line">            t.sender().close();</div>
<div class="line">            t.sender().connection().close();</div>
<div class="line">            do_next_sequence();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>sequence : <span class="keyword">public</span> <a class="code" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events.">proton::messaging_handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers.">proton::container</a> *container;</div>
<div class="line">    <span class="keywordtype">int</span> sequence_no;</div>
<div class="line">    session_sender snd;</div>
<div class="line">    session_receiver rcv_red, rcv_green, rcv_null;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> sequence *the_sequence;</div>
<div class="line"></div>
<div class="line">    sequence (<span class="keyword">const</span> std::string &amp;c, <span class="keyword">const</span> std::string &amp;e) : sequence_no(0),</div>
<div class="line">        snd(c, e), rcv_red(c, e, <span class="stringliteral">&quot;red&quot;</span>), rcv_green(c, e, <span class="stringliteral">&quot;green&quot;</span>), rcv_null(c, e, NULL) {</div>
<div class="line">        the_sequence = <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a name="a30"></a><a class="code" href="classproton_1_1messaging__handler.html#a4949b0c93402fae0c07492d984688a25" title="The container event loop is starting.">on_container_start</a>(<a class="code" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers.">proton::container</a> &amp;c) OVERRIDE {</div>
<div class="line">        container = &amp;c;</div>
<div class="line">        next_sequence();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> next_sequence() {</div>
<div class="line">        <span class="keywordflow">switch</span> (sequence_no++) {</div>
<div class="line">        <span class="comment">// run these in order exactly once</span></div>
<div class="line">        <span class="keywordflow">case</span> 0: snd.run(*container); <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 1: rcv_green.run(*container); <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 2: rcv_red.run(*container); <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="comment">// Run this until the receiver decides there is no messages left to sequence through</span></div>
<div class="line">        <span class="keywordflow">default</span>: rcv_null.run(*container); <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">sequence *sequence::the_sequence = NULL;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> do_next_sequence() { sequence::the_sequence-&gt;next_sequence(); }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    std::string sb_namespace; <span class="comment">// i.e. &quot;foo.servicebus.windows.net&quot;</span></div>
<div class="line">    <span class="comment">// Make sure the next two are urlencoded for Proton</span></div>
<div class="line">    std::string sb_key_name;  <span class="comment">// shared access key name for entity (AKA &quot;Policy Name&quot;)</span></div>
<div class="line">    std::string sb_key;       <span class="comment">// shared access key</span></div>
<div class="line">    std::string sb_entity;    <span class="comment">// AKA the service bus queue.  Must enable</span></div>
<div class="line">                              <span class="comment">// sessions on it for this example.</span></div>
<div class="line"></div>
<div class="line">    example::options opts(argc, argv);</div>
<div class="line">    opts.add_value(sb_namespace, <span class="charliteral">&#39;n&#39;</span>, <span class="stringliteral">&quot;namespace&quot;</span>, <span class="stringliteral">&quot;Service Bus full namespace&quot;</span>, <span class="stringliteral">&quot;NAMESPACE&quot;</span>);</div>
<div class="line">    opts.add_value(sb_key_name, <span class="charliteral">&#39;p&#39;</span>, <span class="stringliteral">&quot;policy&quot;</span>, <span class="stringliteral">&quot;policy name that specifies access rights (key name)&quot;</span>, <span class="stringliteral">&quot;POLICY&quot;</span>);</div>
<div class="line">    opts.add_value(sb_key, <span class="charliteral">&#39;k&#39;</span>, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;secret key for the policy&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line">    opts.add_value(sb_entity, <span class="charliteral">&#39;e&#39;</span>, <span class="stringliteral">&quot;entity&quot;</span>, <span class="stringliteral">&quot;entity path (queue name)&quot;</span>, <span class="stringliteral">&quot;ENTITY&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        opts.parse();</div>
<div class="line">        check_arg(sb_namespace, <span class="stringliteral">&quot;namespace&quot;</span>);</div>
<div class="line">        check_arg(sb_key_name, <span class="stringliteral">&quot;policy&quot;</span>);</div>
<div class="line">        check_arg(sb_key, <span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line">        check_arg(sb_entity, <span class="stringliteral">&quot;entity&quot;</span>);</div>
<div class="line">        std::string connection_string(<span class="stringliteral">&quot;amqps://&quot;</span> + sb_key_name + <span class="stringliteral">&quot;:&quot;</span> + sb_key + <span class="stringliteral">&quot;@&quot;</span> + sb_namespace);</div>
<div class="line"></div>
<div class="line">        sequence seq(connection_string, sb_entity);</div>
<div class="line">        proton::default_container(seq).run();</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
