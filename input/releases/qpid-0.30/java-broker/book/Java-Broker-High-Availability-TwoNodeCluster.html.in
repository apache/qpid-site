<div class="docbook"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">13.3.&#160;Two Node Cluster</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="Java-Broker-High-Availability-OfferingsOfJavaBroker.html">Prev</a>&#160;</td><th align="center" width="60%">Chapter&#160;13.&#160;High Availability</th><td align="right" width="20%">&#160;<a accesskey="n" href="Java-Broker-High-Availability-MultiNodeCluster.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Java-Broker-High-Availability-TwoNodeCluster"></a>13.3.&#160;Two Node Cluster</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140304441400608"></a>13.3.1.&#160;Overview</h3></div></div></div><p>In this HA solution, a cluster is formed with two nodes. one node serves as
        <span class="bold"><strong>master</strong></span> and the other is a <span class="bold"><strong>replica</strong></span>.
      </p><p>All data and state required for the operation of the virtual host is automatically sent from the
        master to the replica. This is called the replication stream. The master virtual host confirms each
        message is on the replica before the client transaction completes. The exact way the client awaits
        for the master and replica is gorverned by the <a class="link" href="Java-Broker-High-Availability-DurabilityGuarantee.html" title="13.6.&#160;Durability Guarantees">durability</a>
        configuration, which is discussed later. In this way, the replica remains ready to take over the
        role of the master if the master becomes unavailable.
      </p><p>It is important to note that there is an inherent limitation of two node clusters is that
        the replica node cannot make itself master automatically in the event of master failure.  This
        is because the replica has no way to distinguish between a network partition (with potentially
        the master still alive on the other side of the partition) and the case of genuine master failure.
        (If the replica were to elect itself as master, the cluster would run the risk of a
        <a class="ulink" href="http://en.wikipedia.org/wiki/Split-brain_(computing)" target="_top">split-brain</a> scenario).
        In the event of a master failure, a third party must designate the replica as primary.  This process
        is described in more detail later.
      </p><p>Clients connect to the cluster using a <a class="link" href="Java-Broker-High-Availability-ClientFailover.html" title="13.7.&#160;Client failover configuration">failover url</a>.
        This allows the client to maintain a connection to the master in a way that is transparent
        to the client application.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140304441539712"></a>13.3.2.&#160;Depictions of cluster operation</h3></div></div></div><p>In this section, the operation of the cluster is depicted through a series of figures
        supported by explanatory text.</p><div class="figure"><a id="idm140304441538128"></a><p class="title"><strong>Figure&#160;13.1.&#160;Key for figures</strong></p><div class="figure-contents"><div class="mediaobject"><img alt="Key to figures" src="images/HA-2N-Key.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="Java-Broker-High-Availability-TwoNodeNormalOperation"></a>13.3.2.1.&#160;Normal Operation</h4></div></div></div><p>The figure below illustrates normal operation.  Clients connecting to the cluster by way
	  of the failover URL achieve a connection to the master. As clients perform work (message
	  production, consumption, queue creation etc), the master additionally sends this data to the
	  replica over the network.</p><div class="figure"><a id="idm140304441532288"></a><p class="title"><strong>Figure&#160;13.2.&#160;Normal operation of a two-node cluster</strong></p><div class="figure-contents"><div class="mediaobject"><img alt="Normal operation" src="images/HA-2N-Normal.png" /></div></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="Java-Broker-High-Availability-TwoNodeMasterFailure"></a>13.3.2.2.&#160;Master Failure and Recovery</h4></div></div></div><p>The figure below illustrates a sequence of events whereby the master suffers a failure
	  and the replica is made the master to allow the clients to continue to work. Later the
	  old master is repaired and comes back on-line in replica role.</p><p>The item numbers in this list apply to the numbered boxes in the figure below.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>System operating normally</p></li><li class="listitem"><p>Master suffers a failure and disconnects all clients. Replica realises that it is no
	      longer in contact with master. Clients begin to try to reconnect to the cluster, although these
	      connection attempts will fail at this point.</p></li><li class="listitem"><p>A third-party (an operator, a script or a combination of the two) verifies that the master has truely
           failed <span class="bold"><strong>and is no longer running</strong></span>. If it has truely failed, the decision is made
           to designate the replica as primary, allowing it to assume the role of master despite the other node being down.
           This primary designation is performed using <a class="link" href="Java-Broker-High-Availability-JMXAPI.html" title="13.8.&#160;Qpid JMX API for HA">JMX</a>.</p></li><li class="listitem"><p>Client connections to the new master succeed and the <span class="bold"><strong>service is restored
	      </strong></span>, albeit without a replica.</p></li><li class="listitem"><p>The old master is repaired and brought back on-line.  It automatically rejoins the cluster
	       in the <span class="bold"><strong>replica</strong></span> role.</p></li></ol></div><div class="figure"><a id="idm140304441000176"></a><p class="title"><strong>Figure&#160;13.3.&#160;Failure of master and recovery sequence</strong></p><div class="figure-contents"><div class="mediaobject"><img alt="Failure of master and subsequent recovery sequence" src="images/HA-2N-MasterFail.png" /></div></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="Java-Broker-High-Availability-TwoNodeReplicaFailure"></a>13.3.2.3.&#160;Replica Failure and Recovery</h4></div></div></div><p>The figure that follows illustrates a sequence of events whereby the replica suffers a failure
	   leaving the master to continue processing alone.  Later the replica is repaired and is restarted.
	   It rejoins the cluster so that it is once again ready to take over in the event of master failure.</p><p>The behavior of the replica failure case is governed by the <code class="varname">designatedPrimary</code>
        configuration item. If set true on the master, the master will continue to operate solo without outside
        intervention when the replica fails. If false, a third-party must designate the master as primary in order
        for it to continue solo.</p><p>The item numbers in this list apply to the numbered boxes in the figure below. This example assumes
	   that <code class="varname">designatedPrimary</code> is true on the original master node.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>System operating normally</p></li><li class="listitem"><p>Replica suffers a failure. Master realises that replica longer in contact but as
	      <code class="varname">designatedPrimary</code> is true, master continues processing solo and thus client
	      connections are uninterrupted by the loss of the replica. System continues operating normally, albeit
          with a single node.</p></li><li class="listitem"><p>Replica is repaired.</p></li><li class="listitem"><p>After catching up with missed work, replica is once again ready to take over in the event of master failure.</p></li></ol></div><div class="figure"><a id="idm140304440987136"></a><p class="title"><strong>Figure&#160;13.4.&#160;Failure of replica and subsequent recovery sequence</strong></p><div class="figure-contents"><div class="mediaobject"><img alt="Failure of replica and subsequent recovery sequence" src="images/HA-2N-ReplicaFail.png" /></div></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="Java-Broker-High-Availability-TwoNodeNetworkPartition"></a>13.3.2.4.&#160;Network Partition and Recovery</h4></div></div></div><p>The figure below illustrates the sequence of events that would occur if the network between
	  master and replica were to suffer a partition, and the nodes were out of contact with one and other.</p><p>As with <a class="link" href="Java-Broker-High-Availability-TwoNodeCluster.html#Java-Broker-High-Availability-TwoNodeReplicaFailure" title="13.3.2.3.&#160;Replica Failure and Recovery">Replica Failure and Recovery</a>, the
	  behaviour is governed by the <code class="varname">designatedPrimary</code>.
	  Only if <code class="varname">designatedPrimary</code> is true on the master, will the master continue solo.</p><p>The item numbers in this list apply to the numbered boxes in the figure below. This example assumes
	   that <code class="varname">designatedPrimary</code> is true on the original master node.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>System operating normally</p></li><li class="listitem"><p>Network suffers a failure. Master realises that replica longer in contact but as
	      <code class="varname">designatedPrimary</code> is true, master continues processing solo and thus client
	      connections are uninterrupted by the network partition between master and replica.</p></li><li class="listitem"><p>Network is repaired.</p></li><li class="listitem"><p>After catching up with missed work, replica is once again ready to take over in the event of master failure.
	    System operating normally again.</p></li></ol></div><div class="figure"><a id="idm140304440973152"></a><p class="title"><strong>Figure&#160;13.5.&#160;Partition of the network separating master and replica</strong></p><div class="figure-contents"><div class="mediaobject"><img alt="Network Partition and Recovery" src="images/HA-2N-NetworkPartition.png" /></div></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="Java-Broker-High-Availability-TwoNodeSplitBrain"></a>13.3.2.5.&#160;Split Brain</h4></div></div></div><p>A <a class="ulink" href="http://en.wikipedia.org/wiki/Split-brain_(computing)" target="_top">split-brain</a>
          is a situation where the two node cluster has two masters. BDB normally strives to prevent
	  this situation arising by preventing two nodes in a cluster being master at the same time.
	  However, if the network suffers a partition, and the third-party intervenes incorrectly
	  and makes the replica a second master a split-brain will be formed and both masters will
	  proceed to perform work  <span class="bold"><strong>independently</strong></span> of one and other.</p><p>There is no automatic recovery from a split-brain.</p><p>Manual intervention will be required to choose which store will be retained as master
	  and which will be discarded.  Manual intervention will be required to identify and repeat the
          lost business transactions.</p><p>The item numbers in this list apply to the numbered boxes in the figure below.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>System operating normally</p></li><li class="listitem"><p>Network suffers a failure. Master realises that replica longer in contact but as
	      <code class="varname">designatedPrimary</code> is true, master continues processing solo.  Client
	      connections are uninterrupted by the network partition.</p><p>A third-party <span class="bold"><strong>erroneously</strong></span> designates the replica as primary while the
            original master continues running (now solo).</p></li><li class="listitem"><p>As the nodes cannot see one and other, both behave as masters. Clients may perform work against
	      both master nodes.</p></li></ol></div><div class="figure"><a id="idm140304440958832"></a><p class="title"><strong>Figure&#160;13.6.&#160;Split Brain</strong></p><div class="figure-contents"><div class="mediaobject"><img alt="Split Brain" src="images/HA-2N-SplitBrain.png" /></div></div></div><br class="figure-break" /></div></div></div><div class="navfooter"><hr /><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="Java-Broker-High-Availability-OfferingsOfJavaBroker.html">Prev</a>&#160;</td><td align="center" width="20%"><a accesskey="u" href="Java-Broker-High-Availability.html">Up</a></td><td align="right" width="40%">&#160;<a accesskey="n" href="Java-Broker-High-Availability-MultiNodeCluster.html">Next</a></td></tr><tr><td align="left" valign="top" width="40%">13.2.&#160;HA offerings of the Java Broker&#160;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td align="right" valign="top" width="40%">&#160;13.4.&#160;Multi Node Cluster</td></tr></table></div></div>