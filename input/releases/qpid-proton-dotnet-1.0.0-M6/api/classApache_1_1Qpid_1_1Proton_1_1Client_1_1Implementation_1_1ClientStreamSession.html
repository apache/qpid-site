<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Proton DotNet: Apache.Qpid.Proton.Client.Implementation.ClientStreamSession Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Proton DotNet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceApache.html">Apache</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid.html">Qpid</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html">Client</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation.html">Implementation</a></li><li class="navelem"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html">ClientStreamSession</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Apache.Qpid.Proton.Client.Implementation.ClientStreamSession:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.png" usemap="#Apache.Qpid.Proton.Client.Implementation.ClientStreamSession_map" alt=""/>
  <map id="Apache.Qpid.Proton.Client.Implementation.ClientStreamSession_map" name="Apache.Qpid.Proton.Client.Implementation.ClientStreamSession_map">
<area href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html" title="Client session that wraps a proton session instance and provides the higher level clint API for manag..." alt="Apache.Qpid.Proton.Client.Implementation.ClientSession" shape="rect" coords="0,112,369,136"/>
<area href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html" title="A single AMQP session instance." alt="Apache.Qpid.Proton.Client.ISession" shape="rect" coords="0,56,369,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1de83c24446b4fd9ff715d807c9c9d5e"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a1de83c24446b4fd9ff715d807c9c9d5e">OpenDurableReceiver</a> (string address, string subscriptionName, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null)</td></tr>
<tr class="memdesc:a1de83c24446b4fd9ff715d807c9c9d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a receiver used to consume messages from the given node address. The returned receiver will be configured using the provided receiver options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a1de83c24446b4fd9ff715d807c9c9d5e">More...</a><br /></td></tr>
<tr class="separator:a1de83c24446b4fd9ff715d807c9c9d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c3522ef5200e303c1ba66e6e86b079"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a46c3522ef5200e303c1ba66e6e86b079">OpenDynamicReceiver</a> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null, IDictionary&lt; string, object &gt; dynamicNodeProperties=null)</td></tr>
<tr class="memdesc:a46c3522ef5200e303c1ba66e6e86b079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamic receiver used to consume messages from the dynamically generated node. on the remote. The returned receiver will be configured using the provided options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a46c3522ef5200e303c1ba66e6e86b079">More...</a><br /></td></tr>
<tr class="separator:a46c3522ef5200e303c1ba66e6e86b079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ef0e478638dc4b05eb35fb17117939"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a22ef0e478638dc4b05eb35fb17117939">OpenReceiver</a> (string address, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null)</td></tr>
<tr class="memdesc:a22ef0e478638dc4b05eb35fb17117939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a receiver used to consume messages from the given node address. The returned receiver will be configured using the provided receiver options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a22ef0e478638dc4b05eb35fb17117939">More...</a><br /></td></tr>
<tr class="separator:a22ef0e478638dc4b05eb35fb17117939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef36457ae53038a07ca66737033eb9ed"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aef36457ae53038a07ca66737033eb9ed">OpenSender</a> (string address, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a> options=null)</td></tr>
<tr class="memdesc:aef36457ae53038a07ca66737033eb9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sender used to send messages to the given node address. The returned sender will be configured using configuration options provided.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aef36457ae53038a07ca66737033eb9ed">More...</a><br /></td></tr>
<tr class="separator:aef36457ae53038a07ca66737033eb9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9a936805f1f5be44403098f85203c7"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aee9a936805f1f5be44403098f85203c7">OpenAnonymousSender</a> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a> options=null)</td></tr>
<tr class="memdesc:aee9a936805f1f5be44403098f85203c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a anonymous sender used to send messages to the "anonymous relay" on the remote. Each message sent must include a "to" address for the remote to route the message. The returned sender will be configured using the provided sender options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aee9a936805f1f5be44403098f85203c7">More...</a><br /></td></tr>
<tr class="separator:aee9a936805f1f5be44403098f85203c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fde76a2cdc0a566db3fde8b8faeeb0"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a79fde76a2cdc0a566db3fde8b8faeeb0">OpenDurableReceiverAsync</a> (string address, string subscriptionName, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null)</td></tr>
<tr class="memdesc:a79fde76a2cdc0a566db3fde8b8faeeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a receiver used to consume messages from the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a79fde76a2cdc0a566db3fde8b8faeeb0">More...</a><br /></td></tr>
<tr class="separator:a79fde76a2cdc0a566db3fde8b8faeeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb569e41cab972b1f4c5618a76a14b26"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aeb569e41cab972b1f4c5618a76a14b26">OpenDynamicReceiverAsync</a> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null, IDictionary&lt; string, object &gt; dynamicNodeProperties=null)</td></tr>
<tr class="memdesc:aeb569e41cab972b1f4c5618a76a14b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamic receiver used to consume messages from the dynamically generated node. on the remote. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aeb569e41cab972b1f4c5618a76a14b26">More...</a><br /></td></tr>
<tr class="separator:aeb569e41cab972b1f4c5618a76a14b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fbe3f6d97b80e55f4dfdd9396c4165"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a38fbe3f6d97b80e55f4dfdd9396c4165">OpenReceiverAsync</a> (string address, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null)</td></tr>
<tr class="memdesc:a38fbe3f6d97b80e55f4dfdd9396c4165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a receiver used to consume messages from the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a38fbe3f6d97b80e55f4dfdd9396c4165">More...</a><br /></td></tr>
<tr class="separator:a38fbe3f6d97b80e55f4dfdd9396c4165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24cb15933159431c2136adad2bfc811"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#af24cb15933159431c2136adad2bfc811">OpenSenderAsync</a> (string address, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a> options=null)</td></tr>
<tr class="memdesc:af24cb15933159431c2136adad2bfc811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sender used to send messages to the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#af24cb15933159431c2136adad2bfc811">More...</a><br /></td></tr>
<tr class="separator:af24cb15933159431c2136adad2bfc811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ede4a1eb616f3f1c5070c2f4b23e30"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a50ede4a1eb616f3f1c5070c2f4b23e30">OpenAnonymousSenderAsync</a> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a> options=null)</td></tr>
<tr class="memdesc:a50ede4a1eb616f3f1c5070c2f4b23e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a anonymous sender used to send messages to the "anonymous relay" on the remote. Each message sent must include a "to" address for the remote to route the message. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a50ede4a1eb616f3f1c5070c2f4b23e30">More...</a><br /></td></tr>
<tr class="separator:a50ede4a1eb616f3f1c5070c2f4b23e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21d5617a3644f940ab26909892c84a2"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#ac21d5617a3644f940ab26909892c84a2">NextReceiver</a> ()</td></tr>
<tr class="memdesc:ac21d5617a3644f940ab26909892c84a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits indefinitely for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#ac21d5617a3644f940ab26909892c84a2">More...</a><br /></td></tr>
<tr class="separator:ac21d5617a3644f940ab26909892c84a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9403b51dbe368f4d6fbadf1200cbfb6c"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a9403b51dbe368f4d6fbadf1200cbfb6c">NextReceiverAsync</a> ()</td></tr>
<tr class="memdesc:a9403b51dbe368f4d6fbadf1200cbfb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a task that will complete only after a receiver created from this session has a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a9403b51dbe368f4d6fbadf1200cbfb6c">More...</a><br /></td></tr>
<tr class="separator:a9403b51dbe368f4d6fbadf1200cbfb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c98fc86faaa50aaa26b99d785082f4"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#ac5c98fc86faaa50aaa26b99d785082f4">NextReceiver</a> (<a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a> policy)</td></tr>
<tr class="memdesc:ac5c98fc86faaa50aaa26b99d785082f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits indefinitely for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#ac5c98fc86faaa50aaa26b99d785082f4">More...</a><br /></td></tr>
<tr class="separator:ac5c98fc86faaa50aaa26b99d785082f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec55819e08ed6e850a912d74721f082"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a4ec55819e08ed6e850a912d74721f082">NextReceiverAsync</a> (<a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a> policy)</td></tr>
<tr class="memdesc:a4ec55819e08ed6e850a912d74721f082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a task that will complete only after a receiver created from this session has a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a4ec55819e08ed6e850a912d74721f082">More...</a><br /></td></tr>
<tr class="separator:a4ec55819e08ed6e850a912d74721f082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8a71c72476fc6ea02b4d2308c94b5d"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a5d8a71c72476fc6ea02b4d2308c94b5d">NextReceiver</a> (TimeSpan timeout)</td></tr>
<tr class="memdesc:a5d8a71c72476fc6ea02b4d2308c94b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits up to the given timeout for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a5d8a71c72476fc6ea02b4d2308c94b5d">More...</a><br /></td></tr>
<tr class="separator:a5d8a71c72476fc6ea02b4d2308c94b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6cd94b070f404aac21086707358d6e"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a9c6cd94b070f404aac21086707358d6e">NextReceiverAsync</a> (TimeSpan timeout)</td></tr>
<tr class="memdesc:a9c6cd94b070f404aac21086707358d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a task that will complete once a receiver created from this session has a delivery ready for receipt or the given timeout expires. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a9c6cd94b070f404aac21086707358d6e">More...</a><br /></td></tr>
<tr class="separator:a9c6cd94b070f404aac21086707358d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9f125db3f349dbaf0c44f1a311fa70"><td class="memItemLeft" align="right" valign="top">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#adb9f125db3f349dbaf0c44f1a311fa70">NextReceiver</a> (<a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a> policy, TimeSpan timeout)</td></tr>
<tr class="memdesc:adb9f125db3f349dbaf0c44f1a311fa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits up to the given timeout for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#adb9f125db3f349dbaf0c44f1a311fa70">More...</a><br /></td></tr>
<tr class="separator:adb9f125db3f349dbaf0c44f1a311fa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055f3774286cc10d89f10badff8b60d9"><td class="memItemLeft" align="right" valign="top">override Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a055f3774286cc10d89f10badff8b60d9">NextReceiverAsync</a> (<a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a> policy, TimeSpan timeout)</td></tr>
<tr class="memdesc:a055f3774286cc10d89f10badff8b60d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a task that will complete once a receiver created from this session has a delivery ready for receipt or the given timeout expires. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a055f3774286cc10d89f10badff8b60d9">More...</a><br /></td></tr>
<tr class="separator:a055f3774286cc10d89f10badff8b60d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html">Apache.Qpid.Proton.Client.Implementation.ClientSession</a></td></tr>
<tr class="memitem:ae29fb56b378717c92f60c22fd6f3a815 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a id="ae29fb56b378717c92f60c22fd6f3a815"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ClientSession</b> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientConnection.html">ClientConnection</a> connection, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SessionOptions.html">SessionOptions</a> options, string sessionId, <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Engine_1_1ISession.html">Engine.ISession</a> session)</td></tr>
<tr class="separator:ae29fb56b378717c92f60c22fd6f3a815 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424da9054dc2b12a1659d1c67398b6ba inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a id="a424da9054dc2b12a1659d1c67398b6ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Dispose</b> ()</td></tr>
<tr class="separator:a424da9054dc2b12a1659d1c67398b6ba inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f9f9094c2b44934b1ebc0297d27fcf inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a61f9f9094c2b44934b1ebc0297d27fcf">Close</a> (<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IErrorCondition.html">IErrorCondition</a> error=null)</td></tr>
<tr class="memdesc:a61f9f9094c2b44934b1ebc0297d27fcf inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a close of the session and awaits a response from the remote that indicates completion of the close operation. If the response from the remote exceeds the configure close timeout the method returns after cleaning up the session resources.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a61f9f9094c2b44934b1ebc0297d27fcf">More...</a><br /></td></tr>
<tr class="separator:a61f9f9094c2b44934b1ebc0297d27fcf inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8db042150dec3321b4412d5651ffd83 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ad8db042150dec3321b4412d5651ffd83">CloseAsync</a> (<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IErrorCondition.html">IErrorCondition</a> error=null)</td></tr>
<tr class="memdesc:ad8db042150dec3321b4412d5651ffd83 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a close of the session and a Task that allows the caller to await or poll for the response from the remote that indicates completion of the close operation. If the response from the remote exceeds the configure close timeout the session will be cleaned up and the Task signalled indicating completion.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ad8db042150dec3321b4412d5651ffd83">More...</a><br /></td></tr>
<tr class="separator:ad8db042150dec3321b4412d5651ffd83 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425fff36f2e16fe6dba9346df9d40c73 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a425fff36f2e16fe6dba9346df9d40c73">BeginTransaction</a> ()</td></tr>
<tr class="memdesc:a425fff36f2e16fe6dba9346df9d40c73 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a new transaction scoped to this <a class="el" href="">Session</a> if one is not already active.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a425fff36f2e16fe6dba9346df9d40c73">More...</a><br /></td></tr>
<tr class="separator:a425fff36f2e16fe6dba9346df9d40c73 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5f9467d761e486dbe638f16d24cabe inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#acc5f9467d761e486dbe638f16d24cabe">BeginTransactionAsync</a> ()</td></tr>
<tr class="memdesc:acc5f9467d761e486dbe638f16d24cabe inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a new transaction scoped to this <a class="el" href="">Session</a> if one is not already active. The transaction will not be considered active until the returned Task is completed.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#acc5f9467d761e486dbe638f16d24cabe">More...</a><br /></td></tr>
<tr class="separator:acc5f9467d761e486dbe638f16d24cabe inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b84c43aeff41dfca3f8609bb3d9d4d inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ad1b84c43aeff41dfca3f8609bb3d9d4d">CommitTransaction</a> ()</td></tr>
<tr class="memdesc:ad1b84c43aeff41dfca3f8609bb3d9d4d inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the currently active transaction in this Session.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ad1b84c43aeff41dfca3f8609bb3d9d4d">More...</a><br /></td></tr>
<tr class="separator:ad1b84c43aeff41dfca3f8609bb3d9d4d inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b3a266f65b9020632788bd73763d74 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a61b3a266f65b9020632788bd73763d74">CommitTransactionAsync</a> ()</td></tr>
<tr class="memdesc:a61b3a266f65b9020632788bd73763d74 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously commit the currently active transaction in this Session, the transaction cannot be considered retired until the Task has been completed.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a61b3a266f65b9020632788bd73763d74">More...</a><br /></td></tr>
<tr class="separator:a61b3a266f65b9020632788bd73763d74 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4af6573350431da0a744820735b510 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a8b4af6573350431da0a744820735b510">RollbackTransaction</a> ()</td></tr>
<tr class="memdesc:a8b4af6573350431da0a744820735b510 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roll back the currently active transaction in this Session.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a8b4af6573350431da0a744820735b510">More...</a><br /></td></tr>
<tr class="separator:a8b4af6573350431da0a744820735b510 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa1884176bdb2df80f1c34016ca8e66 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a0fa1884176bdb2df80f1c34016ca8e66">RollbackTransactionAsync</a> ()</td></tr>
<tr class="memdesc:a0fa1884176bdb2df80f1c34016ca8e66 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously roll back the currently active transaction in this Session.  <a href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a0fa1884176bdb2df80f1c34016ca8e66">More...</a><br /></td></tr>
<tr class="separator:a0fa1884176bdb2df80f1c34016ca8e66 inherit pub_methods_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td colspan="2" onclick="javascript:toggleInherit('properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html">Apache.Qpid.Proton.Client.Implementation.ClientSession</a></td></tr>
<tr class="memitem:a21b96a8a33e119bc5d90c08233e9cea7 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a id="a21b96a8a33e119bc5d90c08233e9cea7"></a>
<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IClient.html">IClient</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Client</b><code> [get]</code></td></tr>
<tr class="separator:a21b96a8a33e119bc5d90c08233e9cea7 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3267a844f0f79b8ebdc08278d2547c04 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a id="a3267a844f0f79b8ebdc08278d2547c04"></a>
<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IConnection.html">IConnection</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Connection</b><code> [get]</code></td></tr>
<tr class="separator:a3267a844f0f79b8ebdc08278d2547c04 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e3bf5d6f82d5cc49c54fc47c34bbe3 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a id="a49e3bf5d6f82d5cc49c54fc47c34bbe3"></a>
Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OpenTask</b><code> [get]</code></td></tr>
<tr class="separator:a49e3bf5d6f82d5cc49c54fc47c34bbe3 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f47ea32e8e58c462e4d9618e034fb51 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a id="a1f47ea32e8e58c462e4d9618e034fb51"></a>
IReadOnlyDictionary&lt; string, object &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Properties</b><code> [get]</code></td></tr>
<tr class="separator:a1f47ea32e8e58c462e4d9618e034fb51 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c77b724c91f7a308cf06fa1cc22472 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a id="a35c77b724c91f7a308cf06fa1cc22472"></a>
IReadOnlyCollection&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OfferedCapabilities</b><code> [get]</code></td></tr>
<tr class="separator:a35c77b724c91f7a308cf06fa1cc22472 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d6674e5791cbf22bdc050b5c23bed6 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memItemLeft" align="right" valign="top"><a id="a06d6674e5791cbf22bdc050b5c23bed6"></a>
IReadOnlyCollection&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DesiredCapabilities</b><code> [get]</code></td></tr>
<tr class="separator:a06d6674e5791cbf22bdc050b5c23bed6 inherit properties_classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">Apache.Qpid.Proton.Client.ISession</a></td></tr>
<tr class="memitem:af38ccd6eb9b0d761ab84b3646efb2cfb inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IClient.html">IClient</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#af38ccd6eb9b0d761ab84b3646efb2cfb">Client</a><code> [get]</code></td></tr>
<tr class="memdesc:af38ccd6eb9b0d761ab84b3646efb2cfb inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent client instance that hosts this session.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#af38ccd6eb9b0d761ab84b3646efb2cfb">More...</a><br /></td></tr>
<tr class="separator:af38ccd6eb9b0d761ab84b3646efb2cfb inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e9b98870fe17493a86037896e367c inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IConnection.html">IConnection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a988e9b98870fe17493a86037896e367c">Connection</a><code> [get]</code></td></tr>
<tr class="memdesc:a988e9b98870fe17493a86037896e367c inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent connection instance that created this session.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a988e9b98870fe17493a86037896e367c">More...</a><br /></td></tr>
<tr class="separator:a988e9b98870fe17493a86037896e367c inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588da7f4bd213ed87d91bba92eddfd6f inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a588da7f4bd213ed87d91bba92eddfd6f">OpenTask</a><code> [get]</code></td></tr>
<tr class="memdesc:a588da7f4bd213ed87d91bba92eddfd6f inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a session is created and returned to the client application it may not be remotely opened yet and if the client needs to wait for completion of the open before proceeding the open task can be fetched and waited upon.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a588da7f4bd213ed87d91bba92eddfd6f">More...</a><br /></td></tr>
<tr class="separator:a588da7f4bd213ed87d91bba92eddfd6f inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a713c73335d1b8ab75c67742354d8a inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memItemLeft" align="right" valign="top">IReadOnlyDictionary&lt; string, object &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#af9a713c73335d1b8ab75c67742354d8a">Properties</a><code> [get]</code></td></tr>
<tr class="memdesc:af9a713c73335d1b8ab75c67742354d8a inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the properties that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote properties. If the remote provides no properties this method will return null.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#af9a713c73335d1b8ab75c67742354d8a">More...</a><br /></td></tr>
<tr class="separator:af9a713c73335d1b8ab75c67742354d8a inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ad906f3dcc20d704f14d3e3945b4a4 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memItemLeft" align="right" valign="top">IReadOnlyCollection&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae6ad906f3dcc20d704f14d3e3945b4a4">OfferedCapabilities</a><code> [get]</code></td></tr>
<tr class="memdesc:ae6ad906f3dcc20d704f14d3e3945b4a4 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offered capabilities that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote offered capabilities. If the remote provides no offered capabilities this method will return null.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae6ad906f3dcc20d704f14d3e3945b4a4">More...</a><br /></td></tr>
<tr class="separator:ae6ad906f3dcc20d704f14d3e3945b4a4 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78617ec27836349d427bab2fca774ad inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memItemLeft" align="right" valign="top">IReadOnlyCollection&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#aa78617ec27836349d427bab2fca774ad">DesiredCapabilities</a><code> [get]</code></td></tr>
<tr class="memdesc:aa78617ec27836349d427bab2fca774ad inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the desired capabilities that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote desired capabilities. If the remote provides no desired capabilities this method will return null.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#aa78617ec27836349d427bab2fca774ad">More...</a><br /></td></tr>
<tr class="separator:aa78617ec27836349d427bab2fca774ad inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac21d5617a3644f940ab26909892c84a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21d5617a3644f940ab26909892c84a2">&#9670;&nbsp;</a></span>NextReceiver() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.NextReceiver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits indefinitely for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options. </p>
<dl class="section return"><dt>Returns</dt><dd>The next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a3b6a835c7c04e41091004fa4efa09c9d">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="ac5c98fc86faaa50aaa26b99d785082f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c98fc86faaa50aaa26b99d785082f4">&#9670;&nbsp;</a></span>NextReceiver() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.NextReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits indefinitely for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The next receiver policy to apply when selecting a result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a316fbdd4cba9a9dae0212f249f00f4df">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="adb9f125db3f349dbaf0c44f1a311fa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9f125db3f349dbaf0c44f1a311fa70">&#9670;&nbsp;</a></span>NextReceiver() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.NextReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits up to the given timeout for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The next receiver policy to apply when selecting a result</td></tr>
    <tr><td class="paramname">timeout</td><td>The time to wait for a receiver to have a pending delivery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Task that results in the next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a5623647e0682b3869d2d2b19b4b279f2">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a5d8a71c72476fc6ea02b4d2308c94b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8a71c72476fc6ea02b4d2308c94b5d">&#9670;&nbsp;</a></span>NextReceiver() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.NextReceiver </td>
          <td>(</td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits up to the given timeout for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The time to wait for a receiver to have a pending delivery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a116412ddeca6299cdb3eb7cc42bc4813">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a9403b51dbe368f4d6fbadf1200cbfb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9403b51dbe368f4d6fbadf1200cbfb6c">&#9670;&nbsp;</a></span>NextReceiverAsync() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.NextReceiverAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a task that will complete only after a receiver created from this session has a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options. </p>
<dl class="section return"><dt>Returns</dt><dd>A Task that results in the next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a035f8b87d9f346b80e29349a9c38d916">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a4ec55819e08ed6e850a912d74721f082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec55819e08ed6e850a912d74721f082">&#9670;&nbsp;</a></span>NextReceiverAsync() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.NextReceiverAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a task that will complete only after a receiver created from this session has a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The next receiver policy to apply when selecting a result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Task that results in the next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#aa552ed2d5e303c5c58f73f54c08cc561">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a055f3774286cc10d89f10badff8b60d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055f3774286cc10d89f10badff8b60d9">&#9670;&nbsp;</a></span>NextReceiverAsync() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.NextReceiverAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a task that will complete once a receiver created from this session has a delivery ready for receipt or the given timeout expires. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The next receiver policy to apply when selecting a result</td></tr>
    <tr><td class="paramname">timeout</td><td>The time to wait for a receiver to have a pending delivery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Task that results in the next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a1a4a00ff43127ecd5900069a93d3c257">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a9c6cd94b070f404aac21086707358d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6cd94b070f404aac21086707358d6e">&#9670;&nbsp;</a></span>NextReceiverAsync() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.NextReceiverAsync </td>
          <td>(</td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a task that will complete once a receiver created from this session has a delivery ready for receipt or the given timeout expires. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The time to wait for a receiver to have a pending delivery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ab4b1459f1e40685ad38ce1bc05751d05">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="aee9a936805f1f5be44403098f85203c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9a936805f1f5be44403098f85203c7">&#9670;&nbsp;</a></span>OpenAnonymousSender()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenAnonymousSender </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a anonymous sender used to send messages to the "anonymous relay" on the remote. Each message sent must include a "to" address for the remote to route the message. The returned sender will be configured using the provided sender options. </p>
<p>The returned sender may not have been opened on the remote when it is returned. Some methods of the sender can block until the remote fully opens the sender, the user can wait for the remote to respond to the open request by obtaining the open task from the sender and using it to await the completion of the sender open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional sender options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sender instance.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#aec48183c29e9403a8501440b87d63fc9">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a50ede4a1eb616f3f1c5070c2f4b23e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ede4a1eb616f3f1c5070c2f4b23e30">&#9670;&nbsp;</a></span>OpenAnonymousSenderAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenAnonymousSenderAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a anonymous sender used to send messages to the "anonymous relay" on the remote. Each message sent must include a "to" address for the remote to route the message. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned sender may not have been opened on the remote when it is returned. Some methods of the sender can block until the remote fully opens the sender, the user can wait for the remote to respond to the open request by obtaining the open task from the sender and using it to await the completion of the sender open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional sender options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;ISender&gt; instance.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a7c3ef30f8cb175937a5d5df1ac7dbe43">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a1de83c24446b4fd9ff715d807c9c9d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de83c24446b4fd9ff715d807c9c9d5e">&#9670;&nbsp;</a></span>OpenDurableReceiver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenDurableReceiver </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>subscriptionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a receiver used to consume messages from the given node address. The returned receiver will be configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the receiver attaches to</td></tr>
    <tr><td class="paramname">subscriptionName</td><td>The subscription name to use for the receiver</td></tr>
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new receiver instance</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#af4e811f7deecb904ed5b32f83285444a">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a79fde76a2cdc0a566db3fde8b8faeeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fde76a2cdc0a566db3fde8b8faeeb0">&#9670;&nbsp;</a></span>OpenDurableReceiverAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenDurableReceiverAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>subscriptionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a receiver used to consume messages from the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the receiver attaches to</td></tr>
    <tr><td class="paramname">subscriptionName</td><td>The subscription name to use for the receiver</td></tr>
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;Receiver&gt; instance that can be awaited</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ac01272ea873a476ccf3de8b9cefabb41">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a46c3522ef5200e303c1ba66e6e86b079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c3522ef5200e303c1ba66e6e86b079">&#9670;&nbsp;</a></span>OpenDynamicReceiver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenDynamicReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDictionary&lt; string, object &gt;&#160;</td>
          <td class="paramname"><em>dynamicNodeProperties</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a dynamic receiver used to consume messages from the dynamically generated node. on the remote. The returned receiver will be configured using the provided options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
    <tr><td class="paramname">dynamicNodeProperties</td><td>Optional properties to assign to the node create</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new receiver instance</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#aaa8aa112144d241fc494a5c34984992f">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="aeb569e41cab972b1f4c5618a76a14b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb569e41cab972b1f4c5618a76a14b26">&#9670;&nbsp;</a></span>OpenDynamicReceiverAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenDynamicReceiverAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDictionary&lt; string, object &gt;&#160;</td>
          <td class="paramname"><em>dynamicNodeProperties</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a dynamic receiver used to consume messages from the dynamically generated node. on the remote. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
    <tr><td class="paramname">dynamicNodeProperties</td><td>Optional properties to assign to the node create</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;Receiver&gt; instance that can be awaited</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a3be8e88201e8d18d1d6ef3f1e73b9e7f">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a22ef0e478638dc4b05eb35fb17117939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ef0e478638dc4b05eb35fb17117939">&#9670;&nbsp;</a></span>OpenReceiver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenReceiver </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a receiver used to consume messages from the given node address. The returned receiver will be configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the receiver attaches to</td></tr>
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new receiver instance</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a9fb770fb421efe532cfd648e849c2d5a">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a38fbe3f6d97b80e55f4dfdd9396c4165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fbe3f6d97b80e55f4dfdd9396c4165">&#9670;&nbsp;</a></span>OpenReceiverAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenReceiverAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a receiver used to consume messages from the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the receiver attaches to</td></tr>
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;Receiver&gt; instance that can be awaited</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a433f896714fa12e46eb6842c14074c6f">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="aef36457ae53038a07ca66737033eb9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef36457ae53038a07ca66737033eb9ed">&#9670;&nbsp;</a></span>OpenSender()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a> Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenSender </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sender used to send messages to the given node address. The returned sender will be configured using configuration options provided. </p>
<p>The returned sender may not have been opened on the remote when it is returned. Some methods of the sender can block until the remote fully opens the sender, the user can wait for the remote to respond to the open request by obtaining the open task from the sender and using it to await the completion of the sender open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the sender attaches to</td></tr>
    <tr><td class="paramname">options</td><td>Optional sender options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sender instance.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#aef1456ca7e5aca731b83ff45d1328180">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="af24cb15933159431c2136adad2bfc811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24cb15933159431c2136adad2bfc811">&#9670;&nbsp;</a></span>OpenSenderAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a>&gt; Apache.Qpid.Proton.Client.Implementation.ClientStreamSession.OpenSenderAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sender used to send messages to the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned sender may not have been opened on the remote when it is returned. Some methods of the sender can block until the remote fully opens the sender, the user can wait for the remote to respond to the open request by obtaining the open task from the sender and using it to await the completion of the sender open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the sender attaches to</td></tr>
    <tr><td class="paramname">options</td><td>Optional sender options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;ISender&gt; instance.</dd></dl>

<p>Reimplemented from <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a2443bd6c61c9fdba65ac35dde478371a">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Proton.Client/Client/Implementation/ClientStreamSession.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
