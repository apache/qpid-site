<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qpid Proton C API: Raw connection</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C API
   &#160;<span id="projectnumber">0.34.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__raw__connection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Raw connection<div class="ingroups"><a class="el" href="group__io.html">IO</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><b>Unsettled API</b> - An API allowing raw sockets to be used with proactor  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structpn__raw__buffer__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a></td></tr>
<tr class="memdesc:structpn__raw__buffer__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A descriptor used to represent a single raw buffer in memory.  <a href="group__raw__connection.html#structpn__raw__buffer__t">More...</a><br /></td></tr>
<tr class="separator:structpn__raw__buffer__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga771f248632968276665fb90245023e86"><td class="memItemLeft" align="right" valign="top"><a id="ga771f248632968276665fb90245023e86"></a>
typedef struct <a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a></td></tr>
<tr class="memdesc:ga771f248632968276665fb90245023e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">A raw network connection used with the proactor. <br /></td></tr>
<tr class="separator:ga771f248632968276665fb90245023e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaae8e5b4a86a4f025ece3c3e424ac585d"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gaae8e5b4a86a4f025ece3c3e424ac585d">pn_raw_connection</a> (void)</td></tr>
<tr class="memdesc:gaae8e5b4a86a4f025ece3c3e424ac585d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new raw connection for use with the <a class="el" href="group__proactor.html">Proactor</a>.  <a href="group__raw__connection.html#gaae8e5b4a86a4f025ece3c3e424ac585d">More...</a><br /></td></tr>
<tr class="separator:gaae8e5b4a86a4f025ece3c3e424ac585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64743d369497e272f0d3617526e00373"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN const struct <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#ga64743d369497e272f0d3617526e00373">pn_raw_connection_local_addr</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:ga64743d369497e272f0d3617526e00373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local address of a raw connection.  <a href="group__raw__connection.html#ga64743d369497e272f0d3617526e00373">More...</a><br /></td></tr>
<tr class="separator:ga64743d369497e272f0d3617526e00373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31625ba605ca925685463b300d8c2dca"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN const struct <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#ga31625ba605ca925685463b300d8c2dca">pn_raw_connection_remote_addr</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:ga31625ba605ca925685463b300d8c2dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local address of a raw connection.  <a href="group__raw__connection.html#ga31625ba605ca925685463b300d8c2dca">More...</a><br /></td></tr>
<tr class="separator:ga31625ba605ca925685463b300d8c2dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc38bdc0c5adbd5b7a41a188a895fb7f"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gadc38bdc0c5adbd5b7a41a188a895fb7f">pn_raw_connection_close</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:gadc38bdc0c5adbd5b7a41a188a895fb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a raw connection.  <a href="group__raw__connection.html#gadc38bdc0c5adbd5b7a41a188a895fb7f">More...</a><br /></td></tr>
<tr class="separator:gadc38bdc0c5adbd5b7a41a188a895fb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab01e98e0757e3e3bc16d07005936b417"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gab01e98e0757e3e3bc16d07005936b417">pn_raw_connection_read_close</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:gab01e98e0757e3e3bc16d07005936b417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown a raw connection for reading.  <a href="group__raw__connection.html#gab01e98e0757e3e3bc16d07005936b417">More...</a><br /></td></tr>
<tr class="separator:gab01e98e0757e3e3bc16d07005936b417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78329b8beed24a8ebf98788c2ac6be3"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gaf78329b8beed24a8ebf98788c2ac6be3">pn_raw_connection_write_close</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:gaf78329b8beed24a8ebf98788c2ac6be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown a raw connection for writing.  <a href="group__raw__connection.html#gaf78329b8beed24a8ebf98788c2ac6be3">More...</a><br /></td></tr>
<tr class="separator:gaf78329b8beed24a8ebf98788c2ac6be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28896d789da87c24614ea13276e0bbd0"><td class="memItemLeft" align="right" valign="top"><a id="ga28896d789da87c24614ea13276e0bbd0"></a>
PNP_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#ga28896d789da87c24614ea13276e0bbd0">pn_raw_connection_read_buffers_capacity</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:ga28896d789da87c24614ea13276e0bbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the raw connection for how many more read buffers it can be given. <br /></td></tr>
<tr class="separator:ga28896d789da87c24614ea13276e0bbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac759d82c72058e69301e8a10a3df0e57"><td class="memItemLeft" align="right" valign="top"><a id="gac759d82c72058e69301e8a10a3df0e57"></a>
PNP_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gac759d82c72058e69301e8a10a3df0e57">pn_raw_connection_write_buffers_capacity</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:gac759d82c72058e69301e8a10a3df0e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the raw connection for how many more write buffers it can be given. <br /></td></tr>
<tr class="separator:gac759d82c72058e69301e8a10a3df0e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d8c66c40f79650db663cee78713413"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gad0d8c66c40f79650db663cee78713413">pn_raw_connection_give_read_buffers</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection, <a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> const *buffers, size_t num)</td></tr>
<tr class="memdesc:gad0d8c66c40f79650db663cee78713413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the raw connection buffers to use for reading from the underlying socket.  <a href="group__raw__connection.html#gad0d8c66c40f79650db663cee78713413">More...</a><br /></td></tr>
<tr class="separator:gad0d8c66c40f79650db663cee78713413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98d3b7cf675b6f780d6539a18d24530"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gae98d3b7cf675b6f780d6539a18d24530">pn_raw_connection_take_read_buffers</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection, <a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> *buffers, size_t num)</td></tr>
<tr class="memdesc:gae98d3b7cf675b6f780d6539a18d24530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch buffers with bytes read from the raw socket.  <a href="group__raw__connection.html#gae98d3b7cf675b6f780d6539a18d24530">More...</a><br /></td></tr>
<tr class="separator:gae98d3b7cf675b6f780d6539a18d24530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3167efa9818f821a6af1565859b9e440"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#ga3167efa9818f821a6af1565859b9e440">pn_raw_connection_write_buffers</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection, <a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> const *buffers, size_t num)</td></tr>
<tr class="memdesc:ga3167efa9818f821a6af1565859b9e440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the raw connection buffers to write to the underlying socket.  <a href="group__raw__connection.html#ga3167efa9818f821a6af1565859b9e440">More...</a><br /></td></tr>
<tr class="separator:ga3167efa9818f821a6af1565859b9e440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4169b0f5c64fa2333f147f0eec271129"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#ga4169b0f5c64fa2333f147f0eec271129">pn_raw_connection_take_written_buffers</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection, <a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> *buffers, size_t num)</td></tr>
<tr class="memdesc:ga4169b0f5c64fa2333f147f0eec271129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a buffer chain with buffers that have all been written to the raw socket.  <a href="group__raw__connection.html#ga4169b0f5c64fa2333f147f0eec271129">More...</a><br /></td></tr>
<tr class="separator:ga4169b0f5c64fa2333f147f0eec271129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0d0d70ead71c5d2a64317edf1daca2"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gaed0d0d70ead71c5d2a64317edf1daca2">pn_raw_connection_is_read_closed</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:gaed0d0d70ead71c5d2a64317edf1daca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <code>connection</code> closed for read?  <a href="group__raw__connection.html#gaed0d0d70ead71c5d2a64317edf1daca2">More...</a><br /></td></tr>
<tr class="separator:gaed0d0d70ead71c5d2a64317edf1daca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf15a987d6a4fc42fb665c6b482cf4442"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gaf15a987d6a4fc42fb665c6b482cf4442">pn_raw_connection_is_write_closed</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:gaf15a987d6a4fc42fb665c6b482cf4442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <code>connection</code> closed for write?  <a href="group__raw__connection.html#gaf15a987d6a4fc42fb665c6b482cf4442">More...</a><br /></td></tr>
<tr class="separator:gaf15a987d6a4fc42fb665c6b482cf4442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca978a14e487ec6a6410f031c2ac0432"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gaca978a14e487ec6a6410f031c2ac0432">pn_raw_connection_wake</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:gaca978a14e487ec6a6410f031c2ac0432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa471e4c60d57ab77eb9bc1716fa50134d">PN_RAW_CONNECTION_WAKE</a> event for <code>connection</code> as soon as possible.  <a href="group__raw__connection.html#gaca978a14e487ec6a6410f031c2ac0432">More...</a><br /></td></tr>
<tr class="separator:gaca978a14e487ec6a6410f031c2ac0432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d2e343f71310e1d1d76d677a4cc32cf"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__condition.html#ga11eb7db7d2c205169fe3d47c996a95a5">pn_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#ga5d2e343f71310e1d1d76d677a4cc32cf">pn_raw_connection_condition</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:ga5d2e343f71310e1d1d76d677a4cc32cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get additional information about a raw connection error.  <a href="group__raw__connection.html#ga5d2e343f71310e1d1d76d677a4cc32cf">More...</a><br /></td></tr>
<tr class="separator:ga5d2e343f71310e1d1d76d677a4cc32cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa162a817447cadfb08cb742c13baaf"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gabaa162a817447cadfb08cb742c13baaf">pn_raw_connection_get_context</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:gabaa162a817447cadfb08cb742c13baaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the application context associated with this raw connection.  <a href="group__raw__connection.html#gabaa162a817447cadfb08cb742c13baaf">More...</a><br /></td></tr>
<tr class="separator:gabaa162a817447cadfb08cb742c13baaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1796a50ddd8b0987686b556f477e81"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gafe1796a50ddd8b0987686b556f477e81">pn_raw_connection_set_context</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection, void *context)</td></tr>
<tr class="memdesc:gafe1796a50ddd8b0987686b556f477e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new application context for a raw connection.  <a href="group__raw__connection.html#gafe1796a50ddd8b0987686b556f477e81">More...</a><br /></td></tr>
<tr class="separator:gafe1796a50ddd8b0987686b556f477e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b17a45f4b791b5bbfe32844cb22e5cb"><td class="memItemLeft" align="right" valign="top"><a id="ga5b17a45f4b791b5bbfe32844cb22e5cb"></a>
PNP_EXTERN pn_record_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#ga5b17a45f4b791b5bbfe32844cb22e5cb">pn_raw_connection_attachments</a> (<a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *connection)</td></tr>
<tr class="memdesc:ga5b17a45f4b791b5bbfe32844cb22e5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the attachments that are associated with a raw connection. <br /></td></tr>
<tr class="separator:ga5b17a45f4b791b5bbfe32844cb22e5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf363bfb40f61c6c368fbf452f0bdd5c1"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__connection.html#gaf363bfb40f61c6c368fbf452f0bdd5c1">pn_event_raw_connection</a> (<a class="el" href="group__event.html#ga87f3028b4888632bbd56fb71ac737ae8">pn_event_t</a> *event)</td></tr>
<tr class="memdesc:gaf363bfb40f61c6c368fbf452f0bdd5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw connection associated with an event.  <a href="group__raw__connection.html#gaf363bfb40f61c6c368fbf452f0bdd5c1">More...</a><br /></td></tr>
<tr class="separator:gaf363bfb40f61c6c368fbf452f0bdd5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><b>Unsettled API</b> - An API allowing raw sockets to be used with proactor </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structpn__raw__buffer__t" id="structpn__raw__buffer__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpn__raw__buffer__t">&#9670;&nbsp;</a></span>pn_raw_buffer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pn_raw_buffer_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A descriptor used to represent a single raw buffer in memory. </p>
<dl class="section note"><dt>Note</dt><dd>The intent of the offset is to allow the actual bytes being read/written to be at a variable location relative to the head of the buffer because of other data or structures that are important to the application associated with the data to be written but not themselves read/written to the connection.</dd>
<dd>
For read buffers: When read buffers are returned to the application size will be the number of bytes read. Read operations will not change the context, bytes or capacity members of the structure.</dd>
<dd>
For write buffers: When write buffers are returned to the application all of the struct members will be returned unaltered. Also write operations will not modify the bytes of the buffer passed in at all. In principle this means that the write buffer can be used for multiple writes at the same time as long as the actual buffer is unmodified by the application at any time the buffer is being used by any raw connection. </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="afb301b46bf1bb94237366e0db5c62810"></a>uintptr_t</td>
<td class="fieldname">
context</td>
<td class="fielddoc">
Used to associate arbitrary application data with this raw buffer. </td></tr>
<tr><td class="fieldtype">
<a id="adcc78999fdbb41052741a6e30b16fab5"></a>char *</td>
<td class="fieldname">
bytes</td>
<td class="fielddoc">
Pointer to the start of the raw buffer, if this is null then no buffer is represented. </td></tr>
<tr><td class="fieldtype">
<a id="a391c992c66c3e5540265a85ec2b9216a"></a>uint32_t</td>
<td class="fieldname">
capacity</td>
<td class="fielddoc">
Count of available bytes starting at <a class="el" href="group__raw__connection.html#adcc78999fdbb41052741a6e30b16fab5">bytes</a>. </td></tr>
<tr><td class="fieldtype">
<a id="ab2c6b258f02add8fdf4cfc7c371dd772"></a>uint32_t</td>
<td class="fieldname">
size</td>
<td class="fielddoc">
Number of bytes read or to be written starting at <a class="el" href="group__raw__connection.html#a894bdfa2d603d8343f8ef01dda6fcd23">offset</a>. </td></tr>
<tr><td class="fieldtype">
<a id="a894bdfa2d603d8343f8ef01dda6fcd23"></a>uint32_t</td>
<td class="fieldname">
offset</td>
<td class="fielddoc">
First byte in the buffer to be read or written. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaae8e5b4a86a4f025ece3c3e424ac585d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae8e5b4a86a4f025ece3c3e424ac585d">&#9670;&nbsp;</a></span>pn_raw_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a>* pn_raw_connection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new raw connection for use with the <a class="el" href="group__proactor.html">Proactor</a>. </p>
<p>See <a class="el" href="group__proactor.html#gafd5c18f9d8be144bc7951510a3663b60">pn_proactor_raw_connect</a> and <a class="el" href="group__listener.html#gaa85081d87210d85a304cbf5a0203dc79">pn_listener_raw_accept</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated pn_raw_connection_t or NULL if there wasn't sufficient memory.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is the only pn_raw_connection_t function that allocates memory. So an application that wants good control of out of memory conditions should check the return value for NULL.</dd>
<dd>
It would be a good practice is to create a raw connection and attach application specific context to it before giving it to the proactor.</dd>
<dd>
There is no way to free a pn_raw_connection_t as once passed to the proactor the proactor owns it and controls its lifecycle. </dd></dl>

</div>
</div>
<a id="ga64743d369497e272f0d3617526e00373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64743d369497e272f0d3617526e00373">&#9670;&nbsp;</a></span>pn_raw_connection_local_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN const struct <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a>* pn_raw_connection_local_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local address of a raw connection. </p>
<p>Return <code>NULL</code> if not available. Pointer is invalid after the transport closes (<a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1278d8c62c5bf1a46f70b1cb2866ab80">PN_RAW_CONNECTION_DISCONNECTED</a> event is handled) </p>

</div>
</div>
<a id="ga31625ba605ca925685463b300d8c2dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31625ba605ca925685463b300d8c2dca">&#9670;&nbsp;</a></span>pn_raw_connection_remote_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN const struct <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a>* pn_raw_connection_remote_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local address of a raw connection. </p>
<p>Return <code>NULL</code> if not available. Pointer is invalid after the transport closes (<a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1278d8c62c5bf1a46f70b1cb2866ab80">PN_RAW_CONNECTION_DISCONNECTED</a> event is handled) </p>

</div>
</div>
<a id="gadc38bdc0c5adbd5b7a41a188a895fb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc38bdc0c5adbd5b7a41a188a895fb7f">&#9670;&nbsp;</a></span>pn_raw_connection_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_raw_connection_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a raw connection. </p>
<p>This will flush any buffers to be written; close the underlying socket and release all buffers held by the raw connection.</p>
<p>It will cause <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa23e8c593d41b3ef88c3b57a98ca1e0ad">PN_RAW_CONNECTION_READ</a> and <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa7928b624dab81e3d51a9919954c67b27">PN_RAW_CONNECTION_WRITTEN</a> to be emitted so the application can clean up buffers given to the raw connection. After that a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1278d8c62c5bf1a46f70b1cb2866ab80">PN_RAW_CONNECTION_DISCONNECTED</a> event will be emitted to allow the application to clean up any other state held by the raw connection. </p>

</div>
</div>
<a id="gab01e98e0757e3e3bc16d07005936b417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab01e98e0757e3e3bc16d07005936b417">&#9670;&nbsp;</a></span>pn_raw_connection_read_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_raw_connection_read_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown a raw connection for reading. </p>
<p>This will close the underlying socket for reading and release all empty read buffers held by the raw connection.</p>
<p>It will cause <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa23e8c593d41b3ef88c3b57a98ca1e0ad">PN_RAW_CONNECTION_READ</a> to be emitted so the application can clean up buffers given to the raw connection. Note that these buffers may still also contain data read from the socket but not yet consumed by the application.</p>
<p>If <a class="el" href="group__raw__connection.html#gaf78329b8beed24a8ebf98788c2ac6be3">pn_raw_connection_write_close()</a> has already been called then <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1278d8c62c5bf1a46f70b1cb2866ab80">PN_RAW_CONNECTION_DISCONNECTED</a> will then also be emitted.</p>
<p>In order to fully close a raw connection the application will need to either call <a class="el" href="group__raw__connection.html#gadc38bdc0c5adbd5b7a41a188a895fb7f">pn_raw_connection_close()</a> or <a class="el" href="group__raw__connection.html#gaf78329b8beed24a8ebf98788c2ac6be3">pn_raw_connection_write_close()</a> after it calls <a class="el" href="group__raw__connection.html#gab01e98e0757e3e3bc16d07005936b417">pn_raw_connection_read_close()</a>. </p>

</div>
</div>
<a id="gaf78329b8beed24a8ebf98788c2ac6be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf78329b8beed24a8ebf98788c2ac6be3">&#9670;&nbsp;</a></span>pn_raw_connection_write_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_raw_connection_write_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown a raw connection for writing. </p>
<p>This will flush any buffers to be written to the socket; close the underlying socket for writing and release all write buffers held by the raw connection.</p>
<p>It will cause <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa7928b624dab81e3d51a9919954c67b27">PN_RAW_CONNECTION_WRITTEN</a> to be emitted so the application can clean up write buffers given to the raw connection.</p>
<p>If <a class="el" href="group__raw__connection.html#gab01e98e0757e3e3bc16d07005936b417">pn_raw_connection_read_close()</a> has already been called then <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1278d8c62c5bf1a46f70b1cb2866ab80">PN_RAW_CONNECTION_DISCONNECTED</a> will then also be emitted.</p>
<p>In order to fully close a raw connection the application will need to either call <a class="el" href="group__raw__connection.html#gadc38bdc0c5adbd5b7a41a188a895fb7f">pn_raw_connection_close()</a> or <a class="el" href="group__raw__connection.html#gab01e98e0757e3e3bc16d07005936b417">pn_raw_connection_read_close()</a> after it calls <a class="el" href="group__raw__connection.html#gaf78329b8beed24a8ebf98788c2ac6be3">pn_raw_connection_write_close()</a>. </p>

</div>
</div>
<a id="gad0d8c66c40f79650db663cee78713413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0d8c66c40f79650db663cee78713413">&#9670;&nbsp;</a></span>pn_raw_connection_give_read_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN size_t pn_raw_connection_give_read_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> const *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the raw connection buffers to use for reading from the underlying socket. </p>
<p>If the raw socket has no read buffers then the application will never receive a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa23e8c593d41b3ef88c3b57a98ca1e0ad">PN_RAW_CONNECTION_READ</a> event.</p>
<p>A <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaaebc9e2d013af020e30caafc86f89a391">PN_RAW_CONNECTION_NEED_READ_BUFFERS</a> event will be generated immediately after the <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa878996fc147735984a2c008fbd113f8c">PN_RAW_CONNECTION_CONNECTED</a> event if there are no read buffers. It will also be generated whenever the raw connection runs out of read buffers. In both these cases the event will not be generated again until <a class="el" href="group__raw__connection.html#gad0d8c66c40f79650db663cee78713413">pn_raw_connection_give_read_buffers</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of buffers actually given to the raw connection. This will only be different from the number supplied if the connection has no more space to record more buffers. In this case the buffers taken will be the earlier buffers in the array supplied, the elements 0 to the returned value-1.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffers given to the raw connection are owned by it until the application receives the buffers back with a <a class="el" href="group__raw__connection.html#gae98d3b7cf675b6f780d6539a18d24530">pn_raw_connection_take_read_buffers</a> call. They must not be accessed at all (written or even read) from calling <a class="el" href="group__raw__connection.html#gad0d8c66c40f79650db663cee78713413">pn_raw_connection_give_read_buffers</a> until receiving them back.</dd>
<dd>
The application should not assume that the <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaaebc9e2d013af020e30caafc86f89a391">PN_RAW_CONNECTION_NEED_READ_BUFFERS</a> event signifies that the connection is readable. </dd></dl>

</div>
</div>
<a id="gae98d3b7cf675b6f780d6539a18d24530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98d3b7cf675b6f780d6539a18d24530">&#9670;&nbsp;</a></span>pn_raw_connection_take_read_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN size_t pn_raw_connection_take_read_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch buffers with bytes read from the raw socket. </p>
<p>The buffers will be placed in the buffers array in the order in which they were read. So the first buffer in the array will contain the first bytes read; the second buffer the next bytes etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>pointer to an array of <a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> structures which will be filled in with the read buffer information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>the number of buffers allocated in the passed in array of buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of buffers being returned, if there are no read bytes then this will be 0. As many buffers will be returned as can be given the number that are passed in. So if the number returned is less than the number passed in there are no more buffers read. But if the number is the same there may be more read buffers to take.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After the application receives <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa23e8c593d41b3ef88c3b57a98ca1e0ad">PN_RAW_CONNECTION_READ</a> there should be bytes read from the socket and hence this call should return buffers. It is safe to carry on calling <a class="el" href="group__raw__connection.html#gae98d3b7cf675b6f780d6539a18d24530">pn_raw_connection_take_read_buffers</a> until it returns 0. </dd></dl>

</div>
</div>
<a id="ga3167efa9818f821a6af1565859b9e440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3167efa9818f821a6af1565859b9e440">&#9670;&nbsp;</a></span>pn_raw_connection_write_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN size_t pn_raw_connection_write_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> const *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the raw connection buffers to write to the underlying socket. </p>
<p>The buffers will be written to the connection in the order that they are passed in. That is the first buffer in the array of buffers passed will be the first buffer written to the connection; the second buffer passed in will be the second written etc.</p>
<p>A <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa7928b624dab81e3d51a9919954c67b27">PN_RAW_CONNECTION_WRITTEN</a> event will be generated once the buffers have been written to the socket until this point the buffers must not be accessed at all (written or even read).</p>
<p>A <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaad3fb4c7b64b68e9afd2bead0f6c24cc3">PN_RAW_CONNECTION_NEED_WRITE_BUFFERS</a> event will be generated immediately after the <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa878996fc147735984a2c008fbd113f8c">PN_RAW_CONNECTION_CONNECTED</a> event if there are no write buffers. It will also be generated whenever the raw connection finishes writing all the write buffers. In both these cases the event will not be generated again until <a class="el" href="group__raw__connection.html#ga3167efa9818f821a6af1565859b9e440">pn_raw_connection_write_buffers</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of buffers actually recorded by the raw connection to write. This will only be different from the number supplied if the connection has no more space to record more buffers. In this case the buffers recorded will be the earlier buffers in the array supplied, the elements 0 to the returned value-1. </dd></dl>

</div>
</div>
<a id="ga4169b0f5c64fa2333f147f0eec271129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4169b0f5c64fa2333f147f0eec271129">&#9670;&nbsp;</a></span>pn_raw_connection_take_written_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN size_t pn_raw_connection_take_written_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a buffer chain with buffers that have all been written to the raw socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>pointer to an array of <a class="el" href="group__raw__connection.html#structpn__raw__buffer__t">pn_raw_buffer_t</a> structures which will be filled in with the written buffer information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>the number of buffers allocated in the passed in array of buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of buffers being returned, if there is are no written buffers to return then this will be 0. As many buffers will be returned as can be given the number that are passed in. So if the number returned is less than the number passed in there are no more buffers written. But if the number is the same there may be more written buffers to take.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After the application receives <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa7928b624dab81e3d51a9919954c67b27">PN_RAW_CONNECTION_WRITTEN</a> there should be bytes written to the socket and hence this call should return buffers. It is safe to carry on calling <a class="el" href="group__raw__connection.html#ga4169b0f5c64fa2333f147f0eec271129">pn_raw_connection_take_written_buffers</a> until it returns 0.</dd>
<dd>
The buffers will be returned in the same order as they were originally passed in. </dd></dl>

</div>
</div>
<a id="gaed0d0d70ead71c5d2a64317edf1daca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed0d0d70ead71c5d2a64317edf1daca2">&#9670;&nbsp;</a></span>pn_raw_connection_is_read_closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN bool pn_raw_connection_is_read_closed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is <code>connection</code> closed for read? </p>
<dl class="section return"><dt>Returns</dt><dd>true if the raw connection is closed for read. </dd></dl>

</div>
</div>
<a id="gaf15a987d6a4fc42fb665c6b482cf4442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf15a987d6a4fc42fb665c6b482cf4442">&#9670;&nbsp;</a></span>pn_raw_connection_is_write_closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN bool pn_raw_connection_is_write_closed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is <code>connection</code> closed for write? </p>
<dl class="section return"><dt>Returns</dt><dd>true if the raw connection is closed for write. </dd></dl>

</div>
</div>
<a id="gaca978a14e487ec6a6410f031c2ac0432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca978a14e487ec6a6410f031c2ac0432">&#9670;&nbsp;</a></span>pn_raw_connection_wake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_raw_connection_wake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa471e4c60d57ab77eb9bc1716fa50134d">PN_RAW_CONNECTION_WAKE</a> event for <code>connection</code> as soon as possible. </p>
<p>At least one wake event will be returned, serialized with other <a class="el" href="group__proactor__events.html">Proactor events</a> for the same raw connection. Wakes can be "coalesced" - if several <a class="el" href="group__raw__connection.html#gaca978a14e487ec6a6410f031c2ac0432">pn_raw_connection_wake()</a> calls happen close together, there may be only one <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa471e4c60d57ab77eb9bc1716fa50134d">PN_RAW_CONNECTION_WAKE</a> event that occurs after all of them.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe </dd></dl>

</div>
</div>
<a id="ga5d2e343f71310e1d1d76d677a4cc32cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d2e343f71310e1d1d76d677a4cc32cf">&#9670;&nbsp;</a></span>pn_raw_connection_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__condition.html#ga11eb7db7d2c205169fe3d47c996a95a5">pn_condition_t</a>* pn_raw_connection_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get additional information about a raw connection error. </p>
<p>There is a raw connection error if the <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1278d8c62c5bf1a46f70b1cb2866ab80">PN_RAW_CONNECTION_DISCONNECTED</a> event is received and the pn_condition_t associated is non null (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__condition.html#ga112611a7a4087e050c476a430db2cfb9" title="Returns true if the condition object is holding some information, i.e.">pn_condition_is_set</a>).</dd></dl>
<p>The value returned is only valid until the end of handler for the <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1278d8c62c5bf1a46f70b1cb2866ab80">PN_RAW_CONNECTION_DISCONNECTED</a> event. </p>

</div>
</div>
<a id="gabaa162a817447cadfb08cb742c13baaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa162a817447cadfb08cb742c13baaf">&#9670;&nbsp;</a></span>pn_raw_connection_get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void* pn_raw_connection_get_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the application context associated with this raw connection. </p>
<p>The application context for a raw connection may be set using <a class="el" href="group__raw__connection.html#gafe1796a50ddd8b0987686b556f477e81" title="Set a new application context for a raw connection.">pn_raw_connection_set_context</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connection</td><td>the raw connection whose context is to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the application context for the raw connection </dd></dl>

</div>
</div>
<a id="gafe1796a50ddd8b0987686b556f477e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1796a50ddd8b0987686b556f477e81">&#9670;&nbsp;</a></span>pn_raw_connection_set_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_raw_connection_set_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new application context for a raw connection. </p>
<p>The application context for a raw connection may be retrieved using <a class="el" href="group__raw__connection.html#gabaa162a817447cadfb08cb742c13baaf" title="Get the application context associated with this raw connection.">pn_raw_connection_get_context</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connection</td><td>the raw connection object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the application context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf363bfb40f61c6c368fbf452f0bdd5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf363bfb40f61c6c368fbf452f0bdd5c1">&#9670;&nbsp;</a></span>pn_event_raw_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__raw__connection.html#ga771f248632968276665fb90245023e86">pn_raw_connection_t</a>* pn_event_raw_connection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event.html#ga87f3028b4888632bbd56fb71ac737ae8">pn_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the raw connection associated with an event. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if the event is not associated with a raw connection. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
