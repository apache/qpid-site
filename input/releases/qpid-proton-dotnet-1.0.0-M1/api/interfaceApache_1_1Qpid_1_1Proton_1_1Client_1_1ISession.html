<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Proton DotNet: Apache.Qpid.Proton.Client.ISession Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Proton DotNet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceApache.html">Apache</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid.html">Qpid</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html">Client</a></li><li class="navelem"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Apache.Qpid.Proton.Client.ISession Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A single AMQP session instance.  
 <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Apache.Qpid.Proton.Client.ISession:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.png" usemap="#Apache.Qpid.Proton.Client.ISession_map" alt=""/>
  <map id="Apache.Qpid.Proton.Client.ISession_map" name="Apache.Qpid.Proton.Client.ISession_map">
<area href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html" title="Client session that wraps a proton session instance and provides the higher level clint API for manag..." alt="Apache.Qpid.Proton.Client.Implementation.ClientSession" shape="rect" coords="0,112,369,136"/>
<area href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html" alt="Apache.Qpid.Proton.Client.Implementation.ClientStreamSession" shape="rect" coords="0,168,369,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22cc1167172a92260f5c7ffa83ed93b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a22cc1167172a92260f5c7ffa83ed93b6">Close</a> (<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IErrorCondition.html">IErrorCondition</a> error=null)</td></tr>
<tr class="memdesc:a22cc1167172a92260f5c7ffa83ed93b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a close of the session and awaits a response from the remote that indicates completion of the close operation. If the response from the remote exceeds the configure close timeout the method returns after cleaning up the session resources.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a22cc1167172a92260f5c7ffa83ed93b6">More...</a><br /></td></tr>
<tr class="separator:a22cc1167172a92260f5c7ffa83ed93b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a04f88cd77889e495f9f7c25dc709e2"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a9a04f88cd77889e495f9f7c25dc709e2">CloseAsync</a> (<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IErrorCondition.html">IErrorCondition</a> error=null)</td></tr>
<tr class="memdesc:a9a04f88cd77889e495f9f7c25dc709e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a close of the session and a Task that allows the caller to await or poll for the response from the remote that indicates completion of the close operation. If the response from the remote exceeds the configure close timeout the session will be cleaned up and the Task signalled indicating completion.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a9a04f88cd77889e495f9f7c25dc709e2">More...</a><br /></td></tr>
<tr class="separator:a9a04f88cd77889e495f9f7c25dc709e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb75eda8695cb3393e1500a58eec3d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a9bb75eda8695cb3393e1500a58eec3d2">OpenReceiver</a> (string address, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null)</td></tr>
<tr class="memdesc:a9bb75eda8695cb3393e1500a58eec3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a receiver used to consume messages from the given node address. The returned receiver will be configured using the provided receiver options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a9bb75eda8695cb3393e1500a58eec3d2">More...</a><br /></td></tr>
<tr class="separator:a9bb75eda8695cb3393e1500a58eec3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09df7d29f7c493dc64b68b03286c9ee9"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a09df7d29f7c493dc64b68b03286c9ee9">OpenReceiverAsync</a> (string address, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null)</td></tr>
<tr class="memdesc:a09df7d29f7c493dc64b68b03286c9ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a receiver used to consume messages from the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a09df7d29f7c493dc64b68b03286c9ee9">More...</a><br /></td></tr>
<tr class="separator:a09df7d29f7c493dc64b68b03286c9ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef69d1e55d07ec78daf304962e0f0cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a2ef69d1e55d07ec78daf304962e0f0cc">OpenDurableReceiver</a> (string address, string subscriptionName, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null)</td></tr>
<tr class="memdesc:a2ef69d1e55d07ec78daf304962e0f0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a receiver used to consume messages from the given node address. The returned receiver will be configured using the provided receiver options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a2ef69d1e55d07ec78daf304962e0f0cc">More...</a><br /></td></tr>
<tr class="separator:a2ef69d1e55d07ec78daf304962e0f0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae104c8770276dca1b33d74f8587be343"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae104c8770276dca1b33d74f8587be343">OpenDurableReceiverAsync</a> (string address, string subscriptionName, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null)</td></tr>
<tr class="memdesc:ae104c8770276dca1b33d74f8587be343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a receiver used to consume messages from the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae104c8770276dca1b33d74f8587be343">More...</a><br /></td></tr>
<tr class="separator:ae104c8770276dca1b33d74f8587be343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04ce89189d9e79f0f73faaa78480cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#aa04ce89189d9e79f0f73faaa78480cdb">OpenDynamicReceiver</a> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null, IDictionary&lt; string, object &gt; dynamicNodeProperties=null)</td></tr>
<tr class="memdesc:aa04ce89189d9e79f0f73faaa78480cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamic receiver used to consume messages from the dynamically generated node. on the remote. The returned receiver will be configured using the provided options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#aa04ce89189d9e79f0f73faaa78480cdb">More...</a><br /></td></tr>
<tr class="separator:aa04ce89189d9e79f0f73faaa78480cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce84cc92bb97939457784e986561ce0"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a4ce84cc92bb97939457784e986561ce0">OpenDynamicReceiverAsync</a> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a> options=null, IDictionary&lt; string, object &gt; dynamicNodeProperties=null)</td></tr>
<tr class="memdesc:a4ce84cc92bb97939457784e986561ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamic receiver used to consume messages from the dynamically generated node. on the remote. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a4ce84cc92bb97939457784e986561ce0">More...</a><br /></td></tr>
<tr class="separator:a4ce84cc92bb97939457784e986561ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724491adc9df52e26acefc9a9914c766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a724491adc9df52e26acefc9a9914c766">OpenSender</a> (string address, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a> options=null)</td></tr>
<tr class="memdesc:a724491adc9df52e26acefc9a9914c766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sender used to send messages to the given node address. The returned sender will be configured using configuration options provided.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a724491adc9df52e26acefc9a9914c766">More...</a><br /></td></tr>
<tr class="separator:a724491adc9df52e26acefc9a9914c766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1895c477d732c53df437ffe6869a13ca"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a1895c477d732c53df437ffe6869a13ca">OpenSenderAsync</a> (string address, <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a> options=null)</td></tr>
<tr class="memdesc:a1895c477d732c53df437ffe6869a13ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sender used to send messages to the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a1895c477d732c53df437ffe6869a13ca">More...</a><br /></td></tr>
<tr class="separator:a1895c477d732c53df437ffe6869a13ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4191691d2afea1c011aec94981227da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae4191691d2afea1c011aec94981227da">OpenAnonymousSender</a> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a> options=null)</td></tr>
<tr class="memdesc:ae4191691d2afea1c011aec94981227da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a anonymous sender used to send messages to the "anonymous relay" on the remote. Each message sent must include a "to" address for the remote to route the message. The returned sender will be configured using the provided sender options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae4191691d2afea1c011aec94981227da">More...</a><br /></td></tr>
<tr class="separator:ae4191691d2afea1c011aec94981227da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4adf7a50e3b6630a54e06bb4b7205eb"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab4adf7a50e3b6630a54e06bb4b7205eb">OpenAnonymousSenderAsync</a> (<a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a> options=null)</td></tr>
<tr class="memdesc:ab4adf7a50e3b6630a54e06bb4b7205eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a anonymous sender used to send messages to the "anonymous relay" on the remote. Each message sent must include a "to" address for the remote to route the message. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab4adf7a50e3b6630a54e06bb4b7205eb">More...</a><br /></td></tr>
<tr class="separator:ab4adf7a50e3b6630a54e06bb4b7205eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae624e00036e368b876597ad9a6175520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae624e00036e368b876597ad9a6175520">BeginTransaction</a> ()</td></tr>
<tr class="memdesc:ae624e00036e368b876597ad9a6175520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a new transaction scoped to this <a class="el" href="">Session</a> if one is not already active.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae624e00036e368b876597ad9a6175520">More...</a><br /></td></tr>
<tr class="separator:ae624e00036e368b876597ad9a6175520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a2e3c3fb63efac53446c0191f6a69e"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab2a2e3c3fb63efac53446c0191f6a69e">BeginTransactionAsync</a> ()</td></tr>
<tr class="memdesc:ab2a2e3c3fb63efac53446c0191f6a69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a new transaction scoped to this <a class="el" href="">Session</a> if one is not already active. The transaction will not be considered active until the returned Task is completed.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab2a2e3c3fb63efac53446c0191f6a69e">More...</a><br /></td></tr>
<tr class="separator:ab2a2e3c3fb63efac53446c0191f6a69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2995252a773f97ed448062f5f65b5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab2995252a773f97ed448062f5f65b5c3">CommitTransaction</a> ()</td></tr>
<tr class="memdesc:ab2995252a773f97ed448062f5f65b5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the currently active transaction in this Session.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab2995252a773f97ed448062f5f65b5c3">More...</a><br /></td></tr>
<tr class="separator:ab2995252a773f97ed448062f5f65b5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be1b4b9dffc9fb9ada1c4d52280348e"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a8be1b4b9dffc9fb9ada1c4d52280348e">CommitTransactionAsync</a> ()</td></tr>
<tr class="memdesc:a8be1b4b9dffc9fb9ada1c4d52280348e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously commit the currently active transaction in this Session, the transaction cannot be considered retired until the Task has been completed.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a8be1b4b9dffc9fb9ada1c4d52280348e">More...</a><br /></td></tr>
<tr class="separator:a8be1b4b9dffc9fb9ada1c4d52280348e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2b816af6c3c2339d9f472f1de0216a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#abe2b816af6c3c2339d9f472f1de0216a">RollbackTransaction</a> ()</td></tr>
<tr class="memdesc:abe2b816af6c3c2339d9f472f1de0216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roll back the currently active transaction in this Session.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#abe2b816af6c3c2339d9f472f1de0216a">More...</a><br /></td></tr>
<tr class="separator:abe2b816af6c3c2339d9f472f1de0216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167ebd8c9a6394c06c4531298eb78895"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a167ebd8c9a6394c06c4531298eb78895">RollbackTransactionAsync</a> ()</td></tr>
<tr class="memdesc:a167ebd8c9a6394c06c4531298eb78895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously roll back the currently active transaction in this Session.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a167ebd8c9a6394c06c4531298eb78895">More...</a><br /></td></tr>
<tr class="separator:a167ebd8c9a6394c06c4531298eb78895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa51a3bace953da787e811ae41301e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a2fa51a3bace953da787e811ae41301e6">NextReceiver</a> ()</td></tr>
<tr class="memdesc:a2fa51a3bace953da787e811ae41301e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits indefinitely for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a2fa51a3bace953da787e811ae41301e6">More...</a><br /></td></tr>
<tr class="separator:a2fa51a3bace953da787e811ae41301e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839e75308edc88db46348b340c72bdae"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a839e75308edc88db46348b340c72bdae">NextReceiverAsync</a> ()</td></tr>
<tr class="memdesc:a839e75308edc88db46348b340c72bdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a task that will complete only after a receiver created from this session has a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a839e75308edc88db46348b340c72bdae">More...</a><br /></td></tr>
<tr class="separator:a839e75308edc88db46348b340c72bdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae992a34b6506bc86504ce251177daf24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae992a34b6506bc86504ce251177daf24">NextReceiver</a> (<a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a> policy)</td></tr>
<tr class="memdesc:ae992a34b6506bc86504ce251177daf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits indefinitely for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae992a34b6506bc86504ce251177daf24">More...</a><br /></td></tr>
<tr class="separator:ae992a34b6506bc86504ce251177daf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abc41999965b9beee8e086bf6df3fdc"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a4abc41999965b9beee8e086bf6df3fdc">NextReceiverAsync</a> (<a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a> policy)</td></tr>
<tr class="memdesc:a4abc41999965b9beee8e086bf6df3fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a task that will complete only after a receiver created from this session has a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a4abc41999965b9beee8e086bf6df3fdc">More...</a><br /></td></tr>
<tr class="separator:a4abc41999965b9beee8e086bf6df3fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab331b77fb965e6e07a492f410608cd8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab331b77fb965e6e07a492f410608cd8c">NextReceiver</a> (TimeSpan timeout)</td></tr>
<tr class="memdesc:ab331b77fb965e6e07a492f410608cd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits up to the given timeout for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab331b77fb965e6e07a492f410608cd8c">More...</a><br /></td></tr>
<tr class="separator:ab331b77fb965e6e07a492f410608cd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872d89db7a89cd96b0474c21592da59c"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a872d89db7a89cd96b0474c21592da59c">NextReceiverAsync</a> (TimeSpan timeout)</td></tr>
<tr class="memdesc:a872d89db7a89cd96b0474c21592da59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a task that will complete once a receiver created from this session has a delivery ready for receipt or the given timeout expires. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a872d89db7a89cd96b0474c21592da59c">More...</a><br /></td></tr>
<tr class="separator:a872d89db7a89cd96b0474c21592da59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff2b5efd2f1dcede3b8b2fed65084b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a1ff2b5efd2f1dcede3b8b2fed65084b6">NextReceiver</a> (<a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a> policy, TimeSpan timeout)</td></tr>
<tr class="memdesc:a1ff2b5efd2f1dcede3b8b2fed65084b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits up to the given timeout for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a1ff2b5efd2f1dcede3b8b2fed65084b6">More...</a><br /></td></tr>
<tr class="separator:a1ff2b5efd2f1dcede3b8b2fed65084b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27f2854c30bc8d413ed1ee0e0e6d7a8"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab27f2854c30bc8d413ed1ee0e0e6d7a8">NextReceiverAsync</a> (<a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a> policy, TimeSpan timeout)</td></tr>
<tr class="memdesc:ab27f2854c30bc8d413ed1ee0e0e6d7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a task that will complete once a receiver created from this session has a delivery ready for receipt or the given timeout expires. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ab27f2854c30bc8d413ed1ee0e0e6d7a8">More...</a><br /></td></tr>
<tr class="separator:ab27f2854c30bc8d413ed1ee0e0e6d7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:af38ccd6eb9b0d761ab84b3646efb2cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IClient.html">IClient</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#af38ccd6eb9b0d761ab84b3646efb2cfb">Client</a><code> [get]</code></td></tr>
<tr class="memdesc:af38ccd6eb9b0d761ab84b3646efb2cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent client instance that hosts this session.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#af38ccd6eb9b0d761ab84b3646efb2cfb">More...</a><br /></td></tr>
<tr class="separator:af38ccd6eb9b0d761ab84b3646efb2cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e9b98870fe17493a86037896e367c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IConnection.html">IConnection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a988e9b98870fe17493a86037896e367c">Connection</a><code> [get]</code></td></tr>
<tr class="memdesc:a988e9b98870fe17493a86037896e367c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent connection instance that created this session.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a988e9b98870fe17493a86037896e367c">More...</a><br /></td></tr>
<tr class="separator:a988e9b98870fe17493a86037896e367c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588da7f4bd213ed87d91bba92eddfd6f"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a588da7f4bd213ed87d91bba92eddfd6f">OpenTask</a><code> [get]</code></td></tr>
<tr class="memdesc:a588da7f4bd213ed87d91bba92eddfd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a session is created and returned to the client application it may not be remotely opened yet and if the client needs to wait for completion of the open before proceeding the open task can be fetched and waited upon.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#a588da7f4bd213ed87d91bba92eddfd6f">More...</a><br /></td></tr>
<tr class="separator:a588da7f4bd213ed87d91bba92eddfd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a713c73335d1b8ab75c67742354d8a"><td class="memItemLeft" align="right" valign="top">IReadOnlyDictionary&lt; string, object &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#af9a713c73335d1b8ab75c67742354d8a">Properties</a><code> [get]</code></td></tr>
<tr class="memdesc:af9a713c73335d1b8ab75c67742354d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the properties that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote properties. If the remote provides no properties this method will return null.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#af9a713c73335d1b8ab75c67742354d8a">More...</a><br /></td></tr>
<tr class="separator:af9a713c73335d1b8ab75c67742354d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ad906f3dcc20d704f14d3e3945b4a4"><td class="memItemLeft" align="right" valign="top">IReadOnlyCollection&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae6ad906f3dcc20d704f14d3e3945b4a4">OfferedCapabilities</a><code> [get]</code></td></tr>
<tr class="memdesc:ae6ad906f3dcc20d704f14d3e3945b4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offered capabilities that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote offered capabilities. If the remote provides no offered capabilities this method will return null.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#ae6ad906f3dcc20d704f14d3e3945b4a4">More...</a><br /></td></tr>
<tr class="separator:ae6ad906f3dcc20d704f14d3e3945b4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78617ec27836349d427bab2fca774ad"><td class="memItemLeft" align="right" valign="top">IReadOnlyCollection&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#aa78617ec27836349d427bab2fca774ad">DesiredCapabilities</a><code> [get]</code></td></tr>
<tr class="memdesc:aa78617ec27836349d427bab2fca774ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the desired capabilities that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote desired capabilities. If the remote provides no desired capabilities this method will return null.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html#aa78617ec27836349d427bab2fca774ad">More...</a><br /></td></tr>
<tr class="separator:aa78617ec27836349d427bab2fca774ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single AMQP session instance. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae624e00036e368b876597ad9a6175520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae624e00036e368b876597ad9a6175520">&#9670;&nbsp;</a></span>BeginTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> Apache.Qpid.Proton.Client.ISession.BeginTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a new transaction scoped to this <a class="el" href="">Session</a> if one is not already active. </p>
<p>A Session that has an active transaction will perform all sends and all delivery dispositions under that active transaction. If the user wishes to send with the same session but outside of a transaction they user must commit the active transaction and not request that a new one be started. A session can only have one active transaction at a time and as such any call to begin while there is a currently active transaction will throw an ClientTransactionNotActiveException to indicate that the operation being requested is not valid at that time. </p>
<p>This is a blocking method that will return successfully only after a new transaction has been started. </p>
<dl class="section return"><dt>Returns</dt><dd>This Session instance</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a425fff36f2e16fe6dba9346df9d40c73">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="ab2a2e3c3fb63efac53446c0191f6a69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a2e3c3fb63efac53446c0191f6a69e">&#9670;&nbsp;</a></span>BeginTransactionAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&gt; Apache.Qpid.Proton.Client.ISession.BeginTransactionAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a new transaction scoped to this <a class="el" href="">Session</a> if one is not already active. The transaction will not be considered active until the returned Task is completed. </p>
<p>A Session that has an active transaction will perform all sends and all delivery dispositions under that active transaction. If the user wishes to send with the same session but outside of a transaction they user must commit the active transaction and not request that a new one be started. A session can only have one active transaction at a time and as such any call to begin while there is a currently active transaction will throw an ClientTransactionNotActiveException to indicate that the operation being requested is not valid at that time. </p>
<dl class="section return"><dt>Returns</dt><dd>A Task whose result is the Session instance now under a transaction</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#acc5f9467d761e486dbe638f16d24cabe">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a22cc1167172a92260f5c7ffa83ed93b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cc1167172a92260f5c7ffa83ed93b6">&#9670;&nbsp;</a></span>Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Apache.Qpid.Proton.Client.ISession.Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IErrorCondition.html">IErrorCondition</a>&#160;</td>
          <td class="paramname"><em>error</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a close of the session and awaits a response from the remote that indicates completion of the close operation. If the response from the remote exceeds the configure close timeout the method returns after cleaning up the session resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Optional error condition to convey to the remote</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a61f9f9094c2b44934b1ebc0297d27fcf">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a9a04f88cd77889e495f9f7c25dc709e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a04f88cd77889e495f9f7c25dc709e2">&#9670;&nbsp;</a></span>CloseAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&gt; Apache.Qpid.Proton.Client.ISession.CloseAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IErrorCondition.html">IErrorCondition</a>&#160;</td>
          <td class="paramname"><em>error</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a close of the session and a Task that allows the caller to await or poll for the response from the remote that indicates completion of the close operation. If the response from the remote exceeds the configure close timeout the session will be cleaned up and the Task signalled indicating completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Optional error condition to convey to the remote</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ad8db042150dec3321b4412d5651ffd83">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="ab2995252a773f97ed448062f5f65b5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2995252a773f97ed448062f5f65b5c3">&#9670;&nbsp;</a></span>CommitTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> Apache.Qpid.Proton.Client.ISession.CommitTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit the currently active transaction in this Session. </p>
<p>Commit the currently active transaction in this Session but does not start a new transaction automatically. If there is no current transaction this method will throw an ClientTransactionNotActiveException to indicate this error. If the active transaction has entered an in doubt state or was remotely rolled back this method will throw an error to indicate that the commit failed and that a new transaction need to be started by the user. When a transaction rolled back error occurs the user should assume that all work performed under that transaction has failed and will need to be attempted under a new transaction. </p>
<p>This is a blocking method that will return successfully only after the transaction has been committed. </p>
<dl class="section return"><dt>Returns</dt><dd>This Session instance</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ad1b84c43aeff41dfca3f8609bb3d9d4d">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a8be1b4b9dffc9fb9ada1c4d52280348e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be1b4b9dffc9fb9ada1c4d52280348e">&#9670;&nbsp;</a></span>CommitTransactionAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&gt; Apache.Qpid.Proton.Client.ISession.CommitTransactionAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously commit the currently active transaction in this Session, the transaction cannot be considered retired until the Task has been completed. </p>
<p>Commit the currently active transaction in this Session but does not start a new transaction automatically. If there is no current transaction this method fails the returned Task with an ClientTransactionNotActiveException to indicate this error. If the active transaction has entered an in doubt state or was remotely rolled back this method fail the Task with an error to indicate that the commit failed and that a new transaction need to be started by the user. When a transaction rolled back error occurs the user should assume that all work performed under that transaction has failed and will need to be attempted under a new transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>A Task whose result is the Session no longer under a transaction</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a61b3a266f65b9020632788bd73763d74">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a2fa51a3bace953da787e811ae41301e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa51a3bace953da787e811ae41301e6">&#9670;&nbsp;</a></span>NextReceiver() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.ISession.NextReceiver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits indefinitely for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options. </p>
<dl class="section return"><dt>Returns</dt><dd>The next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a3b6a835c7c04e41091004fa4efa09c9d">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#ac21d5617a3644f940ab26909892c84a2">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="ae992a34b6506bc86504ce251177daf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae992a34b6506bc86504ce251177daf24">&#9670;&nbsp;</a></span>NextReceiver() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.ISession.NextReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits indefinitely for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The next receiver policy to apply when selecting a result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a316fbdd4cba9a9dae0212f249f00f4df">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#ac5c98fc86faaa50aaa26b99d785082f4">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a1ff2b5efd2f1dcede3b8b2fed65084b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff2b5efd2f1dcede3b8b2fed65084b6">&#9670;&nbsp;</a></span>NextReceiver() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.ISession.NextReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits up to the given timeout for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The next receiver policy to apply when selecting a result</td></tr>
    <tr><td class="paramname">timeout</td><td>The time to wait for a receiver to have a pending delivery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Task that results in the next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a5623647e0682b3869d2d2b19b4b279f2">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#adb9f125db3f349dbaf0c44f1a311fa70">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="ab331b77fb965e6e07a492f410608cd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab331b77fb965e6e07a492f410608cd8c">&#9670;&nbsp;</a></span>NextReceiver() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.ISession.NextReceiver </td>
          <td>(</td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits up to the given timeout for a receiver created from this session to have a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The time to wait for a receiver to have a pending delivery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a116412ddeca6299cdb3eb7cc42bc4813">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a5d8a71c72476fc6ea02b4d2308c94b5d">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a839e75308edc88db46348b340c72bdae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839e75308edc88db46348b340c72bdae">&#9670;&nbsp;</a></span>NextReceiverAsync() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.ISession.NextReceiverAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a task that will complete only after a receiver created from this session has a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options. </p>
<dl class="section return"><dt>Returns</dt><dd>A Task that results in the next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a035f8b87d9f346b80e29349a9c38d916">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a9403b51dbe368f4d6fbadf1200cbfb6c">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a4abc41999965b9beee8e086bf6df3fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abc41999965b9beee8e086bf6df3fdc">&#9670;&nbsp;</a></span>NextReceiverAsync() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.ISession.NextReceiverAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a task that will complete only after a receiver created from this session has a delivery ready for receipt. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The next receiver policy to apply when selecting a result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Task that results in the next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#aa552ed2d5e303c5c58f73f54c08cc561">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a4ec55819e08ed6e850a912d74721f082">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="ab27f2854c30bc8d413ed1ee0e0e6d7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27f2854c30bc8d413ed1ee0e0e6d7a8">&#9670;&nbsp;</a></span>NextReceiverAsync() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.ISession.NextReceiverAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html#a29fcbe719c1b2f22561850a3dc0203ff">NextReceiverPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a task that will complete once a receiver created from this session has a delivery ready for receipt or the given timeout expires. The selection of the next receiver when more than one exists which has pending deliveries is based upon the value of the next receiver policy that is provided by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The next receiver policy to apply when selecting a result</td></tr>
    <tr><td class="paramname">timeout</td><td>The time to wait for a receiver to have a pending delivery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Task that results in the next receiver that has a pending delivery available based on policy.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a1a4a00ff43127ecd5900069a93d3c257">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a055f3774286cc10d89f10badff8b60d9">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a872d89db7a89cd96b0474c21592da59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872d89db7a89cd96b0474c21592da59c">&#9670;&nbsp;</a></span>NextReceiverAsync() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.ISession.NextReceiverAsync </td>
          <td>(</td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a task that will complete once a receiver created from this session has a delivery ready for receipt or the given timeout expires. The selection of the next receiver when more than one exists which has pending deliveries is based upon the configured value of the default next receiver policy that was configured in the session options used to create this session, or the connection level policy if none was assigned to the session options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The time to wait for a receiver to have a pending delivery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ab4b1459f1e40685ad38ce1bc05751d05">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a9c6cd94b070f404aac21086707358d6e">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="ae4191691d2afea1c011aec94981227da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4191691d2afea1c011aec94981227da">&#9670;&nbsp;</a></span>OpenAnonymousSender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a> Apache.Qpid.Proton.Client.ISession.OpenAnonymousSender </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a anonymous sender used to send messages to the "anonymous relay" on the remote. Each message sent must include a "to" address for the remote to route the message. The returned sender will be configured using the provided sender options. </p>
<p>The returned sender may not have been opened on the remote when it is returned. Some methods of the sender can block until the remote fully opens the sender, the user can wait for the remote to respond to the open request by obtaining the open task from the sender and using it to await the completion of the sender open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional sender options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sender instance.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#aec48183c29e9403a8501440b87d63fc9">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aee9a936805f1f5be44403098f85203c7">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="ab4adf7a50e3b6630a54e06bb4b7205eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4adf7a50e3b6630a54e06bb4b7205eb">&#9670;&nbsp;</a></span>OpenAnonymousSenderAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a>&gt; Apache.Qpid.Proton.Client.ISession.OpenAnonymousSenderAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a anonymous sender used to send messages to the "anonymous relay" on the remote. Each message sent must include a "to" address for the remote to route the message. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned sender may not have been opened on the remote when it is returned. Some methods of the sender can block until the remote fully opens the sender, the user can wait for the remote to respond to the open request by obtaining the open task from the sender and using it to await the completion of the sender open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional sender options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;ISender&gt; instance.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a7c3ef30f8cb175937a5d5df1ac7dbe43">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a50ede4a1eb616f3f1c5070c2f4b23e30">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a2ef69d1e55d07ec78daf304962e0f0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef69d1e55d07ec78daf304962e0f0cc">&#9670;&nbsp;</a></span>OpenDurableReceiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.ISession.OpenDurableReceiver </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>subscriptionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a receiver used to consume messages from the given node address. The returned receiver will be configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the receiver attaches to</td></tr>
    <tr><td class="paramname">subscriptionName</td><td>The subscription name to use for the receiver</td></tr>
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new receiver instance</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#af4e811f7deecb904ed5b32f83285444a">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a1de83c24446b4fd9ff715d807c9c9d5e">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="ae104c8770276dca1b33d74f8587be343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae104c8770276dca1b33d74f8587be343">&#9670;&nbsp;</a></span>OpenDurableReceiverAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.ISession.OpenDurableReceiverAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>subscriptionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a receiver used to consume messages from the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the receiver attaches to</td></tr>
    <tr><td class="paramname">subscriptionName</td><td>The subscription name to use for the receiver</td></tr>
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;Receiver&gt; instance that can be awaited</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#ac01272ea873a476ccf3de8b9cefabb41">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a79fde76a2cdc0a566db3fde8b8faeeb0">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="aa04ce89189d9e79f0f73faaa78480cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04ce89189d9e79f0f73faaa78480cdb">&#9670;&nbsp;</a></span>OpenDynamicReceiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.ISession.OpenDynamicReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDictionary&lt; string, object &gt;&#160;</td>
          <td class="paramname"><em>dynamicNodeProperties</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamic receiver used to consume messages from the dynamically generated node. on the remote. The returned receiver will be configured using the provided options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
    <tr><td class="paramname">dynamicNodeProperties</td><td>Optional properties to assign to the node create</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new receiver instance</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#aaa8aa112144d241fc494a5c34984992f">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a46c3522ef5200e303c1ba66e6e86b079">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a4ce84cc92bb97939457784e986561ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce84cc92bb97939457784e986561ce0">&#9670;&nbsp;</a></span>OpenDynamicReceiverAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.ISession.OpenDynamicReceiverAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDictionary&lt; string, object &gt;&#160;</td>
          <td class="paramname"><em>dynamicNodeProperties</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamic receiver used to consume messages from the dynamically generated node. on the remote. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
    <tr><td class="paramname">dynamicNodeProperties</td><td>Optional properties to assign to the node create</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;Receiver&gt; instance that can be awaited</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a3be8e88201e8d18d1d6ef3f1e73b9e7f">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aeb569e41cab972b1f4c5618a76a14b26">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a9bb75eda8695cb3393e1500a58eec3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb75eda8695cb3393e1500a58eec3d2">&#9670;&nbsp;</a></span>OpenReceiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.ISession.OpenReceiver </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a receiver used to consume messages from the given node address. The returned receiver will be configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the receiver attaches to</td></tr>
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new receiver instance</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a9fb770fb421efe532cfd648e849c2d5a">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a22ef0e478638dc4b05eb35fb17117939">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a09df7d29f7c493dc64b68b03286c9ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09df7d29f7c493dc64b68b03286c9ee9">&#9670;&nbsp;</a></span>OpenReceiverAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.ISession.OpenReceiverAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1ReceiverOptions.html">ReceiverOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a receiver used to consume messages from the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned receiver may not have been opened on the remote when it is returned. Some methods of the receiver can block until the remote fully opens the receiver, the user can wait for the remote to respond to the open request by obtaining the open task from the receiver and using it to await the completion of the receiver open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the receiver attaches to</td></tr>
    <tr><td class="paramname">options</td><td>Optional receiver options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;Receiver&gt; instance that can be awaited</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a433f896714fa12e46eb6842c14074c6f">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#a38fbe3f6d97b80e55f4dfdd9396c4165">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a724491adc9df52e26acefc9a9914c766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724491adc9df52e26acefc9a9914c766">&#9670;&nbsp;</a></span>OpenSender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a> Apache.Qpid.Proton.Client.ISession.OpenSender </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a sender used to send messages to the given node address. The returned sender will be configured using configuration options provided. </p>
<p>The returned sender may not have been opened on the remote when it is returned. Some methods of the sender can block until the remote fully opens the sender, the user can wait for the remote to respond to the open request by obtaining the open task from the sender and using it to await the completion of the sender open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the sender attaches to</td></tr>
    <tr><td class="paramname">options</td><td>Optional sender options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sender instance.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#aef1456ca7e5aca731b83ff45d1328180">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#aef36457ae53038a07ca66737033eb9ed">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="a1895c477d732c53df437ffe6869a13ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1895c477d732c53df437ffe6869a13ca">&#9670;&nbsp;</a></span>OpenSenderAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISender.html">ISender</a>&gt; Apache.Qpid.Proton.Client.ISession.OpenSenderAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1SenderOptions.html">SenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a sender used to send messages to the given node address. The returned Task will allow the caller to wait for the creation of the receiver configured using the provided receiver options. </p>
<p>The returned sender may not have been opened on the remote when it is returned. Some methods of the sender can block until the remote fully opens the sender, the user can wait for the remote to respond to the open request by obtaining the open task from the sender and using it to await the completion of the sender open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the node the sender attaches to</td></tr>
    <tr><td class="paramname">options</td><td>Optional sender options to use for configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Task&lt;ISender&gt; instance.</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a2443bd6c61c9fdba65ac35dde478371a">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>, and <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientStreamSession.html#af24cb15933159431c2136adad2bfc811">Apache.Qpid.Proton.Client.Implementation.ClientStreamSession</a>.</p>

</div>
</div>
<a id="abe2b816af6c3c2339d9f472f1de0216a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2b816af6c3c2339d9f472f1de0216a">&#9670;&nbsp;</a></span>RollbackTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a> Apache.Qpid.Proton.Client.ISession.RollbackTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Roll back the currently active transaction in this Session. </p>
<p>Roll back the currently active transaction in this Session but does not automatically start a new transaction. If there is no current transaction this method will throw an ClientTransactionNotActiveException to indicate this error. If the active transaction has entered an in doubt state or was remotely rolled back this method will throw an error to indicate that the roll back failed and that a new transaction need to be started by the user. </p>
<p>This is a blocking method that will return successfully only after the transaction has been rolled back. </p>
<dl class="section return"><dt>Returns</dt><dd>This Session instance</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a8b4af6573350431da0a744820735b510">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<a id="a167ebd8c9a6394c06c4531298eb78895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167ebd8c9a6394c06c4531298eb78895">&#9670;&nbsp;</a></span>RollbackTransactionAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&gt; Apache.Qpid.Proton.Client.ISession.RollbackTransactionAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously roll back the currently active transaction in this Session. </p>
<p>Roll back the currently active transaction in this Session but does not automatically start a new transaction. If there is no current transaction this method fails the returned Task an ClientTransactionNotActiveException to indicate this error. If the active transaction has entered an in doubt state or was remotely rolled back this method will fail the returned Task with an error to indicate that the roll back failed and that a new transaction need to be started by the user. </p>
<dl class="section return"><dt>Returns</dt><dd>A Task whose result is the Session no longer under a transaction</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientSession.html#a0fa1884176bdb2df80f1c34016ca8e66">Apache.Qpid.Proton.Client.Implementation.ClientSession</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="af38ccd6eb9b0d761ab84b3646efb2cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38ccd6eb9b0d761ab84b3646efb2cfb">&#9670;&nbsp;</a></span>Client</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IClient.html">IClient</a> Apache.Qpid.Proton.Client.ISession.Client</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent client instance that hosts this session. </p>

</div>
</div>
<a id="a988e9b98870fe17493a86037896e367c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988e9b98870fe17493a86037896e367c">&#9670;&nbsp;</a></span>Connection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IConnection.html">IConnection</a> Apache.Qpid.Proton.Client.ISession.Connection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent connection instance that created this session. </p>

</div>
</div>
<a id="aa78617ec27836349d427bab2fca774ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78617ec27836349d427bab2fca774ad">&#9670;&nbsp;</a></span>DesiredCapabilities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IReadOnlyCollection&lt;string&gt; Apache.Qpid.Proton.Client.ISession.DesiredCapabilities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the desired capabilities that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote desired capabilities. If the remote provides no desired capabilities this method will return null. </p>

</div>
</div>
<a id="ae6ad906f3dcc20d704f14d3e3945b4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ad906f3dcc20d704f14d3e3945b4a4">&#9670;&nbsp;</a></span>OfferedCapabilities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IReadOnlyCollection&lt;string&gt; Apache.Qpid.Proton.Client.ISession.OfferedCapabilities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offered capabilities that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote offered capabilities. If the remote provides no offered capabilities this method will return null. </p>

</div>
</div>
<a id="a588da7f4bd213ed87d91bba92eddfd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588da7f4bd213ed87d91bba92eddfd6f">&#9670;&nbsp;</a></span>OpenTask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ISession.html">ISession</a>&gt; Apache.Qpid.Proton.Client.ISession.OpenTask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When a session is created and returned to the client application it may not be remotely opened yet and if the client needs to wait for completion of the open before proceeding the open task can be fetched and waited upon. </p>

</div>
</div>
<a id="af9a713c73335d1b8ab75c67742354d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a713c73335d1b8ab75c67742354d8a">&#9670;&nbsp;</a></span>Properties</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IReadOnlyDictionary&lt;string, object&gt; Apache.Qpid.Proton.Client.ISession.Properties</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the properties that the remote provided upon successfully opening the session. If the open has not completed yet this method will block to await the open response which carries the remote properties. If the remote provides no properties this method will return null. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>src/Proton.Client/Client/ISession.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
