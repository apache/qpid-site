<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Proton DotNet: Apache.Qpid.Proton.Client.IReceiver Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Proton DotNet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceApache.html">Apache</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid.html">Qpid</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Client.html">Client</a></li><li class="navelem"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Apache.Qpid.Proton.Client.IReceiver Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A single AMQP receiver instance.  
 <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Apache.Qpid.Proton.Client.IReceiver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.png" usemap="#Apache.Qpid.Proton.Client.IReceiver_map" alt=""/>
  <map id="Apache.Qpid.Proton.Client.IReceiver_map" name="Apache.Qpid.Proton.Client.IReceiver_map">
<area href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1ILink.html" alt="Apache.Qpid.Proton.Client.ILink&lt; IReceiver &gt;" shape="rect" coords="0,0,337,24"/>
<area href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientReceiver.html" title="Client receiver implementation which provides a wrapper around the proton receiver link and processes..." alt="Apache.Qpid.Proton.Client.Implementation.ClientReceiver" shape="rect" coords="0,112,337,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a965da284bdb4def86451b896e8ca58e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a965da284bdb4def86451b896e8ca58e9">AddCredit</a> (uint credit)</td></tr>
<tr class="memdesc:a965da284bdb4def86451b896e8ca58e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds credit to the Receiver link for use when there receiver has not been configured with with a credit window. When credit window is configured credit replenishment is automatic and calling this method will result in an exception indicating that the operation is invalid.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a965da284bdb4def86451b896e8ca58e9">More...</a><br /></td></tr>
<tr class="separator:a965da284bdb4def86451b896e8ca58e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6edce24222af437c08270ef9bcc09a5"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#aa6edce24222af437c08270ef9bcc09a5">AddCreditAsync</a> (uint credit)</td></tr>
<tr class="memdesc:aa6edce24222af437c08270ef9bcc09a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously Adds credit to the Receiver link for use when there receiver has not been configured with with a credit window. When credit window is configured credit replenishment is automatic and calling this method will result in an exception indicating that the operation is invalid.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#aa6edce24222af437c08270ef9bcc09a5">More...</a><br /></td></tr>
<tr class="separator:aa6edce24222af437c08270ef9bcc09a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63215ee7a017f6871d483c68b31c8567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a63215ee7a017f6871d483c68b31c8567">Receive</a> ()</td></tr>
<tr class="memdesc:a63215ee7a017f6871d483c68b31c8567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking receive method that waits forever for the remote to provide a delivery for consumption.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a63215ee7a017f6871d483c68b31c8567">More...</a><br /></td></tr>
<tr class="separator:a63215ee7a017f6871d483c68b31c8567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7996145520ea9c47953199b1550e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a6d7996145520ea9c47953199b1550e8a">Receive</a> (TimeSpan timeout)</td></tr>
<tr class="memdesc:a6d7996145520ea9c47953199b1550e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking receive method that waits for the specified time period for the remote to provide a delivery for consumption before returning null if none was received.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a6d7996145520ea9c47953199b1550e8a">More...</a><br /></td></tr>
<tr class="separator:a6d7996145520ea9c47953199b1550e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744c014c34315bcd333cce1ae61e863c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a744c014c34315bcd333cce1ae61e863c">TryReceive</a> ()</td></tr>
<tr class="memdesc:a744c014c34315bcd333cce1ae61e863c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mostly Non-blocking receive method that either returns a delivery if one is immediately available or returns null if none is currently at hand. It is possible that this method will block for short time intervals while acquiring and releasing internal locks.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a744c014c34315bcd333cce1ae61e863c">More...</a><br /></td></tr>
<tr class="separator:a744c014c34315bcd333cce1ae61e863c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1d0a14e0954bfa21de6535c9f01f57"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#adb1d0a14e0954bfa21de6535c9f01f57">ReceiveAsync</a> ()</td></tr>
<tr class="memdesc:adb1d0a14e0954bfa21de6535c9f01f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous receive method that waits forever for the remote to provide a delivery for consumption and when a delivery is available the returned Task will be completed.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#adb1d0a14e0954bfa21de6535c9f01f57">More...</a><br /></td></tr>
<tr class="separator:adb1d0a14e0954bfa21de6535c9f01f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786410323d2d2a4d66738d5e1489f6bd"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a786410323d2d2a4d66738d5e1489f6bd">ReceiveAsync</a> (TimeSpan timeout)</td></tr>
<tr class="memdesc:a786410323d2d2a4d66738d5e1489f6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous receive method that returns a Task that will be completed after the specified time period if the remote to provides a delivery for consumption before completing with null if none was received.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a786410323d2d2a4d66738d5e1489f6bd">More...</a><br /></td></tr>
<tr class="separator:a786410323d2d2a4d66738d5e1489f6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3565cebe3f1fbfaf539e1d0e86f2cd"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a3f3565cebe3f1fbfaf539e1d0e86f2cd">TryReceiveAsync</a> ()</td></tr>
<tr class="memdesc:a3f3565cebe3f1fbfaf539e1d0e86f2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous receive method that returns a Task which will be completed either with a currently available delivery or with null to indicate there are no queued deliveries.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#a3f3565cebe3f1fbfaf539e1d0e86f2cd">More...</a><br /></td></tr>
<tr class="separator:a3f3565cebe3f1fbfaf539e1d0e86f2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f2688a0b37850020150ccbbc4b196c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#ad5f2688a0b37850020150ccbbc4b196c">Drain</a> ()</td></tr>
<tr class="memdesc:ad5f2688a0b37850020150ccbbc4b196c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the remote to drain previously granted credit for this receiver link. The remote will either send all available deliveries up to the currently granted link credit or will report it has none to send an link credit will be set to zero. This method will block until the remote answers the drain request or the configured drain timeout expires.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#ad5f2688a0b37850020150ccbbc4b196c">More...</a><br /></td></tr>
<tr class="separator:ad5f2688a0b37850020150ccbbc4b196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac351fe0ca65d03582f4c823b2462d851"><td class="memItemLeft" align="right" valign="top">Task&lt; <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#ac351fe0ca65d03582f4c823b2462d851">DrainAsync</a> ()</td></tr>
<tr class="memdesc:ac351fe0ca65d03582f4c823b2462d851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the remote to drain previously granted credit for this receiver link. The remote will either send all available deliveries up to the currently granted link credit or will report it has none to send an link credit will be set to zero. The caller can wait on the returned task which will be signalled either after the remote reports drained or once the configured drain timeout is reached.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#ac351fe0ca65d03582f4c823b2462d851">More...</a><br /></td></tr>
<tr class="separator:ac351fe0ca65d03582f4c823b2462d851"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ab10ec2e9cfbf7ddd9995d60552b33636"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#ab10ec2e9cfbf7ddd9995d60552b33636">QueuedDeliveries</a><code> [get]</code></td></tr>
<tr class="memdesc:ab10ec2e9cfbf7ddd9995d60552b33636"><td class="mdescLeft">&#160;</td><td class="mdescRight">A count of the currently queued deliveries which can be read immediately without blocking a call to receive.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html#ab10ec2e9cfbf7ddd9995d60552b33636">More...</a><br /></td></tr>
<tr class="separator:ab10ec2e9cfbf7ddd9995d60552b33636"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single AMQP receiver instance. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a965da284bdb4def86451b896e8ca58e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965da284bdb4def86451b896e8ca58e9">&#9670;&nbsp;</a></span>AddCredit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.IReceiver.AddCredit </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>credit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds credit to the Receiver link for use when there receiver has not been configured with with a credit window. When credit window is configured credit replenishment is automatic and calling this method will result in an exception indicating that the operation is invalid. </p>
<p>If the Receiver is draining and this method is called an exception will be thrown to indicate that credit cannot be replenished until the remote has drained the existing link credit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">credit</td><td>The amount of new credit to add to the existing credit if any</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This receiver instance.</dd></dl>

</div>
</div>
<a id="aa6edce24222af437c08270ef9bcc09a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6edce24222af437c08270ef9bcc09a5">&#9670;&nbsp;</a></span>AddCreditAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.IReceiver.AddCreditAsync </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>credit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously Adds credit to the Receiver link for use when there receiver has not been configured with with a credit window. When credit window is configured credit replenishment is automatic and calling this method will result in an exception indicating that the operation is invalid. </p>
<p>If the Receiver is draining and this method is called an exception will be thrown to indicate that credit cannot be replenished until the remote has drained the existing link credit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">credit</td><td>The amount of new credit to add to the existing credit if any</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This receiver instance.</dd></dl>

</div>
</div>
<a id="ad5f2688a0b37850020150ccbbc4b196c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f2688a0b37850020150ccbbc4b196c">&#9670;&nbsp;</a></span>Drain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a> Apache.Qpid.Proton.Client.IReceiver.Drain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the remote to drain previously granted credit for this receiver link. The remote will either send all available deliveries up to the currently granted link credit or will report it has none to send an link credit will be set to zero. This method will block until the remote answers the drain request or the configured drain timeout expires. </p>
<dl class="section return"><dt>Returns</dt><dd>This receiver instance once the remote reports drain completed</dd></dl>

</div>
</div>
<a id="ac351fe0ca65d03582f4c823b2462d851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac351fe0ca65d03582f4c823b2462d851">&#9670;&nbsp;</a></span>DrainAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IReceiver.html">IReceiver</a>&gt; Apache.Qpid.Proton.Client.IReceiver.DrainAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the remote to drain previously granted credit for this receiver link. The remote will either send all available deliveries up to the currently granted link credit or will report it has none to send an link credit will be set to zero. The caller can wait on the returned task which will be signalled either after the remote reports drained or once the configured drain timeout is reached. </p>
<dl class="section return"><dt>Returns</dt><dd>A Task that will be completed when the remote reports drained.</dd></dl>

</div>
</div>
<a id="a63215ee7a017f6871d483c68b31c8567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63215ee7a017f6871d483c68b31c8567">&#9670;&nbsp;</a></span>Receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a> Apache.Qpid.Proton.Client.IReceiver.Receive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking receive method that waits forever for the remote to provide a delivery for consumption. </p>
<p>Receive calls will only grant credit on their own if a credit window is configured in the options which by default will have been configured. If the client application has not configured a credit window then this method won't grant or extend the credit window but will wait for a delivery regardless. The application needs to arrange for credit to be granted in that case. </p>
<dl class="section return"><dt>Returns</dt><dd>The next available delivery</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientReceiver.html#a992de99a143960adc187f25ecd0643e3">Apache.Qpid.Proton.Client.Implementation.ClientReceiver</a>.</p>

</div>
</div>
<a id="a6d7996145520ea9c47953199b1550e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7996145520ea9c47953199b1550e8a">&#9670;&nbsp;</a></span>Receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a> Apache.Qpid.Proton.Client.IReceiver.Receive </td>
          <td>(</td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking receive method that waits for the specified time period for the remote to provide a delivery for consumption before returning null if none was received. </p>
<p>Receive calls will only grant credit on their own if a credit window is configured in the options which by default will have been configured. If the client application has not configured a credit window then this method won't grant or extend the credit window but will wait for a delivery regardless. The application needs to arrange for credit to be granted in that case. </p>
<dl class="section return"><dt>Returns</dt><dd>The next available delivery or null if the time span elapses</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientReceiver.html#a55789b99206998e4b8b58bf350260774">Apache.Qpid.Proton.Client.Implementation.ClientReceiver</a>.</p>

</div>
</div>
<a id="adb1d0a14e0954bfa21de6535c9f01f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1d0a14e0954bfa21de6535c9f01f57">&#9670;&nbsp;</a></span>ReceiveAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a>&gt; Apache.Qpid.Proton.Client.IReceiver.ReceiveAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous receive method that waits forever for the remote to provide a delivery for consumption and when a delivery is available the returned Task will be completed. </p>
<p>Receive calls will only grant credit on their own if a credit window is configured in the options which by default will have been configured. If the client application has not configured a credit window then this method won't grant or extend the credit window but will wait for a delivery regardless. The application needs to arrange for credit to be granted in that case. </p>
<dl class="section return"><dt>Returns</dt><dd>The next available delivery</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientReceiver.html#af65ffecc27169d11f94c5db6b87cb8b4">Apache.Qpid.Proton.Client.Implementation.ClientReceiver</a>.</p>

</div>
</div>
<a id="a786410323d2d2a4d66738d5e1489f6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786410323d2d2a4d66738d5e1489f6bd">&#9670;&nbsp;</a></span>ReceiveAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a>&gt; Apache.Qpid.Proton.Client.IReceiver.ReceiveAsync </td>
          <td>(</td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous receive method that returns a Task that will be completed after the specified time period if the remote to provides a delivery for consumption before completing with null if none was received. </p>
<p>Receive calls will only grant credit on their own if a credit window is configured in the options which by default will have been configured. If the client application has not configured a credit window then this method won't grant or extend the credit window but will wait for a delivery regardless. The application needs to arrange for credit to be granted in that case. </p>
<dl class="section return"><dt>Returns</dt><dd>The next available delivery or null if the time span elapses</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientReceiver.html#a20eba20bf3e8d4438567c2524d7d9a53">Apache.Qpid.Proton.Client.Implementation.ClientReceiver</a>.</p>

</div>
</div>
<a id="a744c014c34315bcd333cce1ae61e863c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744c014c34315bcd333cce1ae61e863c">&#9670;&nbsp;</a></span>TryReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a> Apache.Qpid.Proton.Client.IReceiver.TryReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mostly Non-blocking receive method that either returns a delivery if one is immediately available or returns null if none is currently at hand. It is possible that this method will block for short time intervals while acquiring and releasing internal locks. </p>
<dl class="section return"><dt>Returns</dt><dd>A delivery if one is immediately available or null if not</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientReceiver.html#a5bcb4bdd72e1e5fe6f2d95af5066839c">Apache.Qpid.Proton.Client.Implementation.ClientReceiver</a>.</p>

</div>
</div>
<a id="a3f3565cebe3f1fbfaf539e1d0e86f2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3565cebe3f1fbfaf539e1d0e86f2cd">&#9670;&nbsp;</a></span>TryReceiveAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Client_1_1IDelivery.html">IDelivery</a>&gt; Apache.Qpid.Proton.Client.IReceiver.TryReceiveAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous receive method that returns a Task which will be completed either with a currently available delivery or with null to indicate there are no queued deliveries. </p>
<dl class="section return"><dt>Returns</dt><dd>A Task that completes with a delivery if one is immediately available or null if not</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Client_1_1Implementation_1_1ClientReceiver.html#a0eda2a8ede4dc4cfc26a2407d91a0cc1">Apache.Qpid.Proton.Client.Implementation.ClientReceiver</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="ab10ec2e9cfbf7ddd9995d60552b33636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10ec2e9cfbf7ddd9995d60552b33636">&#9670;&nbsp;</a></span>QueuedDeliveries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Apache.Qpid.Proton.Client.IReceiver.QueuedDeliveries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A count of the currently queued deliveries which can be read immediately without blocking a call to receive. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>src/Proton.Client/Client/IReceiver.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
