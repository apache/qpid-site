<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qpid Proton C API: Proactor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C API
   &#160;<span id="projectnumber">0.22.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__proactor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Proactor<div class="ingroups"><a class="el" href="group__io.html">IO</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><b>Unsettled API</b> - An API for multithreaded IO.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga29ae114b42fb797c103dc9883ebcb256"><td class="memItemLeft" align="right" valign="top"><a id="ga29ae114b42fb797c103dc9883ebcb256"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga29ae114b42fb797c103dc9883ebcb256">PN_MAX_ADDR</a></td></tr>
<tr class="memdesc:ga29ae114b42fb797c103dc9883ebcb256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of buffer that can hold the largest connection or listening address. <br /></td></tr>
<tr class="separator:ga29ae114b42fb797c103dc9883ebcb256"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga79d820cd3ad391cc5207c83dbb373a9c"><td class="memItemLeft" align="right" valign="top"><a id="ga79d820cd3ad391cc5207c83dbb373a9c"></a>
typedef struct <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a></td></tr>
<tr class="memdesc:ga79d820cd3ad391cc5207c83dbb373a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Unsettled API</b> - The network address of a proactor transport. <br /></td></tr>
<tr class="separator:ga79d820cd3ad391cc5207c83dbb373a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabba42c7929dfceb9d296535bad0c93dc"><td class="memItemLeft" align="right" valign="top"><a id="gabba42c7929dfceb9d296535bad0c93dc"></a>
typedef struct <a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a></td></tr>
<tr class="memdesc:gabba42c7929dfceb9d296535bad0c93dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A harness for multithreaded IO. <br /></td></tr>
<tr class="separator:gabba42c7929dfceb9d296535bad0c93dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f6a27999303c6082edc581f880de37c"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga9f6a27999303c6082edc581f880de37c">pn_netaddr_str</a> (const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *addr, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga9f6a27999303c6082edc581f880de37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a network address as a human-readable string in <code>buf</code>.  <a href="#ga9f6a27999303c6082edc581f880de37c">More...</a><br /></td></tr>
<tr class="separator:ga9f6a27999303c6082edc581f880de37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bcff2f30c1608c1d883eab461cc9148"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga8bcff2f30c1608c1d883eab461cc9148">pn_transport_local_addr</a> (<a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *t)</td></tr>
<tr class="memdesc:ga8bcff2f30c1608c1d883eab461cc9148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local address of a transport.  <a href="#ga8bcff2f30c1608c1d883eab461cc9148">More...</a><br /></td></tr>
<tr class="separator:ga8bcff2f30c1608c1d883eab461cc9148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6d4bda7cfae2780dbb587443eded39"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga3a6d4bda7cfae2780dbb587443eded39">pn_transport_remote_addr</a> (<a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *t)</td></tr>
<tr class="memdesc:ga3a6d4bda7cfae2780dbb587443eded39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local address of a transport.  <a href="#ga3a6d4bda7cfae2780dbb587443eded39">More...</a><br /></td></tr>
<tr class="separator:ga3a6d4bda7cfae2780dbb587443eded39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdbda4ea3dc040af5a4c1d633ddd7cd9"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gacdbda4ea3dc040af5a4c1d633ddd7cd9">pn_listener_addr</a> (<a class="el" href="group__listener.html#ga68ac7072ae60612d0bca5470014bf216">pn_listener_t</a> *l)</td></tr>
<tr class="memdesc:gacdbda4ea3dc040af5a4c1d633ddd7cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the listening addresses of a listener.  <a href="#gacdbda4ea3dc040af5a4c1d633ddd7cd9">More...</a><br /></td></tr>
<tr class="separator:gacdbda4ea3dc040af5a4c1d633ddd7cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6163449ac3b87782628448f192930eb0"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga6163449ac3b87782628448f192930eb0">pn_netaddr_next</a> (const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *na)</td></tr>
<tr class="separator:ga6163449ac3b87782628448f192930eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b1a40af2d837915d21cdb52ccb0c58"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN const struct sockaddr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga00b1a40af2d837915d21cdb52ccb0c58">pn_netaddr_sockaddr</a> (const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *na)</td></tr>
<tr class="memdesc:ga00b1a40af2d837915d21cdb52ccb0c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">On POSIX or Windows, get the underlying <code>struct sockaddr</code>.  <a href="#ga00b1a40af2d837915d21cdb52ccb0c58">More...</a><br /></td></tr>
<tr class="separator:ga00b1a40af2d837915d21cdb52ccb0c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddaf2b0b3e107d100e4c3658116a6c3c"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gaddaf2b0b3e107d100e4c3658116a6c3c">pn_netaddr_socklen</a> (const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *na)</td></tr>
<tr class="memdesc:gaddaf2b0b3e107d100e4c3658116a6c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">On POSIX or Windows, get the size of the underlying <code>struct sockaddr</code>.  <a href="#gaddaf2b0b3e107d100e4c3658116a6c3c">More...</a><br /></td></tr>
<tr class="separator:gaddaf2b0b3e107d100e4c3658116a6c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cdeab8554e7d376a422dae8ac6d474b"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga8cdeab8554e7d376a422dae8ac6d474b">pn_netaddr_host_port</a> (const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *na, char *host, size_t hlen, char *port, size_t plen)</td></tr>
<tr class="memdesc:ga8cdeab8554e7d376a422dae8ac6d474b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host and port name from na as separate strings.  <a href="#ga8cdeab8554e7d376a422dae8ac6d474b">More...</a><br /></td></tr>
<tr class="separator:ga8cdeab8554e7d376a422dae8ac6d474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67a7642c9003b36255b58776b494c96"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gaf67a7642c9003b36255b58776b494c96">pn_proactor_addr</a> (char *addr, size_t size, const char *host, const char *port)</td></tr>
<tr class="memdesc:gaf67a7642c9003b36255b58776b494c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a host:port address string for <a class="el" href="group__proactor.html#gabb093e51449351cf5530bb300bd67ba1" title="Connect transport to addr and bind to connection. ">pn_proactor_connect2()</a> or pn_proactor_listen2()  <a href="#gaf67a7642c9003b36255b58776b494c96">More...</a><br /></td></tr>
<tr class="separator:gaf67a7642c9003b36255b58776b494c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a925b3de00efd8cd40fa9920169554"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gac2a925b3de00efd8cd40fa9920169554">pn_proactor</a> (void)</td></tr>
<tr class="memdesc:gac2a925b3de00efd8cd40fa9920169554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a proactor.  <a href="#gac2a925b3de00efd8cd40fa9920169554">More...</a><br /></td></tr>
<tr class="separator:gac2a925b3de00efd8cd40fa9920169554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5260c2653d4af5eb2f1c8c6190e9d6cf"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga5260c2653d4af5eb2f1c8c6190e9d6cf">pn_proactor_free</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor)</td></tr>
<tr class="memdesc:ga5260c2653d4af5eb2f1c8c6190e9d6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the proactor.  <a href="#ga5260c2653d4af5eb2f1c8c6190e9d6cf">More...</a><br /></td></tr>
<tr class="separator:ga5260c2653d4af5eb2f1c8c6190e9d6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb093e51449351cf5530bb300bd67ba1"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gabb093e51449351cf5530bb300bd67ba1">pn_proactor_connect2</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor, <a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *connection, <a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *transport, const char *addr)</td></tr>
<tr class="memdesc:gabb093e51449351cf5530bb300bd67ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect <code>transport</code> to <code>addr</code> and bind to <code>connection</code>.  <a href="#gabb093e51449351cf5530bb300bd67ba1">More...</a><br /></td></tr>
<tr class="separator:gabb093e51449351cf5530bb300bd67ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9d1c4138226fa87160f4769b87f8e6"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga9a9d1c4138226fa87160f4769b87f8e6">pn_proactor_connect</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor, <a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *connection, const char *addr)</td></tr>
<tr class="separator:ga9a9d1c4138226fa87160f4769b87f8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbed6a4ab75ef8452c10d52e4cd62752"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gacbed6a4ab75ef8452c10d52e4cd62752">pn_proactor_listen</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor, <a class="el" href="group__listener.html#ga68ac7072ae60612d0bca5470014bf216">pn_listener_t</a> *listener, const char *addr, int backlog)</td></tr>
<tr class="memdesc:gacbed6a4ab75ef8452c10d52e4cd62752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start listening for incoming connections.  <a href="#gacbed6a4ab75ef8452c10d52e4cd62752">More...</a><br /></td></tr>
<tr class="separator:gacbed6a4ab75ef8452c10d52e4cd62752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac600bd88ed0fc6c2b66bed4a8740bd68"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gac600bd88ed0fc6c2b66bed4a8740bd68">pn_proactor_disconnect</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor, <a class="el" href="group__condition.html#ga11eb7db7d2c205169fe3d47c996a95a5">pn_condition_t</a> *condition)</td></tr>
<tr class="memdesc:gac600bd88ed0fc6c2b66bed4a8740bd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect all connections and listeners belonging to the proactor.  <a href="#gac600bd88ed0fc6c2b66bed4a8740bd68">More...</a><br /></td></tr>
<tr class="separator:gac600bd88ed0fc6c2b66bed4a8740bd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b66a46f3e557010ec61bd105326753d"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__event.html#ga6bc581dfeaa8e8d46d07d37229d565c9">pn_event_batch_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga2b66a46f3e557010ec61bd105326753d">pn_proactor_wait</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor)</td></tr>
<tr class="memdesc:ga2b66a46f3e557010ec61bd105326753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until there are <a class="el" href="group__proactor__events.html">Proactor events</a> to handle.  <a href="#ga2b66a46f3e557010ec61bd105326753d">More...</a><br /></td></tr>
<tr class="separator:ga2b66a46f3e557010ec61bd105326753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957eae24db6ec4962af79c5a06106115"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__event.html#ga6bc581dfeaa8e8d46d07d37229d565c9">pn_event_batch_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga957eae24db6ec4962af79c5a06106115">pn_proactor_get</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor)</td></tr>
<tr class="memdesc:ga957eae24db6ec4962af79c5a06106115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="group__proactor__events.html">Proactor events</a> if any are available immediately.  <a href="#ga957eae24db6ec4962af79c5a06106115">More...</a><br /></td></tr>
<tr class="separator:ga957eae24db6ec4962af79c5a06106115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade60ff2292b74841766f953b906285c0"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gade60ff2292b74841766f953b906285c0">pn_proactor_done</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor, <a class="el" href="group__event.html#ga6bc581dfeaa8e8d46d07d37229d565c9">pn_event_batch_t</a> *events)</td></tr>
<tr class="memdesc:gade60ff2292b74841766f953b906285c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call when finished handling a batch of events.  <a href="#gade60ff2292b74841766f953b906285c0">More...</a><br /></td></tr>
<tr class="separator:gade60ff2292b74841766f953b906285c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5255cd1bcb5d7f5639b53dc30712711"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gaa5255cd1bcb5d7f5639b53dc30712711">pn_proactor_interrupt</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor)</td></tr>
<tr class="memdesc:gaa5255cd1bcb5d7f5639b53dc30712711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaaee05826a80e94b5b86c4544e4715f499">PN_PROACTOR_INTERRUPT</a> event as soon as possible.  <a href="#gaa5255cd1bcb5d7f5639b53dc30712711">More...</a><br /></td></tr>
<tr class="separator:gaa5255cd1bcb5d7f5639b53dc30712711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7cd71f06282eb290699d90c316b2d32"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gad7cd71f06282eb290699d90c316b2d32">pn_proactor_set_timeout</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor, <a class="el" href="group__api__types.html#ga9a701bc6dc9af9f42c3f4679172a723c">pn_millis_t</a> timeout)</td></tr>
<tr class="memdesc:gad7cd71f06282eb290699d90c316b2d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa4afa8c2da61f4c665c669fbe37b1c5fe">PN_PROACTOR_TIMEOUT</a> after <code>timeout</code> milliseconds elapse.  <a href="#gad7cd71f06282eb290699d90c316b2d32">More...</a><br /></td></tr>
<tr class="separator:gad7cd71f06282eb290699d90c316b2d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac206e4d0a1b7546d940a83cdd79ce93f"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gac206e4d0a1b7546d940a83cdd79ce93f">pn_proactor_cancel_timeout</a> (<a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *proactor)</td></tr>
<tr class="memdesc:gac206e4d0a1b7546d940a83cdd79ce93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the pending timeout set by <a class="el" href="group__proactor.html#gad7cd71f06282eb290699d90c316b2d32" title="Return a PN_PROACTOR_TIMEOUT after timeout milliseconds elapse. ">pn_proactor_set_timeout()</a>.  <a href="#gac206e4d0a1b7546d940a83cdd79ce93f">More...</a><br /></td></tr>
<tr class="separator:gac206e4d0a1b7546d940a83cdd79ce93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1950236260353f82729dbb4589ef6c27"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga1950236260353f82729dbb4589ef6c27">pn_proactor_release_connection</a> (<a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *connection)</td></tr>
<tr class="memdesc:ga1950236260353f82729dbb4589ef6c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of <code>connection</code>, disassociate it from its proactor.  <a href="#ga1950236260353f82729dbb4589ef6c27">More...</a><br /></td></tr>
<tr class="separator:ga1950236260353f82729dbb4589ef6c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f49c771fe3bff54f58c9d583ca30560"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga0f49c771fe3bff54f58c9d583ca30560">pn_connection_wake</a> (<a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *connection)</td></tr>
<tr class="memdesc:ga0f49c771fe3bff54f58c9d583ca30560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa28a2bfee806bbc1fe31499c8eec39db0">PN_CONNECTION_WAKE</a> event for <code>connection</code> as soon as possible.  <a href="#ga0f49c771fe3bff54f58c9d583ca30560">More...</a><br /></td></tr>
<tr class="separator:ga0f49c771fe3bff54f58c9d583ca30560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4727a4e26f19efcff0d48960cbba2f40"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga4727a4e26f19efcff0d48960cbba2f40">pn_connection_proactor</a> (<a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *connection)</td></tr>
<tr class="memdesc:ga4727a4e26f19efcff0d48960cbba2f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the proactor associated with a connection.  <a href="#ga4727a4e26f19efcff0d48960cbba2f40">More...</a><br /></td></tr>
<tr class="separator:ga4727a4e26f19efcff0d48960cbba2f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac412771217decd84bd70931acbd0828a"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gac412771217decd84bd70931acbd0828a">pn_event_proactor</a> (<a class="el" href="group__event.html#ga87f3028b4888632bbd56fb71ac737ae8">pn_event_t</a> *event)</td></tr>
<tr class="memdesc:gac412771217decd84bd70931acbd0828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the proactor associated with an event.  <a href="#gac412771217decd84bd70931acbd0828a">More...</a><br /></td></tr>
<tr class="separator:gac412771217decd84bd70931acbd0828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45b60b98f2bf385ee6ca5dca7b3f42d"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN <a class="el" href="group__api__types.html#ga9a701bc6dc9af9f42c3f4679172a723c">pn_millis_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#gad45b60b98f2bf385ee6ca5dca7b3f42d">pn_proactor_now</a> (void)</td></tr>
<tr class="memdesc:gad45b60b98f2bf385ee6ca5dca7b3f42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real elapsed time since an arbitrary point in the past in milliseconds.  <a href="#gad45b60b98f2bf385ee6ca5dca7b3f42d">More...</a><br /></td></tr>
<tr class="separator:gad45b60b98f2bf385ee6ca5dca7b3f42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7edab5e295c55e1c2169e39aaa082f8b"><td class="memItemLeft" align="right" valign="top">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proactor.html#ga7edab5e295c55e1c2169e39aaa082f8b">pn_netaddr_local</a> (<a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *t)</td></tr>
<tr class="separator:ga7edab5e295c55e1c2169e39aaa082f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59fa5ba7adc39bc8549645d5d33082c0"><td class="memItemLeft" align="right" valign="top"><a id="ga59fa5ba7adc39bc8549645d5d33082c0"></a>
PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pn_netaddr_remote</b> (<a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *t)</td></tr>
<tr class="separator:ga59fa5ba7adc39bc8549645d5d33082c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga955471a53dd486a6f227d8d57322a44c"><td class="memItemLeft" align="right" valign="top"><a id="ga955471a53dd486a6f227d8d57322a44c"></a>
PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pn_netaddr_listening</b> (<a class="el" href="group__listener.html#ga68ac7072ae60612d0bca5470014bf216">pn_listener_t</a> *l)</td></tr>
<tr class="separator:ga955471a53dd486a6f227d8d57322a44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><b>Unsettled API</b> - An API for multithreaded IO. </p>
<p>The proactor associates an abstract AMQP protocol <a class="el" href="group__connection.html">Connection</a> with a concrete IO <a class="el" href="group__transport.html">Transport</a> implementation for outgoing and incoming connections.</p>
<p><a class="el" href="group__proactor.html#ga2b66a46f3e557010ec61bd105326753d" title="Wait until there are Proactor events to handle. ">pn_proactor_wait()</a> returns <a class="el" href="group__proactor__events.html">Proactor events</a> to application threads for handling.</p>
<p>The <code>pn_proactor_*</code> functions are thread-safe, but to handle <a class="el" href="group__proactor__events.html">Proactor events</a> you must also use the <a class="el" href="group__core.html">Core</a> APIs, which are not. <a class="el" href="group__core.html">Core</a> objects associated with different connections can be used concurrently, but objects associated with a single connection can only be used from their own thread.</p>
<p>The proactor <em>serializes</em> <a class="el" href="group__proactor__events.html">Proactor events</a> for each connection</p><ul>
<li>it never returns <a class="el" href="group__proactor__events.html">Proactor events</a> for the same connection concurrently in different threads. Event-handling code can safely use any <a class="el" href="group__core.html">Core</a> object obtained from the current event. You can attach application data to <a class="el" href="group__core.html">Core</a> objects (for example with <a class="el" href="group__connection.html#gad8b6c777b525c9da9401e3a770db15da" title="Get the attachments that are associated with a connection object. ">pn_connection_attachments()</a>).</li>
</ul>
<p><a class="el" href="group__proactor.html#ga0f49c771fe3bff54f58c9d583ca30560" title="Return a PN_CONNECTION_WAKE event for connection as soon as possible. ">pn_connection_wake()</a> allows any thread to "wake up" a connection. It causes <a class="el" href="group__proactor.html#ga2b66a46f3e557010ec61bd105326753d" title="Wait until there are Proactor events to handle. ">pn_proactor_wait()</a> to return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa28a2bfee806bbc1fe31499c8eec39db0">PN_CONNECTION_WAKE</a> event that is serialized with the connection's other <a class="el" href="group__proactor__events.html">Proactor events</a>. You can use this to implement communication between different connections, or from non-proactor threads.</p>
<p>Serialization and <a class="el" href="group__proactor.html#ga0f49c771fe3bff54f58c9d583ca30560" title="Return a PN_CONNECTION_WAKE event for connection as soon as possible. ">pn_connection_wake()</a> simplify building applications with a shared thread pool, which serialize work per connection. Many other variations are possible, but you are responsible for any additional synchronization needed. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9f6a27999303c6082edc581f880de37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f6a27999303c6082edc581f880de37c">&#9670;&nbsp;</a></span>pn_netaddr_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN int pn_netaddr_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a network address as a human-readable string in <code>buf</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the length of the string (excluding trailing '\0'), if &gt;= size then the address was truncated. </dd></dl>

</div>
</div>
<a id="ga8bcff2f30c1608c1d883eab461cc9148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bcff2f30c1608c1d883eab461cc9148">&#9670;&nbsp;</a></span>pn_transport_local_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a>* pn_transport_local_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local address of a transport. </p>
<p>Return <code>NULL</code> if not available. Pointer is invalid after the transport closes (PN_TRANSPORT_CLOSED event is handled) </p>

</div>
</div>
<a id="ga3a6d4bda7cfae2780dbb587443eded39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a6d4bda7cfae2780dbb587443eded39">&#9670;&nbsp;</a></span>pn_transport_remote_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a>* pn_transport_remote_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local address of a transport. </p>
<p>Return <code>NULL</code> if not available. Pointer is invalid after the transport closes (PN_TRANSPORT_CLOSED event is handled) </p>

</div>
</div>
<a id="gacdbda4ea3dc040af5a4c1d633ddd7cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdbda4ea3dc040af5a4c1d633ddd7cd9">&#9670;&nbsp;</a></span>pn_listener_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a>* pn_listener_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__listener.html#ga68ac7072ae60612d0bca5470014bf216">pn_listener_t</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the listening addresses of a listener. </p>
<p>Addresses are only available after the <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa6e25f00110ab278fd8b34fee00bd5fd7">PN_LISTENER_OPEN</a> event for the listener.</p>
<p>A listener can have more than one address for several reasons:</p><ul>
<li>DNS host records may indicate more than one address</li>
<li>On a multi-homed host, listening on the default host "" will listen on all local addresses.</li>
<li>Some IPv4/IPV6 configurations may expand a single address into a v4/v6 pair.</li>
</ul>
<p><a class="el" href="group__proactor.html#ga6163449ac3b87782628448f192930eb0">pn_netaddr_next()</a> will iterate over the addresses in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>points to the listener </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first listening address or NULL if there are no addresses are available. Use <a class="el" href="group__proactor.html#ga6163449ac3b87782628448f192930eb0">pn_netaddr_next()</a> to iterate over the list. Pointer is invalid after the listener closes (PN_LISTENER_CLOSED event is handled) </dd></dl>

</div>
</div>
<a id="ga6163449ac3b87782628448f192930eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6163449ac3b87782628448f192930eb0">&#9670;&nbsp;</a></span>pn_netaddr_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a>* pn_netaddr_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td>
          <td class="paramname"><em>na</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to the next address in a list of addresses, NULL if at the end of the list or if this address is not part of a list. </dd></dl>

</div>
</div>
<a id="ga00b1a40af2d837915d21cdb52ccb0c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b1a40af2d837915d21cdb52ccb0c58">&#9670;&nbsp;</a></span>pn_netaddr_sockaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN const struct sockaddr* pn_netaddr_sockaddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td>
          <td class="paramname"><em>na</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On POSIX or Windows, get the underlying <code>struct sockaddr</code>. </p>
<p>Return NULL if not available. </p>

</div>
</div>
<a id="gaddaf2b0b3e107d100e4c3658116a6c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddaf2b0b3e107d100e4c3658116a6c3c">&#9670;&nbsp;</a></span>pn_netaddr_socklen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN size_t pn_netaddr_socklen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td>
          <td class="paramname"><em>na</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On POSIX or Windows, get the size of the underlying <code>struct sockaddr</code>. </p>
<p>Return 0 if not available. </p>

</div>
</div>
<a id="ga8cdeab8554e7d376a422dae8ac6d474b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cdeab8554e7d376a422dae8ac6d474b">&#9670;&nbsp;</a></span>pn_netaddr_host_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN int pn_netaddr_host_port </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a> *&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>plen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the host and port name from na as separate strings. </p>
<p>Returns 0 if successful, non-0 on error. </p>

</div>
</div>
<a id="ga7edab5e295c55e1c2169e39aaa082f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7edab5e295c55e1c2169e39aaa082f8b">&#9670;&nbsp;</a></span>pn_netaddr_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN const <a class="el" href="group__proactor.html#ga79d820cd3ad391cc5207c83dbb373a9c">pn_netaddr_t</a>* pn_netaddr_local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf67a7642c9003b36255b58776b494c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67a7642c9003b36255b58776b494c96">&#9670;&nbsp;</a></span>pn_proactor_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN int pn_proactor_addr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a host:port address string for <a class="el" href="group__proactor.html#gabb093e51449351cf5530bb300bd67ba1" title="Connect transport to addr and bind to connection. ">pn_proactor_connect2()</a> or pn_proactor_listen2() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>address is copied to this buffer, with trailing '\0' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of addr buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>network host name, DNS name or IP address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>network service name or decimal port number, e.g. "amqp" or "5672" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of network address (excluding trailing '\0'), if &gt;= size then the address was truncated </dd></dl>

</div>
</div>
<a id="gac2a925b3de00efd8cd40fa9920169554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a925b3de00efd8cd40fa9920169554">&#9670;&nbsp;</a></span>pn_proactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a>* pn_proactor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a proactor. </p>
<p>Must be freed with <a class="el" href="group__proactor.html#ga5260c2653d4af5eb2f1c8c6190e9d6cf" title="Free the proactor. ">pn_proactor_free()</a> </p>

</div>
</div>
<a id="ga5260c2653d4af5eb2f1c8c6190e9d6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5260c2653d4af5eb2f1c8c6190e9d6cf">&#9670;&nbsp;</a></span>pn_proactor_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the proactor. </p>
<p>Abort open connections/listeners, clean up all resources. </p>

</div>
</div>
<a id="gabb093e51449351cf5530bb300bd67ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb093e51449351cf5530bb300bd67ba1">&#9670;&nbsp;</a></span>pn_proactor_connect2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_connect2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__transport.html#gac26eda05f649bbf0399f3d8d78d12fa8">pn_transport_t</a> *&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect <code>transport</code> to <code>addr</code> and bind to <code>connection</code>. </p>
<p>Errors are returned as <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1ca722ce3c0b2c13a33636cded8430ba">PN_TRANSPORT_CLOSED</a> events by <a class="el" href="group__proactor.html#ga2b66a46f3e557010ec61bd105326753d" title="Wait until there are Proactor events to handle. ">pn_proactor_wait()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">proactor</td><td>the proactor object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection</td><td>If NULL a new connection is created. <code>proactor</code> <em>takes ownership</em> of <code>connection</code> and will automatically call <a class="el" href="group__connection.html#ga00cbef1a9f5062a6e1f113fda923f65e" title="Free a connection object. ">pn_connection_free()</a> after the final <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1ca722ce3c0b2c13a33636cded8430ba">PN_TRANSPORT_CLOSED</a> event is handled, or when <a class="el" href="group__proactor.html#ga5260c2653d4af5eb2f1c8c6190e9d6cf" title="Free the proactor. ">pn_proactor_free()</a> is called. You can prevent the automatic free with <a class="el" href="group__proactor.html#ga1950236260353f82729dbb4589ef6c27" title="Release ownership of connection, disassociate it from its proactor. ">pn_proactor_release_connection()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transport</td><td>If NULL a new transport is created. <code>proactor</code> <em>takes ownership</em> of <code>transport</code>, it will be freed even if <a class="el" href="group__proactor.html#ga1950236260353f82729dbb4589ef6c27" title="Release ownership of connection, disassociate it from its proactor. ">pn_proactor_release_connection()</a> is called.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the "host:port" network address, constructed by <a class="el" href="group__proactor.html#gaf67a7642c9003b36255b58776b494c96" title="Format a host:port address string for pn_proactor_connect2() or pn_proactor_listen2() ...">pn_proactor_addr()</a> An empty host will connect to the local host via the default protocol (IPV6 or IPV4). An empty port will connect to the standard AMQP port (5672). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a9d1c4138226fa87160f4769b87f8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a9d1c4138226fa87160f4769b87f8e6">&#9670;&nbsp;</a></span>pn_proactor_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gacbed6a4ab75ef8452c10d52e4cd62752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbed6a4ab75ef8452c10d52e4cd62752">&#9670;&nbsp;</a></span>pn_proactor_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__listener.html#ga68ac7072ae60612d0bca5470014bf216">pn_listener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start listening for incoming connections. </p>
<p><a class="el" href="group__proactor.html#ga2b66a46f3e557010ec61bd105326753d" title="Wait until there are Proactor events to handle. ">pn_proactor_wait()</a> will return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa6e25f00110ab278fd8b34fee00bd5fd7">PN_LISTENER_OPEN</a> event when the listener is ready to accept connections, or a PN_LISTENER_CLOSE if the listen operation fails. If the listen failed, <a class="el" href="group__listener.html#gaa49d0d11a9f46a75fbbbebf6def2d4b2" title="Get the error condition for a listener. ">pn_listener_condition()</a> will be set.</p>
<p>When the listener is closed by <a class="el" href="group__listener.html#ga17a5b8573f00e16b233c59a3bb17c104" title="Close the listener. ">pn_listener_close()</a>, or because of an error, a PN_LISTENER_CLOSE event will be returned and <a class="el" href="group__listener.html#gaa49d0d11a9f46a75fbbbebf6def2d4b2" title="Get the error condition for a listener. ">pn_listener_condition()</a> will be set for an error.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">proactor</td><td>the proactor object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listener</td><td><code>proactor</code> <em>takes ownership</em> of <code>listener</code>, and will automatically call <a class="el" href="group__listener.html#gaf5769baf81fdfa80e5c4326dd4a9ab63" title="Free a listener. ">pn_listener_free()</a> after the final PN_LISTENER_CLOSE event is handled, or when <a class="el" href="group__proactor.html#ga5260c2653d4af5eb2f1c8c6190e9d6cf" title="Free the proactor. ">pn_proactor_free()</a> is called.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the "host:port" network address, constructed by <a class="el" href="group__proactor.html#gaf67a7642c9003b36255b58776b494c96" title="Format a host:port address string for pn_proactor_connect2() or pn_proactor_listen2() ...">pn_proactor_addr()</a> An empty host will listen for all protocols (IPV6 and IPV4) on all local interfaces. An empty port will listen on the standard AMQP port (5672).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>of un-handled connection requests to allow before refusing connections. If <code>addr</code> resolves to multiple interface/protocol combinations, the backlog applies to each separately. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac600bd88ed0fc6c2b66bed4a8740bd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac600bd88ed0fc6c2b66bed4a8740bd68">&#9670;&nbsp;</a></span>pn_proactor_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__condition.html#ga11eb7db7d2c205169fe3d47c996a95a5">pn_condition_t</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect all connections and listeners belonging to the proactor. </p>
<p><a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaad5920df168cd28daaf253cad789d8aca">PN_LISTENER_CLOSE</a>, <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa1ca722ce3c0b2c13a33636cded8430ba">PN_TRANSPORT_CLOSED</a> and other <a class="el" href="group__proactor__events.html">Proactor events</a> are generated as usual.</p>
<p>A <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa894e93f167ef39e28a07c9cdf6b1181b">PN_PROACTOR_INACTIVE</a> event will be generated when all connections and listeners are disconnected and no timeout is pending. The event will also be generated if there are no listeners, connections or timeout when <a class="el" href="group__proactor.html#gac600bd88ed0fc6c2b66bed4a8740bd68" title="Disconnect all connections and listeners belonging to the proactor. ">pn_proactor_disconnect()</a> is called.</p>
<p>Creating new connections and listeners after this call and before the PN_PROACTOR_INACTIVE event may prevent the proactor from becoming inactive. After the PN_PROACTOR_INACTIVE event, the proactor can be used normally.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proactor</td><td>the proactor</td></tr>
    <tr><td class="paramname">condition</td><td>if not NULL the condition data is copied to each disconnected transports and listener and is available in the close event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b66a46f3e557010ec61bd105326753d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b66a46f3e557010ec61bd105326753d">&#9670;&nbsp;</a></span>pn_proactor_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__event.html#ga6bc581dfeaa8e8d46d07d37229d565c9">pn_event_batch_t</a>* pn_proactor_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until there are <a class="el" href="group__proactor__events.html">Proactor events</a> to handle. </p>
<p>You must call <a class="el" href="group__proactor.html#gade60ff2292b74841766f953b906285c0" title="Call when finished handling a batch of events. ">pn_proactor_done()</a> when you are finished with the batch, you must not use the batch pointer after calling <a class="el" href="group__proactor.html#gade60ff2292b74841766f953b906285c0" title="Call when finished handling a batch of events. ">pn_proactor_done()</a>.</p>
<p>Normally it is most efficient to handle the entire batch in the calling thread and then call <a class="el" href="group__proactor.html#gade60ff2292b74841766f953b906285c0" title="Call when finished handling a batch of events. ">pn_proactor_done()</a>, but see <a class="el" href="group__proactor.html#gade60ff2292b74841766f953b906285c0" title="Call when finished handling a batch of events. ">pn_proactor_done()</a> for more options.</p>
<p><a class="el" href="group__proactor.html#ga957eae24db6ec4962af79c5a06106115" title="Return Proactor events if any are available immediately. ">pn_proactor_get()</a> is a non-blocking version of this call.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a non-empty batch of events that must be processed in sequence. </dd></dl>

</div>
</div>
<a id="ga957eae24db6ec4962af79c5a06106115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga957eae24db6ec4962af79c5a06106115">&#9670;&nbsp;</a></span>pn_proactor_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__event.html#ga6bc581dfeaa8e8d46d07d37229d565c9">pn_event_batch_t</a>* pn_proactor_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <a class="el" href="group__proactor__events.html">Proactor events</a> if any are available immediately. </p>
<p>If not, return NULL. If the return value is not NULL, the behavior is the same as <a class="el" href="group__proactor.html#ga2b66a46f3e557010ec61bd105326753d" title="Wait until there are Proactor events to handle. ">pn_proactor_wait()</a></p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe </dd></dl>

</div>
</div>
<a id="gade60ff2292b74841766f953b906285c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade60ff2292b74841766f953b906285c0">&#9670;&nbsp;</a></span>pn_proactor_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event.html#ga6bc581dfeaa8e8d46d07d37229d565c9">pn_event_batch_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call when finished handling a batch of events. </p>
<p>Must be called exactly once to match each call to <a class="el" href="group__proactor.html#ga2b66a46f3e557010ec61bd105326753d" title="Wait until there are Proactor events to handle. ">pn_proactor_wait()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: May be called from any thread provided the exactly once rule is respected. </dd></dl>

</div>
</div>
<a id="gaa5255cd1bcb5d7f5639b53dc30712711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5255cd1bcb5d7f5639b53dc30712711">&#9670;&nbsp;</a></span>pn_proactor_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaaee05826a80e94b5b86c4544e4715f499">PN_PROACTOR_INTERRUPT</a> event as soon as possible. </p>
<p>At least one PN_PROACTOR_INTERRUPT event will be returned after this call. Interrupts can be "coalesced" - if several <a class="el" href="group__proactor.html#gaa5255cd1bcb5d7f5639b53dc30712711" title="Return a PN_PROACTOR_INTERRUPT event as soon as possible. ">pn_proactor_interrupt()</a> calls happen close together, there may be only one PN_PROACTOR_INTERRUPT event that occurs after all of them.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe and async-signal-safe: can be called in a signal handler. This is the only pn_proactor function that is async-signal-safe. </dd></dl>

</div>
</div>
<a id="gad7cd71f06282eb290699d90c316b2d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7cd71f06282eb290699d90c316b2d32">&#9670;&nbsp;</a></span>pn_proactor_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_set_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__api__types.html#ga9a701bc6dc9af9f42c3f4679172a723c">pn_millis_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa4afa8c2da61f4c665c669fbe37b1c5fe">PN_PROACTOR_TIMEOUT</a> after <code>timeout</code> milliseconds elapse. </p>
<p>If no threads are blocked in <a class="el" href="group__proactor.html#ga2b66a46f3e557010ec61bd105326753d" title="Wait until there are Proactor events to handle. ">pn_proactor_wait()</a> when the timeout elapses, the event will be delivered to the next available thread.</p>
<p>Calling <a class="el" href="group__proactor.html#gad7cd71f06282eb290699d90c316b2d32" title="Return a PN_PROACTOR_TIMEOUT after timeout milliseconds elapse. ">pn_proactor_set_timeout()</a> again before the PN_PROACTOR_TIMEOUT is delivered will cancel the previous timeout and deliver an event only after the new timeout.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe </dd></dl>

</div>
</div>
<a id="gac206e4d0a1b7546d940a83cdd79ce93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac206e4d0a1b7546d940a83cdd79ce93f">&#9670;&nbsp;</a></span>pn_proactor_cancel_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_cancel_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a> *&#160;</td>
          <td class="paramname"><em>proactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel the pending timeout set by <a class="el" href="group__proactor.html#gad7cd71f06282eb290699d90c316b2d32" title="Return a PN_PROACTOR_TIMEOUT after timeout milliseconds elapse. ">pn_proactor_set_timeout()</a>. </p>
<p>Does nothing if no timeout is set.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe </dd></dl>

</div>
</div>
<a id="ga1950236260353f82729dbb4589ef6c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1950236260353f82729dbb4589ef6c27">&#9670;&nbsp;</a></span>pn_proactor_release_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_proactor_release_connection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ownership of <code>connection</code>, disassociate it from its proactor. </p>
<p>The connection and related objects (<a class="el" href="group__session.html">sessions</a>, <a class="el" href="group__link.html">links</a> and so on) remain intact, but the transport is closed and unbound. The proactor will not return any more events for this connection. The caller must call <a class="el" href="group__connection.html#ga00cbef1a9f5062a6e1f113fda923f65e" title="Free a connection object. ">pn_connection_free()</a>, either directly or indirectly by re-using <code>connection</code> in another call to <a class="el" href="group__proactor.html#gabb093e51449351cf5530bb300bd67ba1" title="Connect transport to addr and bind to connection. ">pn_proactor_connect2()</a> or pn_proactor_listen2().</p>
<dl class="section note"><dt>Note</dt><dd><b>Not thread-safe</b>. Call this function from a connection event handler.</dd>
<dd>
If <code>connection</code> does not belong to a proactor, this call does nothing.</dd>
<dd>
This has nothing to do with <a class="el" href="group__connection.html#ga7c88b4833cf81d801b27d00b45d137b5" title="Release a connection object. ">pn_connection_release()</a>. </dd></dl>

</div>
</div>
<a id="ga0f49c771fe3bff54f58c9d583ca30560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f49c771fe3bff54f58c9d583ca30560">&#9670;&nbsp;</a></span>pn_connection_wake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN void pn_connection_wake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="group__event.html#gga4876e2eed24a4d4e4c52b99842103cdaa28a2bfee806bbc1fe31499c8eec39db0">PN_CONNECTION_WAKE</a> event for <code>connection</code> as soon as possible. </p>
<p>At least one wake event will be returned, serialized with other <a class="el" href="group__proactor__events.html">Proactor events</a> for the same connection. Wakes can be "coalesced" - if several <a class="el" href="group__proactor.html#ga0f49c771fe3bff54f58c9d583ca30560" title="Return a PN_CONNECTION_WAKE event for connection as soon as possible. ">pn_connection_wake()</a> calls happen close together, there may be only one PN_CONNECTION_WAKE event that occurs after all of them.</p>
<dl class="section note"><dt>Note</dt><dd>If <code>connection</code> does not belong to a proactor, this call does nothing.</dd>
<dd>
Thread-safe </dd></dl>

</div>
</div>
<a id="ga4727a4e26f19efcff0d48960cbba2f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4727a4e26f19efcff0d48960cbba2f40">&#9670;&nbsp;</a></span>pn_connection_proactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a>* pn_connection_proactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__connection.html#ga886351d81ff3a977a284a206526c5aff">pn_connection_t</a> *&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the proactor associated with a connection. </p>
<dl class="section note"><dt>Note</dt><dd><b>Not thread-safe</b></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the proactor or NULL if the connection does not belong to a proactor. </dd></dl>

</div>
</div>
<a id="gac412771217decd84bd70931acbd0828a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac412771217decd84bd70931acbd0828a">&#9670;&nbsp;</a></span>pn_event_proactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__proactor.html#gabba42c7929dfceb9d296535bad0c93dc">pn_proactor_t</a>* pn_event_proactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event.html#ga87f3028b4888632bbd56fb71ac737ae8">pn_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the proactor associated with an event. </p>
<dl class="section note"><dt>Note</dt><dd><b>Not thread-safe</b></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the proactor or NULL if the connection does not belong to a proactor. </dd></dl>

</div>
</div>
<a id="gad45b60b98f2bf385ee6ca5dca7b3f42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad45b60b98f2bf385ee6ca5dca7b3f42d">&#9670;&nbsp;</a></span>pn_proactor_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PNP_EXTERN <a class="el" href="group__api__types.html#ga9a701bc6dc9af9f42c3f4679172a723c">pn_millis_t</a> pn_proactor_now </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real elapsed time since an arbitrary point in the past in milliseconds. </p>
<p>This may be used as a portable way to get a process-local timestamp for the current time. It is monotonically increasing and will never go backwards.</p>
<p>Note: this is not a suitable value for an AMQP timestamp to be sent as part of a message. Such a timestamp should use the real time in milliseconds since the epoch.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
