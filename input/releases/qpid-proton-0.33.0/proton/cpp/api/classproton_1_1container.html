<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qpid Proton C++ API: container</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">0.33.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classproton_1_1container.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classproton_1_1container-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">container</div>  </div>
</div><!--header-->
<div class="contents">

<p>A top-level container of connections, sessions, and links.  
 <a href="classproton_1_1container.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="container_8hpp_source.html">container.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a322df81c8d397bb4c3fa6c1a67a496"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a9a322df81c8d397bb4c3fa6c1a67a496">container</a> (<a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> &amp;handler, const std::string &amp;<a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677">id</a>)</td></tr>
<tr class="memdesc:a9a322df81c8d397bb4c3fa6c1a67a496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a container with a global handler for messaging events.  <a href="classproton_1_1container.html#a9a322df81c8d397bb4c3fa6c1a67a496">More...</a><br /></td></tr>
<tr class="separator:a9a322df81c8d397bb4c3fa6c1a67a496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7f4be6b8ace086ed7470f66a742059"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a3d7f4be6b8ace086ed7470f66a742059">container</a> (<a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> &amp;handler)</td></tr>
<tr class="memdesc:a3d7f4be6b8ace086ed7470f66a742059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a container with a global handler for messaging events.  <a href="classproton_1_1container.html#a3d7f4be6b8ace086ed7470f66a742059">More...</a><br /></td></tr>
<tr class="separator:a3d7f4be6b8ace086ed7470f66a742059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88125a4442a7b28fab97a89587627c0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a88125a4442a7b28fab97a89587627c0f">container</a> (const std::string &amp;<a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677">id</a>)</td></tr>
<tr class="memdesc:a88125a4442a7b28fab97a89587627c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a container.  <a href="classproton_1_1container.html#a88125a4442a7b28fab97a89587627c0f">More...</a><br /></td></tr>
<tr class="separator:a88125a4442a7b28fab97a89587627c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacc0140de439ebab9a5466c45d38191"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#aeacc0140de439ebab9a5466c45d38191">container</a> ()</td></tr>
<tr class="memdesc:aeacc0140de439ebab9a5466c45d38191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a container.  <a href="classproton_1_1container.html#aeacc0140de439ebab9a5466c45d38191">More...</a><br /></td></tr>
<tr class="separator:aeacc0140de439ebab9a5466c45d38191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c64e64cedfa36303be53f0f581d1d24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a7c64e64cedfa36303be53f0f581d1d24">~container</a> ()</td></tr>
<tr class="memdesc:a7c64e64cedfa36303be53f0f581d1d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a container.  <a href="classproton_1_1container.html#a7c64e64cedfa36303be53f0f581d1d24">More...</a><br /></td></tr>
<tr class="separator:a7c64e64cedfa36303be53f0f581d1d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd9ed231804512a47cca3c81f00cdf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1connection.html">connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#adbd9ed231804512a47cca3c81f00cdf1">connect</a> (const std::string &amp;conn_url, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;conn_opts)</td></tr>
<tr class="memdesc:adbd9ed231804512a47cca3c81f00cdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to <code>conn_url</code> and send an open request to the remote peer.  <a href="classproton_1_1container.html#adbd9ed231804512a47cca3c81f00cdf1">More...</a><br /></td></tr>
<tr class="separator:adbd9ed231804512a47cca3c81f00cdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422bf1e05b6a01039f0ef603b2f165a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1connection.html">connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a422bf1e05b6a01039f0ef603b2f165a4">connect</a> (const std::string &amp;conn_url)</td></tr>
<tr class="memdesc:a422bf1e05b6a01039f0ef603b2f165a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect using the default <a class="el" href="connect-config.html">Connection Configuration</a> file.  <a href="classproton_1_1container.html#a422bf1e05b6a01039f0ef603b2f165a4">More...</a><br /></td></tr>
<tr class="separator:a422bf1e05b6a01039f0ef603b2f165a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d867e171bce707cc73c7003ec489db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1connection.html">connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a32d867e171bce707cc73c7003ec489db">connect</a> ()</td></tr>
<tr class="memdesc:a32d867e171bce707cc73c7003ec489db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect using the default <a class="el" href="connect-config.html">Connection Configuration</a> file.  <a href="classproton_1_1container.html#a32d867e171bce707cc73c7003ec489db">More...</a><br /></td></tr>
<tr class="separator:a32d867e171bce707cc73c7003ec489db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e138b28e9589583915cf5c5e0e7a524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1listener.html">listener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524">listen</a> (const std::string &amp;listen_url, <a class="el" href="classproton_1_1listen__handler.html">listen_handler</a> &amp;handler)</td></tr>
<tr class="memdesc:a9e138b28e9589583915cf5c5e0e7a524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for new connections on <code>listen_url</code>.  <a href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524">More...</a><br /></td></tr>
<tr class="separator:a9e138b28e9589583915cf5c5e0e7a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae234654c72fe7b272728028cd88b8c1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1listener.html">listener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ae234654c72fe7b272728028cd88b8c1c">listen</a> (const std::string &amp;listen_url, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;conn_opts)</td></tr>
<tr class="memdesc:ae234654c72fe7b272728028cd88b8c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for new connections on <code>listen_url</code>.  <a href="classproton_1_1container.html#ae234654c72fe7b272728028cd88b8c1c">More...</a><br /></td></tr>
<tr class="separator:ae234654c72fe7b272728028cd88b8c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf444f30e25454196894dbee96ba2a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1listener.html">listener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#acf444f30e25454196894dbee96ba2a44">listen</a> (const std::string &amp;listen_url)</td></tr>
<tr class="memdesc:acf444f30e25454196894dbee96ba2a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for new connections on <code>listen_url</code>.  <a href="classproton_1_1container.html#acf444f30e25454196894dbee96ba2a44">More...</a><br /></td></tr>
<tr class="separator:acf444f30e25454196894dbee96ba2a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a43e6d814de94978c515cb084873b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1">run</a> ()</td></tr>
<tr class="memdesc:a13a43e6d814de94978c515cb084873b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the container in the current thread.  <a href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1">More...</a><br /></td></tr>
<tr class="separator:a13a43e6d814de94978c515cb084873b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48e94529e54c7e7342fde28b26d9f48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ac48e94529e54c7e7342fde28b26d9f48">run</a> (int count)</td></tr>
<tr class="memdesc:ac48e94529e54c7e7342fde28b26d9f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the container with a pool of <code>count</code> threads, including the current thread.  <a href="classproton_1_1container.html#ac48e94529e54c7e7342fde28b26d9f48">More...</a><br /></td></tr>
<tr class="separator:ac48e94529e54c7e7342fde28b26d9f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5932054f172c66000aec9f4ed498df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a1d5932054f172c66000aec9f4ed498df">auto_stop</a> (bool enabled)</td></tr>
<tr class="memdesc:a1d5932054f172c66000aec9f4ed498df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable automatic container stop.  <a href="classproton_1_1container.html#a1d5932054f172c66000aec9f4ed498df">More...</a><br /></td></tr>
<tr class="separator:a1d5932054f172c66000aec9f4ed498df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade42a19caab198f0fd1d28e03cf9ba0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ade42a19caab198f0fd1d28e03cf9ba0e">stop</a> (const <a class="el" href="classproton_1_1error__condition.html">error_condition</a> &amp;err)</td></tr>
<tr class="memdesc:ade42a19caab198f0fd1d28e03cf9ba0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the container with error condition <code>err</code>.  <a href="classproton_1_1container.html#ade42a19caab198f0fd1d28e03cf9ba0e">More...</a><br /></td></tr>
<tr class="separator:ade42a19caab198f0fd1d28e03cf9ba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c528baf37154d347366083f0f816846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a8c528baf37154d347366083f0f816846">stop</a> ()</td></tr>
<tr class="memdesc:a8c528baf37154d347366083f0f816846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the container with an empty error condition.  <a href="classproton_1_1container.html#a8c528baf37154d347366083f0f816846">More...</a><br /></td></tr>
<tr class="separator:a8c528baf37154d347366083f0f816846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbfd13668611a525bb44328d7a3b1e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1sender.html">sender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#adfbfd13668611a525bb44328d7a3b1e8">open_sender</a> (const std::string &amp;addr_url)</td></tr>
<tr class="memdesc:adfbfd13668611a525bb44328d7a3b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and sender for <code>addr_url</code>.  <a href="classproton_1_1container.html#adfbfd13668611a525bb44328d7a3b1e8">More...</a><br /></td></tr>
<tr class="separator:adfbfd13668611a525bb44328d7a3b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38864960bb258487b7e0db775243fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1sender.html">sender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ae38864960bb258487b7e0db775243fe9">open_sender</a> (const std::string &amp;addr_url, const <a class="el" href="classproton_1_1sender__options.html">proton::sender_options</a> &amp;snd_opts)</td></tr>
<tr class="memdesc:ae38864960bb258487b7e0db775243fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and sender for <code>addr_url</code>.  <a href="classproton_1_1container.html#ae38864960bb258487b7e0db775243fe9">More...</a><br /></td></tr>
<tr class="separator:ae38864960bb258487b7e0db775243fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace90c31b569a4e5e8b435be43ded9ccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1sender.html">sender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ace90c31b569a4e5e8b435be43ded9ccb">open_sender</a> (const std::string &amp;addr_url, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;conn_opts)</td></tr>
<tr class="memdesc:ace90c31b569a4e5e8b435be43ded9ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and sender for <code>addr_url</code>.  <a href="classproton_1_1container.html#ace90c31b569a4e5e8b435be43ded9ccb">More...</a><br /></td></tr>
<tr class="separator:ace90c31b569a4e5e8b435be43ded9ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab868043d49b61929cf852b725816faf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1sender.html">sender</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ab868043d49b61929cf852b725816faf9">open_sender</a> (const std::string &amp;addr_url, const <a class="el" href="classproton_1_1sender__options.html">proton::sender_options</a> &amp;snd_opts, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;conn_opts)</td></tr>
<tr class="memdesc:ab868043d49b61929cf852b725816faf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and sender for <code>addr_url</code>.  <a href="classproton_1_1container.html#ab868043d49b61929cf852b725816faf9">More...</a><br /></td></tr>
<tr class="separator:ab868043d49b61929cf852b725816faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15df75d582af4ed83f0ffab9dcce84bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1receiver.html">receiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a15df75d582af4ed83f0ffab9dcce84bf">open_receiver</a> (const std::string &amp;addr_url)</td></tr>
<tr class="memdesc:a15df75d582af4ed83f0ffab9dcce84bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and receiver for <code>addr_url</code>.  <a href="classproton_1_1container.html#a15df75d582af4ed83f0ffab9dcce84bf">More...</a><br /></td></tr>
<tr class="separator:a15df75d582af4ed83f0ffab9dcce84bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f469bff20702364cd2e333c2694bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1receiver.html">receiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a29f469bff20702364cd2e333c2694bc8">open_receiver</a> (const std::string &amp;addr_url, const <a class="el" href="classproton_1_1receiver__options.html">proton::receiver_options</a> &amp;rcv_opts)</td></tr>
<tr class="memdesc:a29f469bff20702364cd2e333c2694bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and receiver for <code>addr_url</code>.  <a href="classproton_1_1container.html#a29f469bff20702364cd2e333c2694bc8">More...</a><br /></td></tr>
<tr class="separator:a29f469bff20702364cd2e333c2694bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c45b13d73ec3e8a7dbc02c6e95541e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1receiver.html">receiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#aa6c45b13d73ec3e8a7dbc02c6e95541e">open_receiver</a> (const std::string &amp;addr_url, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;conn_opts)</td></tr>
<tr class="memdesc:aa6c45b13d73ec3e8a7dbc02c6e95541e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and receiver for <code>addr_url</code>.  <a href="classproton_1_1container.html#aa6c45b13d73ec3e8a7dbc02c6e95541e">More...</a><br /></td></tr>
<tr class="separator:aa6c45b13d73ec3e8a7dbc02c6e95541e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6b1249015934cae619bbb417ee247f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1returned.html">returned</a>&lt; <a class="el" href="classproton_1_1receiver.html">receiver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a7e6b1249015934cae619bbb417ee247f">open_receiver</a> (const std::string &amp;addr_url, const <a class="el" href="classproton_1_1receiver__options.html">proton::receiver_options</a> &amp;rcv_opts, const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;conn_opts)</td></tr>
<tr class="memdesc:a7e6b1249015934cae619bbb417ee247f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection and receiver for <code>addr_url</code>.  <a href="classproton_1_1container.html#a7e6b1249015934cae619bbb417ee247f">More...</a><br /></td></tr>
<tr class="separator:a7e6b1249015934cae619bbb417ee247f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5cdd8165762b000c6518db56830677"><td class="memItemLeft" align="right" valign="top"><a id="a4c5cdd8165762b000c6518db56830677"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677">id</a> () const</td></tr>
<tr class="memdesc:a4c5cdd8165762b000c6518db56830677"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique identifier for the container. <br /></td></tr>
<tr class="separator:a4c5cdd8165762b000c6518db56830677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913a88786abbbf08dd3e53e2a3e4accb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a913a88786abbbf08dd3e53e2a3e4accb">client_connection_options</a> (const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;conn_opts)</td></tr>
<tr class="memdesc:a913a88786abbbf08dd3e53e2a3e4accb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection options applied to outgoing connections.  <a href="classproton_1_1container.html#a913a88786abbbf08dd3e53e2a3e4accb">More...</a><br /></td></tr>
<tr class="separator:a913a88786abbbf08dd3e53e2a3e4accb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0986a84403bdf62da9649c5de123d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1connection__options.html">connection_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a8d0986a84403bdf62da9649c5de123d3">client_connection_options</a> () const</td></tr>
<tr class="memdesc:a8d0986a84403bdf62da9649c5de123d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection options applied to outgoing connections.  <a href="classproton_1_1container.html#a8d0986a84403bdf62da9649c5de123d3">More...</a><br /></td></tr>
<tr class="separator:a8d0986a84403bdf62da9649c5de123d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7daf70330e5259fbb6ae3f01cfbc125a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a7daf70330e5259fbb6ae3f01cfbc125a">server_connection_options</a> (const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;conn_opts)</td></tr>
<tr class="memdesc:a7daf70330e5259fbb6ae3f01cfbc125a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection options applied to incoming connections.  <a href="classproton_1_1container.html#a7daf70330e5259fbb6ae3f01cfbc125a">More...</a><br /></td></tr>
<tr class="separator:a7daf70330e5259fbb6ae3f01cfbc125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7a536b46ab843775da5390754c9bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1connection__options.html">connection_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a0e7a536b46ab843775da5390754c9bf6">server_connection_options</a> () const</td></tr>
<tr class="memdesc:a0e7a536b46ab843775da5390754c9bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection options applied to incoming connections.  <a href="classproton_1_1container.html#a0e7a536b46ab843775da5390754c9bf6">More...</a><br /></td></tr>
<tr class="separator:a0e7a536b46ab843775da5390754c9bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb43ab767dd944cfea2cc169f112488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a4fb43ab767dd944cfea2cc169f112488">sender_options</a> (const class <a class="el" href="classproton_1_1sender__options.html">sender_options</a> &amp;snd_opts)</td></tr>
<tr class="memdesc:a4fb43ab767dd944cfea2cc169f112488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sender options applied to senders created by this container.  <a href="classproton_1_1container.html#a4fb43ab767dd944cfea2cc169f112488">More...</a><br /></td></tr>
<tr class="separator:a4fb43ab767dd944cfea2cc169f112488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bfc8d811be7f6be17be6cf15e35b4a"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classproton_1_1sender__options.html">sender_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#ae7bfc8d811be7f6be17be6cf15e35b4a">sender_options</a> () const</td></tr>
<tr class="memdesc:ae7bfc8d811be7f6be17be6cf15e35b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sender options applied to senders created by this container.  <a href="classproton_1_1container.html#ae7bfc8d811be7f6be17be6cf15e35b4a">More...</a><br /></td></tr>
<tr class="separator:ae7bfc8d811be7f6be17be6cf15e35b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e01779c75286d270f579a28dae14d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a2e01779c75286d270f579a28dae14d37">receiver_options</a> (const class <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> &amp;rcv_opts)</td></tr>
<tr class="memdesc:a2e01779c75286d270f579a28dae14d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receiver options applied to receivers created by this container.  <a href="classproton_1_1container.html#a2e01779c75286d270f579a28dae14d37">More...</a><br /></td></tr>
<tr class="separator:a2e01779c75286d270f579a28dae14d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099ddaa3cfcd6a8ae14401bbbfb4b660"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a099ddaa3cfcd6a8ae14401bbbfb4b660">receiver_options</a> () const</td></tr>
<tr class="memdesc:a099ddaa3cfcd6a8ae14401bbbfb4b660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receiver options applied to receivers created by this container.  <a href="classproton_1_1container.html#a099ddaa3cfcd6a8ae14401bbbfb4b660">More...</a><br /></td></tr>
<tr class="separator:a099ddaa3cfcd6a8ae14401bbbfb4b660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99ede2051ccdf5fe8257d893559ea26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#aa99ede2051ccdf5fe8257d893559ea26">schedule</a> (<a class="el" href="classproton_1_1duration.html">duration</a> dur, work fn)</td></tr>
<tr class="memdesc:aa99ede2051ccdf5fe8257d893559ea26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule <code>fn</code> for execution after a duration.  <a href="classproton_1_1container.html#aa99ede2051ccdf5fe8257d893559ea26">More...</a><br /></td></tr>
<tr class="separator:aa99ede2051ccdf5fe8257d893559ea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e20a15733ef55ac0c43fbe1e60813d4"><td class="memItemLeft" align="right" valign="top"><a id="a3e20a15733ef55ac0c43fbe1e60813d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1container.html#a3e20a15733ef55ac0c43fbe1e60813d4">schedule</a> (<a class="el" href="classproton_1_1duration.html">duration</a> dur, void_function0 &amp;fn)</td></tr>
<tr class="memdesc:a3e20a15733ef55ac0c43fbe1e60813d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Deprecated</b> - Use <code><a class="el" href="classproton_1_1container.html#aa99ede2051ccdf5fe8257d893559ea26" title="Schedule fn for execution after a duration.">container::schedule(duration, work)</a></code>. <br /></td></tr>
<tr class="separator:a3e20a15733ef55ac0c43fbe1e60813d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A top-level container of connections, sessions, and links. </p>
<p>A container gives a unique identity to each communicating peer. It is often a process-level object.</p>
<p>It also serves as an entry point to the API, allowing connections, senders, and receivers to be established. It can be supplied with an event handler in order to intercept important messaging events, such as newly received messages or newly issued credit for sending messages. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="broker_8cpp-example.html#_a8">broker.cpp</a>, <a class="el" href="client_8cpp-example.html#_a6">client.cpp</a>, <a class="el" href="direct_recv_8cpp-example.html#_a5">direct_recv.cpp</a>, <a class="el" href="direct_send_8cpp-example.html#_a5">direct_send.cpp</a>, <a class="el" href="helloworld_8cpp-example.html#_a2">helloworld.cpp</a>, <a class="el" href="multithreaded_client_8cpp-example.html#_a8">multithreaded_client.cpp</a>, <a class="el" href="multithreaded_client_flow_control_8cpp-example.html#_a3">multithreaded_client_flow_control.cpp</a>, <a class="el" href="scheduled_send_8cpp-example.html#_a6">scheduled_send.cpp</a>, <a class="el" href="scheduled_send_03_8cpp-example.html#_a5">scheduled_send_03.cpp</a>, <a class="el" href="server_8cpp-example.html#_a3">server.cpp</a>, <a class="el" href="server_direct_8cpp-example.html#_a5">server_direct.cpp</a>, <a class="el" href="service_bus_8cpp-example.html#_a9">service_bus.cpp</a>, <a class="el" href="simple_recv_8cpp-example.html#_a3">simple_recv.cpp</a>, and <a class="el" href="simple_send_8cpp-example.html#_a3">simple_send.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a322df81c8d397bb4c3fa6c1a67a496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a322df81c8d397bb4c3fa6c1a67a496">&#9670;&nbsp;</a></span>container() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1container.html">container</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a container with a global handler for messaging events. </p>
<p><b>Thread safety</b> - in a multi-threaded container this handler will be called concurrently. You can use locks to make that safe, or use a separate handler for each connection. See <a class="el" href="mt_page.html">Multithreading</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>global handler, called for events on all connections managed by the container.</td></tr>
    <tr><td class="paramname">id</td><td>sets the container's unique identity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d7f4be6b8ace086ed7470f66a742059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7f4be6b8ace086ed7470f66a742059">&#9670;&nbsp;</a></span>container() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1container.html">container</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a container with a global handler for messaging events. </p>
<p><b>Thread safety</b> - in a multi-threaded container this handler will be called concurrently. You can use locks to make that safe, or use a separate handler for each connection. See <a class="el" href="mt_page.html">Multithreading</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>global handler, called for events on all connections managed by the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88125a4442a7b28fab97a89587627c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88125a4442a7b28fab97a89587627c0f">&#9670;&nbsp;</a></span>container() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1container.html">container</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>sets the container's unique identity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeacc0140de439ebab9a5466c45d38191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacc0140de439ebab9a5466c45d38191">&#9670;&nbsp;</a></span>container() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1container.html">container</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a container. </p>
<p>This will create a default random identity </p>

</div>
</div>
<a id="a7c64e64cedfa36303be53f0f581d1d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c64e64cedfa36303be53f0f581d1d24">&#9670;&nbsp;</a></span>~container()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classproton_1_1container.html">container</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a container. </p>
<p>A container must not be destroyed while a call to <a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in the current thread.">run()</a> is in progress, in particular it must not be destroyed from a <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> callback.</p>
<p><b>Thread safety</b> - in a multi-threaded application, <a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in the current thread.">run()</a> must return in all threads that call it before destroying the container. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adbd9ed231804512a47cca3c81f00cdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd9ed231804512a47cca3c81f00cdf1">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1connection.html">connection</a>&gt; connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>conn_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>conn_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to <code>conn_url</code> and send an open request to the remote peer. </p>
<p>Options are applied to the connection as follows.</p>
<ol type="1">
<li><a class="el" href="classproton_1_1container.html#a913a88786abbbf08dd3e53e2a3e4accb" title="Connection options applied to outgoing connections.">client_connection_options()</a></li>
<li>Options passed to <a class="el" href="classproton_1_1container.html#a32d867e171bce707cc73c7003ec489db" title="Connect using the default Connection Configuration file.">connect()</a></li>
</ol>
<p>Values in later options override earlier ones. The handler in the composed options is used to call <code><a class="el" href="classproton_1_1messaging__handler.html#a41277abe0e33a3df2764b08dcc12d768" title="The remote peer opened the connection: called once on initial open, and again on each successful auto...">messaging_handler::on_connection_open()</a></code> when the open response is received from the remote peer.</p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="helloworld_8cpp-example.html#a3">helloworld.cpp</a>, <a class="el" href="multithreaded_client_8cpp-example.html#a9">multithreaded_client.cpp</a>, <a class="el" href="server_8cpp-example.html#a4">server.cpp</a>, and <a class="el" href="service_bus_8cpp-example.html#a11">service_bus.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a422bf1e05b6a01039f0ef603b2f165a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422bf1e05b6a01039f0ef603b2f165a4">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1connection.html">connection</a>&gt; connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>conn_url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect using the default <a class="el" href="connect-config.html">Connection Configuration</a> file. </p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>

</div>
</div>
<a id="a32d867e171bce707cc73c7003ec489db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d867e171bce707cc73c7003ec489db">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1connection.html">connection</a>&gt; connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect using the default <a class="el" href="connect-config.html">Connection Configuration</a> file. </p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>

</div>
</div>
<a id="a9e138b28e9589583915cf5c5e0e7a524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e138b28e9589583915cf5c5e0e7a524">&#9670;&nbsp;</a></span>listen() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1listener.html">listener</a> listen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>listen_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproton_1_1listen__handler.html">listen_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for new connections on <code>listen_url</code>. </p>
<p>If the listener opens successfully, <a class="el" href="classproton_1_1listen__handler.html#a74a2a66bb05107bd04fbb15731b0578b" title="Called when the listener is opened successfully.">listen_handler::on_open()</a> is called. If it fails to open, <a class="el" href="classproton_1_1listen__handler.html#a0969610957fd465626cfad89db38ef53" title="Called if there is a listening error, with an error message.">listen_handler::on_error()</a> then listen_handler::close() are called.</p>
<p><a class="el" href="classproton_1_1listen__handler.html#a3f8b8dc9641dc3a3ed19e2a60ec8eccc" title="Called for each accepted connection.">listen_handler::on_accept()</a> is called for each incoming connection to determine the <a class="el" href="classproton_1_1connection__options.html">connection_options</a> to use, including the <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a>.</p>
<p><b>Thread safety</b> - Calls to <code><a class="el" href="classproton_1_1listen__handler.html" title="Unsettled API - A handler for incoming connections.">listen_handler</a></code> methods are serialized for this listener, but handlers attached to separate listeners may be called concurrently. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="broker_8cpp-example.html#a31">broker.cpp</a>, <a class="el" href="direct_recv_8cpp-example.html#a6">direct_recv.cpp</a>, <a class="el" href="direct_send_8cpp-example.html#a6">direct_send.cpp</a>, and <a class="el" href="server_direct_8cpp-example.html#a6">server_direct.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae234654c72fe7b272728028cd88b8c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae234654c72fe7b272728028cd88b8c1c">&#9670;&nbsp;</a></span>listen() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1listener.html">listener</a> listen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>listen_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>conn_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for new connections on <code>listen_url</code>. </p>
<p>Use a fixed set of options for all accepted connections. See <a class="el" href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524" title="Listen for new connections on listen_url.">listen(const std::string&amp;, listen_handler&amp;)</a>.</p>
<p><b>Thread safety</b> - for multi-threaded applications we recommend using a <a class="el" href="classproton_1_1listen__handler.html">listen_handler</a> to create a new <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> for each connection. See <a class="el" href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524" title="Listen for new connections on listen_url.">listen(const std::string&amp;, listen_handler&amp;)</a> and <a class="el" href="mt_page.html">Multithreading</a> </p>

</div>
</div>
<a id="acf444f30e25454196894dbee96ba2a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf444f30e25454196894dbee96ba2a44">&#9670;&nbsp;</a></span>listen() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1listener.html">listener</a> listen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>listen_url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for new connections on <code>listen_url</code>. </p>
<p>New connections will use the handler from <code><a class="el" href="classproton_1_1container.html#a7daf70330e5259fbb6ae3f01cfbc125a" title="Connection options applied to incoming connections.">server_connection_options()</a></code>. See listen(const std::string&amp;, const <a class="el" href="classproton_1_1connection__options.html" title="Options for creating a connection.">connection_options</a>&amp;); </p>

</div>
</div>
<a id="a13a43e6d814de94978c515cb084873b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a43e6d814de94978c515cb084873b1">&#9670;&nbsp;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the container in the current thread. </p>
<p>The call returns when the container stops. See <code><a class="el" href="classproton_1_1container.html#a1d5932054f172c66000aec9f4ed498df" title="Enable or disable automatic container stop.">auto_stop()</a></code> and <code><a class="el" href="classproton_1_1container.html#a8c528baf37154d347366083f0f816846" title="Stop the container with an empty error condition.">stop()</a></code>.</p>
<p><b>C++ versions</b> - With C++11 or later, you can call <code><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in the current thread.">run()</a></code> in multiple threads to create a thread pool. See also <code><a class="el" href="classproton_1_1container.html#ac48e94529e54c7e7342fde28b26d9f48" title="Run the container with a pool of count threads, including the current thread.">run(int count)</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="broker_8cpp-example.html#a32">broker.cpp</a>, <a class="el" href="client_8cpp-example.html#a21">client.cpp</a>, <a class="el" href="direct_recv_8cpp-example.html#a17">direct_recv.cpp</a>, <a class="el" href="direct_send_8cpp-example.html#a21">direct_send.cpp</a>, <a class="el" href="helloworld_8cpp-example.html#a18">helloworld.cpp</a>, <a class="el" href="multithreaded_client_flow_control_8cpp-example.html#a24">multithreaded_client_flow_control.cpp</a>, <a class="el" href="scheduled_send_8cpp-example.html#a19">scheduled_send.cpp</a>, <a class="el" href="scheduled_send_03_8cpp-example.html#a17">scheduled_send_03.cpp</a>, <a class="el" href="server_8cpp-example.html#a14">server.cpp</a>, <a class="el" href="server_direct_8cpp-example.html#a22">server_direct.cpp</a>, <a class="el" href="service_bus_8cpp-example.html#a36">service_bus.cpp</a>, <a class="el" href="simple_recv_8cpp-example.html#a17">simple_recv.cpp</a>, and <a class="el" href="simple_send_8cpp-example.html#a23">simple_send.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac48e94529e54c7e7342fde28b26d9f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48e94529e54c7e7342fde28b26d9f48">&#9670;&nbsp;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the container with a pool of <code>count</code> threads, including the current thread. </p>
<p><b>C++ versions</b> - Available with C++11 or later.</p>
<p>The call returns when the container stops. See <code><a class="el" href="classproton_1_1container.html#a1d5932054f172c66000aec9f4ed498df" title="Enable or disable automatic container stop.">auto_stop()</a></code> and <code><a class="el" href="classproton_1_1container.html#a8c528baf37154d347366083f0f816846" title="Stop the container with an empty error condition.">stop()</a></code>. </p>

</div>
</div>
<a id="a1d5932054f172c66000aec9f4ed498df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5932054f172c66000aec9f4ed498df">&#9670;&nbsp;</a></span>auto_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void auto_stop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable automatic container stop. </p>
<p>It is enabled by default.</p>
<p>If true, the container stops when all active connections and listeners are closed. If false, the container keeps running until <code><a class="el" href="classproton_1_1container.html#a8c528baf37154d347366083f0f816846" title="Stop the container with an empty error condition.">stop()</a></code> is called. </p>

</div>
</div>
<a id="ade42a19caab198f0fd1d28e03cf9ba0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade42a19caab198f0fd1d28e03cf9ba0e">&#9670;&nbsp;</a></span>stop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1error__condition.html">error_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the container with error condition <code>err</code>. </p>
<p>This function initiates shutdown and immediately returns. The shutdown process has the following steps.</p>
<ul>
<li>Abort all open connections and listeners.</li>
<li>Process final handler events and queued work.</li>
<li>If <code>!err.empty()</code>, fire <code><a class="el" href="classproton_1_1messaging__handler.html#ab719e98555bab69986acf4ab1fe43665" title="Unexpected disconnect, transport::error() provides details; if reconnect_options are enabled there ma...">messaging_handler::on_transport_error</a></code>.</li>
</ul>
<p>When the process is complete, <code><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in the current thread.">run()</a></code> returns in all threads.</p>
<p><b>Thread safety</b> - It is safe to call this method in any thread. </p>

</div>
</div>
<a id="a8c528baf37154d347366083f0f816846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c528baf37154d347366083f0f816846">&#9670;&nbsp;</a></span>stop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the container with an empty error condition. </p>
<p>This function initiates shutdown and immediately returns. The shutdown process has the following steps.</p>
<ul>
<li>Abort all open connections and listeners.</li>
<li>Process final handler events and queued work.</li>
<li>If <code>!err.empty()</code>, fire <code><a class="el" href="classproton_1_1messaging__handler.html#ab719e98555bab69986acf4ab1fe43665" title="Unexpected disconnect, transport::error() provides details; if reconnect_options are enabled there ma...">messaging_handler::on_transport_error</a></code>.</li>
</ul>
<p>When the process is complete, <code><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in the current thread.">run()</a></code> returns in all threads.</p>
<p><b>Thread safety</b> - It is safe to call this method in any thread. </p>

</div>
</div>
<a id="adfbfd13668611a525bb44328d7a3b1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbfd13668611a525bb44328d7a3b1e8">&#9670;&nbsp;</a></span>open_sender() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1sender.html">sender</a>&gt; open_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addr_url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and sender for <code>addr_url</code>. </p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="client_8cpp-example.html#a7">client.cpp</a>, <a class="el" href="multithreaded_client_flow_control_8cpp-example.html#a4">multithreaded_client_flow_control.cpp</a>, <a class="el" href="scheduled_send_8cpp-example.html#a7">scheduled_send.cpp</a>, <a class="el" href="scheduled_send_03_8cpp-example.html#a6">scheduled_send_03.cpp</a>, <a class="el" href="service_bus_8cpp-example.html#a28">service_bus.cpp</a>, and <a class="el" href="simple_send_8cpp-example.html#a7">simple_send.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae38864960bb258487b7e0db775243fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38864960bb258487b7e0db775243fe9">&#9670;&nbsp;</a></span>open_sender() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1sender.html">sender</a>&gt; open_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addr_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1sender__options.html">proton::sender_options</a> &amp;&#160;</td>
          <td class="paramname"><em>snd_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and sender for <code>addr_url</code>. </p>
<p>Supplied sender options will override the container's template options.</p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>

</div>
</div>
<a id="ace90c31b569a4e5e8b435be43ded9ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace90c31b569a4e5e8b435be43ded9ccb">&#9670;&nbsp;</a></span>open_sender() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1sender.html">sender</a>&gt; open_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addr_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>conn_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and sender for <code>addr_url</code>. </p>
<p>Supplied connection options will override the container's template options.</p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>

</div>
</div>
<a id="ab868043d49b61929cf852b725816faf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab868043d49b61929cf852b725816faf9">&#9670;&nbsp;</a></span>open_sender() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1sender.html">sender</a>&gt; open_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addr_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1sender__options.html">proton::sender_options</a> &amp;&#160;</td>
          <td class="paramname"><em>snd_opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>conn_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and sender for <code>addr_url</code>. </p>
<p>Supplied sender or connection options will override the container's template options.</p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>

</div>
</div>
<a id="a15df75d582af4ed83f0ffab9dcce84bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15df75d582af4ed83f0ffab9dcce84bf">&#9670;&nbsp;</a></span>open_receiver() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1receiver.html">receiver</a>&gt; open_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addr_url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and receiver for <code>addr_url</code>. </p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="multithreaded_client_flow_control_8cpp-example.html#a17">multithreaded_client_flow_control.cpp</a>, and <a class="el" href="simple_recv_8cpp-example.html#a7">simple_recv.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a29f469bff20702364cd2e333c2694bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f469bff20702364cd2e333c2694bc8">&#9670;&nbsp;</a></span>open_receiver() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1receiver.html">receiver</a>&gt; open_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addr_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1receiver__options.html">proton::receiver_options</a> &amp;&#160;</td>
          <td class="paramname"><em>rcv_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and receiver for <code>addr_url</code>. </p>
<p>Supplied receiver options will override the container's template options.</p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>

</div>
</div>
<a id="aa6c45b13d73ec3e8a7dbc02c6e95541e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c45b13d73ec3e8a7dbc02c6e95541e">&#9670;&nbsp;</a></span>open_receiver() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1receiver.html">receiver</a>&gt; open_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addr_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>conn_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and receiver for <code>addr_url</code>. </p>
<p>Supplied receiver or connection options will override the container's template options.</p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>

</div>
</div>
<a id="a7e6b1249015934cae619bbb417ee247f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6b1249015934cae619bbb417ee247f">&#9670;&nbsp;</a></span>open_receiver() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1returned.html">returned</a>&lt;<a class="el" href="classproton_1_1receiver.html">receiver</a>&gt; open_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addr_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1receiver__options.html">proton::receiver_options</a> &amp;&#160;</td>
          <td class="paramname"><em>rcv_opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>conn_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a connection and receiver for <code>addr_url</code>. </p>
<p>Supplied receiver or connection options will override the container's template options.</p>
<p><b>Thread safety</b> - Container method return values are <em>thread-unsafe</em>. A single-threaded application can safely assign the <code>returned&lt;T&gt;</code> value to a plain <code>T</code>. A multithreaded application <em>must</em> ignore the returned value because it may already be invalid by the time the function returns. Multithreaded applications can safely access the value inside <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> functions. </p>

</div>
</div>
<a id="a913a88786abbbf08dd3e53e2a3e4accb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913a88786abbbf08dd3e53e2a3e4accb">&#9670;&nbsp;</a></span>client_connection_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void client_connection_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>conn_opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection options applied to outgoing connections. </p>
<p>These are applied first and then overridden by any options provided in <code><a class="el" href="classproton_1_1container.html#a32d867e171bce707cc73c7003ec489db" title="Connect using the default Connection Configuration file.">connect()</a></code> or <code><a class="el" href="classproton_1_1messaging__handler.html#a41277abe0e33a3df2764b08dcc12d768" title="The remote peer opened the connection: called once on initial open, and again on each successful auto...">messaging_handler::on_connection_open()</a></code>. </p>

</div>
</div>
<a id="a8d0986a84403bdf62da9649c5de123d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0986a84403bdf62da9649c5de123d3">&#9670;&nbsp;</a></span>client_connection_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1connection__options.html">connection_options</a> client_connection_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection options applied to outgoing connections. </p>
<p>These are applied first and then overridden by any options provided in <code><a class="el" href="classproton_1_1container.html#a32d867e171bce707cc73c7003ec489db" title="Connect using the default Connection Configuration file.">connect()</a></code> or <code><a class="el" href="classproton_1_1messaging__handler.html#a41277abe0e33a3df2764b08dcc12d768" title="The remote peer opened the connection: called once on initial open, and again on each successful auto...">messaging_handler::on_connection_open()</a></code>. </p>

</div>
</div>
<a id="a7daf70330e5259fbb6ae3f01cfbc125a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daf70330e5259fbb6ae3f01cfbc125a">&#9670;&nbsp;</a></span>server_connection_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void server_connection_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>conn_opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection options applied to incoming connections. </p>
<p>These are applied first and then overridden by any options provided in <code><a class="el" href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524" title="Listen for new connections on listen_url.">listen()</a></code>, <code><a class="el" href="classproton_1_1listen__handler.html#a3f8b8dc9641dc3a3ed19e2a60ec8eccc" title="Called for each accepted connection.">listen_handler::on_accept()</a></code>, or <code><a class="el" href="classproton_1_1messaging__handler.html#a41277abe0e33a3df2764b08dcc12d768" title="The remote peer opened the connection: called once on initial open, and again on each successful auto...">messaging_handler::on_connection_open()</a></code>. </p>

</div>
</div>
<a id="a0e7a536b46ab843775da5390754c9bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7a536b46ab843775da5390754c9bf6">&#9670;&nbsp;</a></span>server_connection_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1connection__options.html">connection_options</a> server_connection_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection options applied to incoming connections. </p>
<p>These are applied first and then overridden by any options provided in <code><a class="el" href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524" title="Listen for new connections on listen_url.">listen()</a></code>, <code><a class="el" href="classproton_1_1listen__handler.html#a3f8b8dc9641dc3a3ed19e2a60ec8eccc" title="Called for each accepted connection.">listen_handler::on_accept()</a></code>, or <code><a class="el" href="classproton_1_1messaging__handler.html#a41277abe0e33a3df2764b08dcc12d768" title="The remote peer opened the connection: called once on initial open, and again on each successful auto...">messaging_handler::on_connection_open()</a></code>. </p>

</div>
</div>
<a id="a4fb43ab767dd944cfea2cc169f112488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb43ab767dd944cfea2cc169f112488">&#9670;&nbsp;</a></span>sender_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classproton_1_1sender__options.html">sender_options</a> </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classproton_1_1sender__options.html">sender_options</a> &amp;&#160;</td>
          <td class="paramname"><em>snd_opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sender options applied to senders created by this container. </p>
<p>They are applied before <code><a class="el" href="classproton_1_1messaging__handler.html#ac655d56c64574c9eb7b10e80d32764f4" title="The remote peer opened the link.">messaging_handler::on_sender_open()</a></code> and can be overridden. </p>

</div>
</div>
<a id="ae7bfc8d811be7f6be17be6cf15e35b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bfc8d811be7f6be17be6cf15e35b4a">&#9670;&nbsp;</a></span>sender_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classproton_1_1sender__options.html">sender_options</a> <a class="el" href="classproton_1_1sender__options.html">sender_options</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sender options applied to senders created by this container. </p>
<p>They are applied before <code><a class="el" href="classproton_1_1messaging__handler.html#ac655d56c64574c9eb7b10e80d32764f4" title="The remote peer opened the link.">messaging_handler::on_sender_open()</a></code> and can be overridden. </p>

</div>
</div>
<a id="a2e01779c75286d270f579a28dae14d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e01779c75286d270f579a28dae14d37">&#9670;&nbsp;</a></span>receiver_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> &amp;&#160;</td>
          <td class="paramname"><em>rcv_opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receiver options applied to receivers created by this container. </p>
<p>They are applied before <code><a class="el" href="classproton_1_1messaging__handler.html#a77f7e38659ee43ccb764e417ad6dd401" title="The remote peer opened the link.">messaging_handler::on_receiver_open()</a></code> and can be overridden. </p>

</div>
</div>
<a id="a099ddaa3cfcd6a8ae14401bbbfb4b660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099ddaa3cfcd6a8ae14401bbbfb4b660">&#9670;&nbsp;</a></span>receiver_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> <a class="el" href="classproton_1_1receiver__options.html">receiver_options</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receiver options applied to receivers created by this container. </p>
<p>They are applied before <code><a class="el" href="classproton_1_1messaging__handler.html#a77f7e38659ee43ccb764e417ad6dd401" title="The remote peer opened the link.">messaging_handler::on_receiver_open()</a></code> and can be overridden. </p>

</div>
</div>
<a id="aa99ede2051ccdf5fe8257d893559ea26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99ede2051ccdf5fe8257d893559ea26">&#9670;&nbsp;</a></span>schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproton_1_1duration.html">duration</a>&#160;</td>
          <td class="paramname"><em>dur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">work&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule <code>fn</code> for execution after a duration. </p>
<p>The piece of work can be created from a function object.</p>
<p><b>C++ versions</b> - With C++11 and later, use a <code>std::function&lt;void()&gt;</code> type for the <code>fn</code> parameter. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="scheduled_send_8cpp-example.html#a11">scheduled_send.cpp</a>.</dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>proton/<a class="el" href="container_8hpp_source.html">container.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceproton.html">proton</a></li><li class="navelem"><a class="el" href="classproton_1_1container.html">container</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
