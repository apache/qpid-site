<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qpid Proton C++ API: connection_driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">0.18.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classproton_1_1io_1_1connection__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classproton_1_1io_1_1connection__driver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">connection_driver</div>  </div>
</div><!--header-->
<div class="contents">

<p><b>Unsettled API</b> - An AMQP driver for a single connection.  
 <a href="classproton_1_1io_1_1connection__driver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="connection__driver_8hpp_source.html">connection_driver.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a57f27e412ea5d79e071da546dc40aed9"><td class="memItemLeft" align="right" valign="top"><a id="a57f27e412ea5d79e071da546dc40aed9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a57f27e412ea5d79e071da546dc40aed9">connection_driver</a> ()</td></tr>
<tr class="memdesc:a57f27e412ea5d79e071da546dc40aed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An engine without a container id. <br /></td></tr>
<tr class="separator:a57f27e412ea5d79e071da546dc40aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d4721a7dcdb9906a0a3eab9b3ecd50"><td class="memItemLeft" align="right" valign="top"><a id="a68d4721a7dcdb9906a0a3eab9b3ecd50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a68d4721a7dcdb9906a0a3eab9b3ecd50">connection_driver</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a68d4721a7dcdb9906a0a3eab9b3ecd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection driver associated with a container id. <br /></td></tr>
<tr class="separator:a68d4721a7dcdb9906a0a3eab9b3ecd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d2b78bee258ce7bb56806d11a122d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a86d2b78bee258ce7bb56806d11a122d3">configure</a> (const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;opts=<a class="el" href="classproton_1_1connection__options.html">connection_options</a>(), bool server=false)</td></tr>
<tr class="memdesc:a86d2b78bee258ce7bb56806d11a122d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a connection by applying exactly the options in opts (including <a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a>) Does not apply any default options, to apply container defaults use <a class="el" href="classproton_1_1io_1_1connection__driver.html#a49ffce3927a9d5013293bf92fde9e9a2" title="Call configure() with client options and call connection::open() Options applied: container::id()...">connect()</a> or <a class="el" href="classproton_1_1io_1_1connection__driver.html#a8a5938806dc28d71c3ed5f89cc537ddd" title="Call configure() with server options. ">accept()</a> instead.  <a href="#a86d2b78bee258ce7bb56806d11a122d3">More...</a><br /></td></tr>
<tr class="separator:a86d2b78bee258ce7bb56806d11a122d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ffce3927a9d5013293bf92fde9e9a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a49ffce3927a9d5013293bf92fde9e9a2">connect</a> (const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;opts)</td></tr>
<tr class="memdesc:a49ffce3927a9d5013293bf92fde9e9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="classproton_1_1io_1_1connection__driver.html#a86d2b78bee258ce7bb56806d11a122d3" title="Configure a connection by applying exactly the options in opts (including proton::messaging_handler) ...">configure()</a> with client options and call <a class="el" href="classproton_1_1connection.html#a9e8555112049fc2b4945120b3c45f8ab" title="Open the connection. ">connection::open()</a> Options applied: <a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677" title="A unique identifier for the container. ">container::id()</a>, <a class="el" href="classproton_1_1container.html#a913a88786abbbf08dd3e53e2a3e4accb" title="Connection options applied to outgoing connections. ">container::client_connection_options()</a>, opts.  <a href="#a49ffce3927a9d5013293bf92fde9e9a2">More...</a><br /></td></tr>
<tr class="separator:a49ffce3927a9d5013293bf92fde9e9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5938806dc28d71c3ed5f89cc537ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a8a5938806dc28d71c3ed5f89cc537ddd">accept</a> (const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;opts)</td></tr>
<tr class="memdesc:a8a5938806dc28d71c3ed5f89cc537ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="classproton_1_1io_1_1connection__driver.html#a86d2b78bee258ce7bb56806d11a122d3" title="Configure a connection by applying exactly the options in opts (including proton::messaging_handler) ...">configure()</a> with server options.  <a href="#a8a5938806dc28d71c3ed5f89cc537ddd">More...</a><br /></td></tr>
<tr class="separator:a8a5938806dc28d71c3ed5f89cc537ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af477c1401cee5a0cf3bc8d6f4d2be805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structproton_1_1io_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#af477c1401cee5a0cf3bc8d6f4d2be805">read_buffer</a> ()</td></tr>
<tr class="memdesc:af477c1401cee5a0cf3bc8d6f4d2be805"><td class="mdescLeft">&#160;</td><td class="mdescRight">The engine's read buffer.  <a href="#af477c1401cee5a0cf3bc8d6f4d2be805">More...</a><br /></td></tr>
<tr class="separator:af477c1401cee5a0cf3bc8d6f4d2be805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f86a4f778e8c9303e6c0f127e52a5e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a3f86a4f778e8c9303e6c0f127e52a5e2">read_done</a> (size_t n)</td></tr>
<tr class="memdesc:a3f86a4f778e8c9303e6c0f127e52a5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the first n bytes of <a class="el" href="classproton_1_1io_1_1connection__driver.html#af477c1401cee5a0cf3bc8d6f4d2be805" title="The engine&#39;s read buffer. ">read_buffer()</a> have valid data.  <a href="#a3f86a4f778e8c9303e6c0f127e52a5e2">More...</a><br /></td></tr>
<tr class="separator:a3f86a4f778e8c9303e6c0f127e52a5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa622a6fed072f5b4935881efb42ba5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#aaa622a6fed072f5b4935881efb42ba5c">read_close</a> ()</td></tr>
<tr class="memdesc:aaa622a6fed072f5b4935881efb42ba5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the read side of the transport is closed and no more data will be read.  <a href="#aaa622a6fed072f5b4935881efb42ba5c">More...</a><br /></td></tr>
<tr class="separator:aaa622a6fed072f5b4935881efb42ba5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2fdb0871921fc22ba7c119f8c624f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structproton_1_1io_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#aca2fdb0871921fc22ba7c119f8c624f5">write_buffer</a> ()</td></tr>
<tr class="memdesc:aca2fdb0871921fc22ba7c119f8c624f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The engine's write buffer.  <a href="#aca2fdb0871921fc22ba7c119f8c624f5">More...</a><br /></td></tr>
<tr class="separator:aca2fdb0871921fc22ba7c119f8c624f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf05de753467bf31b70db61c8effc80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#aedf05de753467bf31b70db61c8effc80">write_done</a> (size_t n)</td></tr>
<tr class="memdesc:aedf05de753467bf31b70db61c8effc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the first n bytes of <a class="el" href="classproton_1_1io_1_1connection__driver.html#aca2fdb0871921fc22ba7c119f8c624f5" title="The engine&#39;s write buffer. ">write_buffer()</a> have been written successfully.  <a href="#aedf05de753467bf31b70db61c8effc80">More...</a><br /></td></tr>
<tr class="separator:aedf05de753467bf31b70db61c8effc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad730a1d850ea31f35102b765d0eede4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#ad730a1d850ea31f35102b765d0eede4a">write_close</a> ()</td></tr>
<tr class="memdesc:ad730a1d850ea31f35102b765d0eede4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the write side of the transport has closed and no more data can be written.  <a href="#ad730a1d850ea31f35102b765d0eede4a">More...</a><br /></td></tr>
<tr class="separator:ad730a1d850ea31f35102b765d0eede4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81e38a2516ddb11a1790b5b2af6a5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classproton_1_1timestamp.html">timestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#ac81e38a2516ddb11a1790b5b2af6a5ba">tick</a> (<a class="el" href="classproton_1_1timestamp.html">timestamp</a> now)</td></tr>
<tr class="memdesc:ac81e38a2516ddb11a1790b5b2af6a5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that time has passed.  <a href="#ac81e38a2516ddb11a1790b5b2af6a5ba">More...</a><br /></td></tr>
<tr class="separator:ac81e38a2516ddb11a1790b5b2af6a5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4d44bc02e9c32598aa40f03e6c5ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a3f4d44bc02e9c32598aa40f03e6c5ae7">disconnected</a> (const <a class="el" href="classproton_1_1error__condition.html">error_condition</a> &amp;=<a class="el" href="classproton_1_1error__condition.html">error_condition</a>())</td></tr>
<tr class="memdesc:a3f4d44bc02e9c32598aa40f03e6c5ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform the engine that the transport been disconnected unexpectedly, without completing the AMQP connection close sequence.  <a href="#a3f4d44bc02e9c32598aa40f03e6c5ae7">More...</a><br /></td></tr>
<tr class="separator:a3f4d44bc02e9c32598aa40f03e6c5ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be634582ecaf2ae8d059d30fa97cf00"><td class="memItemLeft" align="right" valign="top"><a id="a8be634582ecaf2ae8d059d30fa97cf00"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a8be634582ecaf2ae8d059d30fa97cf00">has_events</a> () const</td></tr>
<tr class="memdesc:a8be634582ecaf2ae8d059d30fa97cf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are events to be dispatched by <a class="el" href="classproton_1_1io_1_1connection__driver.html#a4c79ad1c9029d967b9e1b4daf91b7537" title="Dispatch all available events and call the corresponding messaging_handler methods. ">dispatch()</a> <br /></td></tr>
<tr class="separator:a8be634582ecaf2ae8d059d30fa97cf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c79ad1c9029d967b9e1b4daf91b7537"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a4c79ad1c9029d967b9e1b4daf91b7537">dispatch</a> ()</td></tr>
<tr class="memdesc:a4c79ad1c9029d967b9e1b4daf91b7537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch all available events and call the corresponding <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> methods.  <a href="#a4c79ad1c9029d967b9e1b4daf91b7537">More...</a><br /></td></tr>
<tr class="separator:a4c79ad1c9029d967b9e1b4daf91b7537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8239782294f4dacf38c46a2640e55bf0"><td class="memItemLeft" align="right" valign="top"><a id="a8239782294f4dacf38c46a2640e55bf0"></a>
<a class="el" href="classproton_1_1connection.html">proton::connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a8239782294f4dacf38c46a2640e55bf0">connection</a> () const</td></tr>
<tr class="memdesc:a8239782294f4dacf38c46a2640e55bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the AMQP connection associated with this <a class="el" href="classproton_1_1io_1_1connection__driver.html" title="Unsettled API - An AMQP driver for a single connection. ">connection_driver</a>. <br /></td></tr>
<tr class="separator:a8239782294f4dacf38c46a2640e55bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bd8677ca01c17bc04d6064bbc2c394"><td class="memItemLeft" align="right" valign="top"><a id="ae6bd8677ca01c17bc04d6064bbc2c394"></a>
<a class="el" href="classproton_1_1transport.html">proton::transport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#ae6bd8677ca01c17bc04d6064bbc2c394">transport</a> () const</td></tr>
<tr class="memdesc:ae6bd8677ca01c17bc04d6064bbc2c394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transport associated with this <a class="el" href="classproton_1_1io_1_1connection__driver.html" title="Unsettled API - An AMQP driver for a single connection. ">connection_driver</a>. <br /></td></tr>
<tr class="separator:ae6bd8677ca01c17bc04d6064bbc2c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2129b84576000b05021be09896a3e59c"><td class="memItemLeft" align="right" valign="top"><a id="a2129b84576000b05021be09896a3e59c"></a>
<a class="el" href="classproton_1_1container.html">proton::container</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproton_1_1io_1_1connection__driver.html#a2129b84576000b05021be09896a3e59c">container</a> () const</td></tr>
<tr class="memdesc:a2129b84576000b05021be09896a3e59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the container associated with this <a class="el" href="classproton_1_1io_1_1connection__driver.html" title="Unsettled API - An AMQP driver for a single connection. ">connection_driver</a>, if there is one. <br /></td></tr>
<tr class="separator:a2129b84576000b05021be09896a3e59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b>Unsettled API</b> - An AMQP driver for a single connection. </p>
<p><a class="el" href="classproton_1_1io_1_1connection__driver.html" title="Unsettled API - An AMQP driver for a single connection. ">io::connection_driver</a> manages a single <a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer. ">proton::connection</a> and dispatches events to a <a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a>. It does no IO of its own, but allows you to integrate AMQP protocol handling into any IO or concurrency framework.</p>
<p>The application is coded the same way as for the <a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links. ">proton::container</a>. The application implements a <a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a> to respond to transport, connection, session, link, and message events. With a little care, the same handler classes can be used for both container and <a class="el" href="classproton_1_1io_1_1connection__driver.html" title="Unsettled API - An AMQP driver for a single connection. ">connection_driver</a>. the <a class="el" href="broker_8cpp-example.html">broker.cpp</a> example illustrates this.</p>
<p>You need to write the IO code to read AMQP data to the <a class="el" href="classproton_1_1io_1_1connection__driver.html#af477c1401cee5a0cf3bc8d6f4d2be805" title="The engine&#39;s read buffer. ">read_buffer()</a>. The engine parses the AMQP frames. <a class="el" href="classproton_1_1io_1_1connection__driver.html#a4c79ad1c9029d967b9e1b4daf91b7537" title="Dispatch all available events and call the corresponding messaging_handler methods. ">dispatch()</a> calls the appropriate functions on the applications <a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a>. You write output data from the engine's <a class="el" href="classproton_1_1io_1_1connection__driver.html#aca2fdb0871921fc22ba7c119f8c624f5" title="The engine&#39;s write buffer. ">write_buffer()</a> to your IO.</p>
<p>The engine is not safe for concurrent use, but you can process different engines concurrently. A common pattern for high-performance servers is to serialize read/write activity per connection and dispatch in a fixed-size thread pool.</p>
<p>The engine is designed to work with a classic reactor (e.g., select, poll, epoll) or an async-request driven proactor (e.g., windows completion ports, boost.asio, libuv).</p>
<p>The engine never throws exceptions. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a86d2b78bee258ce7bb56806d11a122d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d2b78bee258ce7bb56806d11a122d3">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classproton_1_1connection__options.html">connection_options</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>server</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a connection by applying exactly the options in opts (including <a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a>) Does not apply any default options, to apply container defaults use <a class="el" href="classproton_1_1io_1_1connection__driver.html#a49ffce3927a9d5013293bf92fde9e9a2" title="Call configure() with client options and call connection::open() Options applied: container::id()...">connect()</a> or <a class="el" href="classproton_1_1io_1_1connection__driver.html#a8a5938806dc28d71c3ed5f89cc537ddd" title="Call configure() with server options. ">accept()</a> instead. </p>
<p>If server==true, configure a server connection. </p>

</div>
</div>
<a id="a49ffce3927a9d5013293bf92fde9e9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ffce3927a9d5013293bf92fde9e9a2">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call <a class="el" href="classproton_1_1io_1_1connection__driver.html#a86d2b78bee258ce7bb56806d11a122d3" title="Configure a connection by applying exactly the options in opts (including proton::messaging_handler) ...">configure()</a> with client options and call <a class="el" href="classproton_1_1connection.html#a9e8555112049fc2b4945120b3c45f8ab" title="Open the connection. ">connection::open()</a> Options applied: <a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677" title="A unique identifier for the container. ">container::id()</a>, <a class="el" href="classproton_1_1container.html#a913a88786abbbf08dd3e53e2a3e4accb" title="Connection options applied to outgoing connections. ">container::client_connection_options()</a>, opts. </p>

</div>
</div>
<a id="a8a5938806dc28d71c3ed5f89cc537ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5938806dc28d71c3ed5f89cc537ddd">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void accept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1connection__options.html">connection_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call <a class="el" href="classproton_1_1io_1_1connection__driver.html#a86d2b78bee258ce7bb56806d11a122d3" title="Configure a connection by applying exactly the options in opts (including proton::messaging_handler) ...">configure()</a> with server options. </p>
<p>Options applied: <a class="el" href="classproton_1_1container.html#a4c5cdd8165762b000c6518db56830677" title="A unique identifier for the container. ">container::id()</a>, <a class="el" href="classproton_1_1container.html#a7daf70330e5259fbb6ae3f01cfbc125a" title="Connection options applied to incoming connections. ">container::server_connection_options()</a>, opts.</p>
<p>Note this does not call <a class="el" href="classproton_1_1connection.html#a9e8555112049fc2b4945120b3c45f8ab" title="Open the connection. ">connection::open()</a>. If there is a <a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">messaging_handler</a> in the composed options it will receive <a class="el" href="classproton_1_1messaging__handler.html#a41277abe0e33a3df2764b08dcc12d768" title="The remote peer opened the connection. ">messaging_handler::on_connection_open()</a> and can respond with <a class="el" href="classproton_1_1connection.html#a9e8555112049fc2b4945120b3c45f8ab" title="Open the connection. ">connection::open()</a> or <a class="el" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca" title="Close the endpoint. ">connection::close()</a> </p>

</div>
</div>
<a id="af477c1401cee5a0cf3bc8d6f4d2be805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af477c1401cee5a0cf3bc8d6f4d2be805">&#9670;&nbsp;</a></span>read_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structproton_1_1io_1_1mutable__buffer.html">mutable_buffer</a> read_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The engine's read buffer. </p>
<p>Read data into this buffer then call <a class="el" href="classproton_1_1io_1_1connection__driver.html#a3f86a4f778e8c9303e6c0f127e52a5e2" title="Indicate that the first n bytes of read_buffer() have valid data. ">read_done()</a> when complete. Returns mutable_buffer(0, 0) if the engine cannot currently read data. Calling <a class="el" href="classproton_1_1io_1_1connection__driver.html#a4c79ad1c9029d967b9e1b4daf91b7537" title="Dispatch all available events and call the corresponding messaging_handler methods. ">dispatch()</a> may open up more buffer space. </p>

</div>
</div>
<a id="a3f86a4f778e8c9303e6c0f127e52a5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f86a4f778e8c9303e6c0f127e52a5e2">&#9670;&nbsp;</a></span>read_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_done </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that the first n bytes of <a class="el" href="classproton_1_1io_1_1connection__driver.html#af477c1401cee5a0cf3bc8d6f4d2be805" title="The engine&#39;s read buffer. ">read_buffer()</a> have valid data. </p>
<p>This changes the buffer, call <a class="el" href="classproton_1_1io_1_1connection__driver.html#af477c1401cee5a0cf3bc8d6f4d2be805" title="The engine&#39;s read buffer. ">read_buffer()</a> to get the updated buffer. </p>

</div>
</div>
<a id="aaa622a6fed072f5b4935881efb42ba5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa622a6fed072f5b4935881efb42ba5c">&#9670;&nbsp;</a></span>read_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that the read side of the transport is closed and no more data will be read. </p>
<p>Note that there may still be events to <a class="el" href="classproton_1_1io_1_1connection__driver.html#a4c79ad1c9029d967b9e1b4daf91b7537" title="Dispatch all available events and call the corresponding messaging_handler methods. ">dispatch()</a> or data to write. </p>

</div>
</div>
<a id="aca2fdb0871921fc22ba7c119f8c624f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2fdb0871921fc22ba7c119f8c624f5">&#9670;&nbsp;</a></span>write_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structproton_1_1io_1_1const__buffer.html">const_buffer</a> write_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The engine's write buffer. </p>
<p>Write data from this buffer then call <a class="el" href="classproton_1_1io_1_1connection__driver.html#aedf05de753467bf31b70db61c8effc80" title="Indicate that the first n bytes of write_buffer() have been written successfully. ...">write_done()</a> Returns const_buffer(0, 0) if the engine has nothing to write. Calling <a class="el" href="classproton_1_1io_1_1connection__driver.html#a4c79ad1c9029d967b9e1b4daf91b7537" title="Dispatch all available events and call the corresponding messaging_handler methods. ">dispatch()</a> may generate more data in the write buffer. </p>

</div>
</div>
<a id="aedf05de753467bf31b70db61c8effc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf05de753467bf31b70db61c8effc80">&#9670;&nbsp;</a></span>write_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_done </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that the first n bytes of <a class="el" href="classproton_1_1io_1_1connection__driver.html#aca2fdb0871921fc22ba7c119f8c624f5" title="The engine&#39;s write buffer. ">write_buffer()</a> have been written successfully. </p>
<p>This changes the buffer, call <a class="el" href="classproton_1_1io_1_1connection__driver.html#aca2fdb0871921fc22ba7c119f8c624f5" title="The engine&#39;s write buffer. ">write_buffer()</a> to get the updated buffer. </p>

</div>
</div>
<a id="ad730a1d850ea31f35102b765d0eede4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad730a1d850ea31f35102b765d0eede4a">&#9670;&nbsp;</a></span>write_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that the write side of the transport has closed and no more data can be written. </p>
<p>Note that there may still be events to <a class="el" href="classproton_1_1io_1_1connection__driver.html#a4c79ad1c9029d967b9e1b4daf91b7537" title="Dispatch all available events and call the corresponding messaging_handler methods. ">dispatch()</a> or data to read. </p>

</div>
</div>
<a id="ac81e38a2516ddb11a1790b5b2af6a5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81e38a2516ddb11a1790b5b2af6a5ba">&#9670;&nbsp;</a></span>tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classproton_1_1timestamp.html">timestamp</a> tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproton_1_1timestamp.html">timestamp</a>&#160;</td>
          <td class="paramname"><em>now</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that time has passed. </p>
<dl class="section return"><dt>Returns</dt><dd>the expiration time of the next unexpired timer. You must arrange to call <a class="el" href="classproton_1_1io_1_1connection__driver.html#ac81e38a2516ddb11a1790b5b2af6a5ba" title="Indicate that time has passed. ">tick()</a> no later than this expiration time. In practice this will mean calling <a class="el" href="classproton_1_1io_1_1connection__driver.html#ac81e38a2516ddb11a1790b5b2af6a5ba" title="Indicate that time has passed. ">tick()</a> every time there is anything read or written, and if nothing is read or written then as soon as possible after the returned timestamp (so you will probably need to set a platform specific timeout to know when this occurs). </dd></dl>

</div>
</div>
<a id="a3f4d44bc02e9c32598aa40f03e6c5ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4d44bc02e9c32598aa40f03e6c5ae7">&#9670;&nbsp;</a></span>disconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disconnected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproton_1_1error__condition.html">error_condition</a> &amp;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="classproton_1_1error__condition.html">error_condition</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inform the engine that the transport been disconnected unexpectedly, without completing the AMQP connection close sequence. </p>
<p>This calls <a class="el" href="classproton_1_1io_1_1connection__driver.html#aaa622a6fed072f5b4935881efb42ba5c" title="Indicate that the read side of the transport is closed and no more data will be read. ">read_close()</a>, <a class="el" href="classproton_1_1io_1_1connection__driver.html#ad730a1d850ea31f35102b765d0eede4a" title="Indicate that the write side of the transport has closed and no more data can be written. ">write_close()</a>, sets the <a class="el" href="classproton_1_1io_1_1connection__driver.html#ae6bd8677ca01c17bc04d6064bbc2c394" title="Get the transport associated with this connection_driver. ">transport()</a>.error() and queues an <code>on_transport_error</code> event. You must call <a class="el" href="classproton_1_1io_1_1connection__driver.html#a4c79ad1c9029d967b9e1b4daf91b7537" title="Dispatch all available events and call the corresponding messaging_handler methods. ">dispatch()</a> one more time to dispatch the <a class="el" href="classproton_1_1messaging__handler.html#ab719e98555bab69986acf4ab1fe43665" title="The underlying network transport has closed with an error condition. ">messaging_handler::on_transport_error()</a> call and other final events.</p>
<p>Note this does not close the <a class="el" href="classproton_1_1io_1_1connection__driver.html#a8239782294f4dacf38c46a2640e55bf0" title="Get the AMQP connection associated with this connection_driver. ">connection()</a> so that a <a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a> can distinguish between a connection close error sent by the remote peer and a transport failure. </p>

</div>
</div>
<a id="a4c79ad1c9029d967b9e1b4daf91b7537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c79ad1c9029d967b9e1b4daf91b7537">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dispatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch all available events and call the corresponding <a class="el" href="classproton_1_1messaging__handler.html">messaging_handler</a> methods. </p>
<p>Returns true if the engine is still active, false if it is finished and can be destroyed. The engine is finished when all events are dispatched and one of the following is true:</p>
<ul>
<li>both <a class="el" href="classproton_1_1io_1_1connection__driver.html#aaa622a6fed072f5b4935881efb42ba5c" title="Indicate that the read side of the transport is closed and no more data will be read. ">read_close()</a> and <a class="el" href="classproton_1_1io_1_1connection__driver.html#ad730a1d850ea31f35102b765d0eede4a" title="Indicate that the write side of the transport has closed and no more data can be written. ">write_close()</a> have been called, no more IO is possible.</li>
<li>The AMQP <a class="el" href="classproton_1_1io_1_1connection__driver.html#a8239782294f4dacf38c46a2640e55bf0" title="Get the AMQP connection associated with this connection_driver. ">connection()</a> is closed AND the <a class="el" href="classproton_1_1io_1_1connection__driver.html#aca2fdb0871921fc22ba7c119f8c624f5" title="The engine&#39;s write buffer. ">write_buffer()</a> is empty.</li>
</ul>
<p>May modify the <a class="el" href="classproton_1_1io_1_1connection__driver.html#af477c1401cee5a0cf3bc8d6f4d2be805" title="The engine&#39;s read buffer. ">read_buffer()</a> and/or the <a class="el" href="classproton_1_1io_1_1connection__driver.html#aca2fdb0871921fc22ba7c119f8c624f5" title="The engine&#39;s write buffer. ">write_buffer()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>proton/io/<a class="el" href="connection__driver_8hpp_source.html">connection_driver.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceproton.html">proton</a></li><li class="navelem"><a class="el" href="namespaceproton_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classproton_1_1io_1_1connection__driver.html">connection_driver</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
