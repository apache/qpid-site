<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qpid Proton C++ API: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">0.20.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_page.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a brief guide to to the fundamentals of building messaging applications using Qpid Proton C++.</p>
<p>Proton provides an "event-driven" programming model, where you implement a subclass of <code><a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a></code> and override functions that react to various AMQP events (connections opening and closing, messages being delivered, and so on).</p>
<p>The examples below show how to implement handlers for clients and servers and how to run them using the <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links. ">proton::container</a></code>, a portable, easy-to-use way to build single-threaded clients or servers.</p>
<p>Some of the examples require an AMQP <em>broker</em> that can receive, store, and send messages. <a class="el" href="broker_8cpp-example.html">broker.cpp</a> defines a simple example broker. If run without arguments, it listens on <code>0.0.0.0:5672</code>, the standard AMQP port on all network interfaces. To use a different port or network interface, use the <code>-a</code> option. </p><pre class="fragment">broker -a &lt;host&gt;:&lt;port&gt;
</pre><p>Instead of the example broker, you can use any AMQP 1.0-compliant broker. You must configure your broker to have a queue (or topic) named "examples".</p>
<p>The <code>helloworld</code> examples take an optional URL argument. The other examples take an option <code>-a URL</code>. A URL looks like this: </p><pre class="fragment">HOST:PORT/ADDRESS
</pre><p>It usually defaults to <code>127.0.0.1:5672/examples</code>, but you can change this if your broker is on a different host or port, or you want to use a different queue or topic name (the ADDRESS part of the URL).</p>
<h2>Hello World! </h2>
<p>Tradition dictates that we start with Hello World! This example sends a message to a broker and then receives the same message back. In a realistic system the sender and receiver would normally be in different processes. The complete example is <a class="el" href="helloworld_8cpp-example.html">helloworld.cpp</a></p>
<p>We will include the following classes. <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links. ">proton::container</a></code> runs an event loop which dispatches events to a <code><a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a></code>. This allows a <em>reactive</em> style of programming which is well suited to messaging applications. <code><a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer. ">proton::connection</a></code> and <code><a class="el" href="classproton_1_1delivery.html" title="A received message. ">proton::delivery</a></code> are AMQP entities used in the handler functions. <code><a class="el" href="classproton_1_1url.html" title="Deprecated - Use a third-party URL library. ">proton::url</a></code> is a simple parser for the URL format mentioned above.</p>
<p><div class="fragment"></div><!-- fragment --></p>
<p>We will define a class <code>hello_world</code> which is a subclass of <code><a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a></code> and overrides functions to handle the events of interest in sending and receiving a message.</p>
<p><div class="fragment"></div><!-- fragment --></p>
<p><code><a class="el" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824" title="The container event loop is starting. ">proton::messaging_handler::on_container_start()</a></code> is called when the event loop first starts. We handle that by establishing a connection and creating a sender and a receiver.</p>
<p><div class="fragment"></div><!-- fragment --></p>
<p><code><a class="el" href="classproton_1_1messaging__handler.html#a86c9509ba3ce1925150c5b7a9a937c94" title="A message can be sent. ">proton::messaging_handler::on_sendable()</a></code> is called when the message can be transferred over the associated sender link to the remote peer. We create a <code><a class="el" href="classproton_1_1message.html" title="An AMQP message. ">proton::message</a></code>, set the message body to <code>"Hello
World!"</code>, and send the message. Then we close the sender, since we only want to send one message. Closing the sender will prevent further calls to <code><a class="el" href="classproton_1_1messaging__handler.html#a86c9509ba3ce1925150c5b7a9a937c94" title="A message can be sent. ">proton::messaging_handler::on_sendable()</a></code>.</p>
<p><div class="fragment"></div><!-- fragment --></p>
<p><code><a class="el" href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb" title="A message is received. ">proton::messaging_handler::on_message()</a></code> is called when a message is received. We just print the body of the message and close the connection, as we only want one message.</p>
<p><div class="fragment"></div><!-- fragment --></p>
<p>The message body is a <code><a class="el" href="classproton_1_1value.html" title="A holder for any AMQP value, simple or complex. ">proton::value</a></code>. See <a class="el" href="types_page.html">AMQP and C++ types</a> for more on how to extract the message body as type-safe C++ values.</p>
<p>Our <code>main</code> function creates an instance of the <code>hello_world</code> handler and a <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links. ">proton::container</a></code> using that handler. Calling <code><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in the current thread. ">proton::container::run()</a></code> sets things in motion and returns when we close the connection. It may throw an exception, which will be a subclass of <code><a class="el" href="structproton_1_1error.html" title="The base Proton error. ">proton::error</a></code>. That in turn is a subclass of <code>std::exception</code>.</p>
<p><div class="fragment"></div><!-- fragment --></p>
<h2>Asynchronous send and receive </h2>
<p>Of course, these <code>Hello World!</code> examples are very artificial, communicating as they do over a network connection but with the same process. A more realistic example involves communication between separate processes, which could indeed be running on completely separate machines.</p>
<p>Let's separate the sender from the receiver, and transfer more than a single message between them.</p>
<p>We'll start with a simple sender, <a class="el" href="simple_send_8cpp-example.html">simple_send.cpp</a>.</p>
<p>As with the previous example, we define the application logic in a class that handles events. Because we are transferring more than one message, we need to keep track of how many we have sent. We'll use a <code>sent</code> member variable for that. The <code>total</code> member variable will hold the number of messages we want to send.</p>
<p><div class="fragment"><div class="line"><span class="keyword">class </span>simple_send : <span class="keyword">public</span> <a class="code" href="classproton_1_1messaging__handler.html">proton::messaging_handler</a> {</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    std::string url;</div><div class="line">    std::string user;</div><div class="line">    std::string password;</div><div class="line">    <a class="code" href="classproton_1_1sender.html">proton::sender</a> sender;</div><div class="line">    <span class="keywordtype">int</span> sent;</div><div class="line">    <span class="keywordtype">int</span> confirmed;</div><div class="line">    <span class="keywordtype">int</span> total;</div></div><!-- fragment --></p>
<p>As before, we use the <code><a class="el" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824" title="The container event loop is starting. ">proton::messaging_handler::on_container_start()</a></code> event to establish our sender link over which we will transfer messages.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c) OVERRIDE {</div><div class="line">        <a class="code" href="classproton_1_1connection__options.html">proton::connection_options</a> co;</div><div class="line">        <span class="keywordflow">if</span> (!user.empty()) co.<a class="code" href="classproton_1_1connection__options.html#a10afa48d580025f71f0a6dd31bd1de24">user</a>(user);</div><div class="line">        <span class="keywordflow">if</span> (!password.empty()) co.<a class="code" href="classproton_1_1connection__options.html#a78a90a1387cf91915dbe39b888955d75">password</a>(password);</div><div class="line">        sender = c.open_sender(url, co);</div><div class="line">    }</div></div><!-- fragment --></p>
<p>AMQP defines a credit-based flow-control mechanism. Flow control allows the receiver to control how many messages it is prepared to receive at a given time and thus prevents any component being overwhelmed by the number of messages it is sent.</p>
<p>In the <code><a class="el" href="classproton_1_1messaging__handler.html#a86c9509ba3ce1925150c5b7a9a937c94" title="A message can be sent. ">proton::messaging_handler::on_sendable()</a></code> callback, we check that our sender has credit before sending messages. We also check that we haven't already sent the required number of messages.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_sendable(<a class="code" href="classproton_1_1sender.html">proton::sender</a> &amp;s) OVERRIDE {</div><div class="line">        <span class="keywordflow">while</span> (s.credit() &amp;&amp; sent &lt; total) {</div><div class="line">            <a class="code" href="classproton_1_1message.html">proton::message</a> msg;</div><div class="line">            std::map&lt;std::string, int&gt; m;</div><div class="line">            m[<span class="stringliteral">&quot;sequence&quot;</span>] = sent + 1;</div><div class="line"></div><div class="line">            msg.<a class="code" href="classproton_1_1message.html#a84811758e758988a802673edca6b77cb">id</a>(sent + 1);</div><div class="line">            msg.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>(m);</div><div class="line"></div><div class="line">            s.send(msg);</div><div class="line">            sent++;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></p>
<p>The <code><a class="el" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830" title="Send a message on the sender. ">proton::sender::send()</a></code> call above is asynchronous. When it returns, the message has not yet actually been transferred across the network to the receiver. By handling the <code><a class="el" href="classproton_1_1messaging__handler.html#a4e61812588fe6fbde253b41f7c02e993" title="The receiving peer accepted a transfer. ">proton::messaging_handler::on_tracker_accept()</a></code> event, we can get notified when the receiver has received and accepted the message. In our example we use this event to track the confirmation of the messages we have sent. We only close the connection and exit when the receiver has received all the messages we wanted to send.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_tracker_accept(<a class="code" href="classproton_1_1tracker.html">proton::tracker</a> &amp;t) OVERRIDE {</div><div class="line">        confirmed++;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (confirmed == total) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;all messages confirmed&quot;</span> &lt;&lt; std::endl;</div><div class="line">            t.connection().close();</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></p>
<p>If we are disconnected after a message is sent and before it has been confirmed by the receiver, it is said to be "in doubt". We don't know whether or not it was received. In this example, we will handle that by resending any in-doubt messages. This is known as an "at-least-once" guarantee, since each message should eventually be received at least once, though a given message may be received more than once (i.e., duplicates are possible). In the <code><a class="el" href="classproton_1_1messaging__handler.html#a8a60c2f6628f44a9587deea8c8729f0f" title="The underlying network transport has closed. ">proton::messaging_handler::on_transport_close()</a></code> callback, we reset the sent count to reflect only those that have been confirmed. The library will automatically try to reconnect for us, and when our sender is sendable again, we can restart from the point we know the receiver got to.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_transport_close(<a class="code" href="classproton_1_1transport.html">proton::transport</a> &amp;) OVERRIDE {</div><div class="line">        sent = confirmed;</div><div class="line">    }</div></div><!-- fragment --></p>
<p>Now let's look at the corresponding receiver, <a class="el" href="simple_recv_8cpp-example.html">simple_recv.cpp</a>.</p>
<p>This time we'll use an <code>expected</code> member variable for for the number of messages we expect and a <code>received</code> variable to count how many we have received so far.</p>
<p><div class="fragment"><div class="line"><span class="keyword">class </span>simple_recv : <span class="keyword">public</span> <a class="code" href="classproton_1_1messaging__handler.html">proton::messaging_handler</a> {</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    std::string url;</div><div class="line">    std::string user;</div><div class="line">    std::string password;</div><div class="line">    <a class="code" href="classproton_1_1receiver.html">proton::receiver</a> receiver;</div><div class="line">    <span class="keywordtype">int</span> expected;</div><div class="line">    <span class="keywordtype">int</span> received;</div></div><!-- fragment --></p>
<p>We handle <code><a class="el" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824" title="The container event loop is starting. ">proton::messaging_handler::on_container_start()</a></code> by creating our receiver, much like we did for the sender.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c) OVERRIDE {</div><div class="line">        <a class="code" href="classproton_1_1connection__options.html">proton::connection_options</a> co;</div><div class="line">        <span class="keywordflow">if</span> (!user.empty()) co.<a class="code" href="classproton_1_1connection__options.html#a10afa48d580025f71f0a6dd31bd1de24">user</a>(user);</div><div class="line">        <span class="keywordflow">if</span> (!password.empty()) co.<a class="code" href="classproton_1_1connection__options.html#a78a90a1387cf91915dbe39b888955d75">password</a>(password);</div><div class="line">        receiver = c.open_receiver(url, co);</div><div class="line">    }</div></div><!-- fragment --></p>
<p>We also handle the <code><a class="el" href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb" title="A message is received. ">proton::messaging_handler::on_message()</a></code> event for received messages and print the message out as in the <code>Hello World!</code> examples. However, we add some logic to allow the receiver to wait for a given number of messages and then close the connection and exit. We also add some logic to check for and ignore duplicates, using a simple sequential ID scheme.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a> &amp;d, <a class="code" href="classproton_1_1message.html">proton::message</a> &amp;msg) OVERRIDE {</div><div class="line">        <span class="keywordflow">if</span> (proton::coerce&lt;int&gt;(msg.<a class="code" href="classproton_1_1message.html#a84811758e758988a802673edca6b77cb">id</a>()) &lt; received) {</div><div class="line">            <span class="keywordflow">return</span>; <span class="comment">// Ignore duplicate</span></div><div class="line">        }</div></div><!-- fragment --></p>
<h2>Direct send and receive </h2>
<p>Sending between these two examples requires an intermediary broker since neither accepts incoming connections. AMQP allows us to send messages directly between two processes. In that case, one or other of the processes needs to accept incoming connections. Let's create a modified version of the receiving example that does this with <a class="el" href="direct_recv_8cpp-example.html">direct_recv.cpp</a>.</p>
<p>There are only two differences here. Instead of initiating a link (and implicitly a connection), we listen for incoming connections.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c) OVERRIDE {</div><div class="line">        listener = c.listen(url, listen_handler);</div><div class="line">    }</div></div><!-- fragment --></p>
<p>When we have received all the expected messages, we then stop listening for incoming connections by calling <code><a class="el" href="classproton_1_1listener.html#a8c528baf37154d347366083f0f816846" title="Stop listening on the address provided to the call to container::listen that returned this listener...">proton::listener::stop()</a></code></p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a> &amp;d, <a class="code" href="classproton_1_1message.html">proton::message</a> &amp;msg) OVERRIDE {</div><div class="line">        <span class="keywordflow">if</span> (proton::coerce&lt;int&gt;(msg.<a class="code" href="classproton_1_1message.html#a84811758e758988a802673edca6b77cb">id</a>()) &lt; received) {</div><div class="line">            <span class="keywordflow">return</span>; <span class="comment">// Ignore duplicate</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (expected == 0 || received &lt; expected) {</div><div class="line">            std::cout &lt;&lt; msg.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>() &lt;&lt; std::endl;</div><div class="line">            received++;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (received == expected) {</div><div class="line">            d.receiver().close();</div><div class="line">            d.connection().close();</div><div class="line">            listener.stop();</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></p>
<p>You can use the <a class="el" href="simple_send_8cpp-example.html">simple_send.cpp</a> example to send to this receiver directly. (Note: you will need to stop any broker that is listening on the 5672 port, or else change the port used by specifying a different address to each example via the <code>-a</code> command-line switch).</p>
<p>We can also modify the sender to allow the original receiver to connect to it, in <a class="el" href="direct_send_8cpp-example.html">direct_send.cpp</a>. Again, that requires just two modifications:</p>
<p>As with the modified receiver, instead of initiating establishment of a link, we listen for incoming connections.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c) OVERRIDE {</div><div class="line">        listener = c.listen(url, listen_handler);</div><div class="line">    }</div></div><!-- fragment --></p>
<p>When we have received confirmation of all the messages we sent, we call <code>container::listener::stop()</code> to exit.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_tracker_accept(<a class="code" href="classproton_1_1tracker.html">proton::tracker</a> &amp;t) OVERRIDE {</div><div class="line">        confirmed++;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (confirmed == total) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;all messages confirmed&quot;</span> &lt;&lt; std::endl;</div><div class="line">            t.connection().close();</div><div class="line">            listener.stop();</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></p>
<p>To try this modified sender, run the original <a class="el" href="simple_recv_8cpp-example.html">simple_recv.cpp</a> against it.</p>
<p>The symmetry in the underlying AMQP wire protocol that enables this is quite unique and elegant, and in reflecting this the Proton API provides a flexible toolkit for implementing all sorts of interesting intermediaries.</p>
<h2>Request and response </h2>
<p>A common pattern is to send a request message and expect a response message in return. AMQP has special support for this pattern. Let's have a look at a simple example. We'll start with <a class="el" href="server_8cpp-example.html">server.cpp</a>, the program that will process the request and send the response. Note that we are still using a broker in this example.</p>
<p>Our server will provide a very simple service: it will respond with the body of the request converted to uppercase.</p>
 <div class="fragment"><div class="line"><span class="keyword">class </span>server : <span class="keyword">public</span> <a class="code" href="classproton_1_1messaging__handler.html">proton::messaging_handler</a> {</div><div class="line">    std::string conn_url_;</div><div class="line">    std::string addr_;</div><div class="line">    <a class="code" href="classproton_1_1connection.html">proton::connection</a> conn_;</div><div class="line">    std::map&lt;std::string, proton::sender&gt; senders_;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    server(<span class="keyword">const</span> std::string&amp; u, <span class="keyword">const</span> std::string&amp; a) :</div><div class="line">        conn_url_(u), addr_(a) {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824">on_container_start</a>(<a class="code" href="classproton_1_1container.html">proton::container</a>&amp; c) OVERRIDE {</div><div class="line">        conn_ = c.connect(conn_url_);</div><div class="line">        conn_.<a class="code" href="classproton_1_1connection.html#aad60d14592ee9d34caca4c61214ecd27">open_receiver</a>(addr_);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Server connected to &quot;</span> &lt;&lt; conn_url_ &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::string to_upper(<span class="keyword">const</span> std::string&amp; s) {</div><div class="line">        std::string uc(s);</div><div class="line">        <span class="keywordtype">size_t</span> l = uc.size();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;l; i++) {</div><div class="line">            uc[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(std::toupper(uc[i]));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> uc;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb">on_message</a>(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a>&amp;, <a class="code" href="classproton_1_1message.html">proton::message</a>&amp; m) OVERRIDE {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt; m.body() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        std::string reply_to = m.reply_to();</div><div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a> reply;</div><div class="line"></div><div class="line">        reply.<a class="code" href="classproton_1_1message.html#a2fda6a98616365e06f1d4a627d1a58ac">to</a>(reply_to);</div><div class="line">        reply.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>(to_upper(proton::get&lt;std::string&gt;(m.body())));</div><div class="line">        reply.<a class="code" href="classproton_1_1message.html#ad159656f1742235cd22a9c6aaabf9d2d">correlation_id</a>(m.correlation_id());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!senders_[reply_to]) {</div><div class="line">            senders_[reply_to] = conn_.<a class="code" href="classproton_1_1connection.html#ae8eece4fd4b9e1a2531ca12d2ab57a32">open_sender</a>(reply_to);</div><div class="line">        }</div><div class="line"></div><div class="line">        senders_[reply_to].send(reply);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --></p>
<p>The code here is not too different from the simple receiver example. However, when we receive a request in <code><a class="el" href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb" title="A message is received. ">proton::messaging_handler::on_message</a></code>, we look at the <code><a class="el" href="classproton_1_1message.html#a4032b495d721bd6d29bfa33ebb8ac5fe" title="Set the address for replies. ">proton::message::reply_to</a></code> address and create a sender with that address for the response. We'll cache the senders in case we get further requests with the same <code>reply_to</code>.</p>
<p>Now let's create a simple <a class="el" href="client_8cpp-example.html">client.cpp</a> to test this service out.</p>
<p>Our client takes a list of strings to send as requests.</p>
<p><div class="fragment"><div class="line">    client(<span class="keyword">const</span> std::string &amp;u, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; r) : url(u), requests(r) {}</div></div><!-- fragment --></p>
<p>Since we will be sending and receiving, we create a sender and a receiver in <code><a class="el" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824" title="The container event loop is starting. ">proton::messaging_handler::on_container_start</a></code>. Our receiver has a blank address and sets the <code>dynamic</code> flag to true, which means we expect the remote end (the broker or server) to assign a unique address for us.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c) OVERRIDE {</div><div class="line">        sender = c.open_sender(url);</div><div class="line">        <span class="comment">// Create a receiver requesting a dynamically created queue</span></div><div class="line">        <span class="comment">// for the message source.</span></div><div class="line">        receiver_options opts = receiver_options().<a class="code" href="classproton_1_1sender.html#a91a9e8a9445b29d83dd0514cd76503ae">source</a>(source_options().dynamic(<span class="keyword">true</span>));</div><div class="line">        receiver = sender.<a class="code" href="classproton_1_1link.html#aff302bb6016f2ae29f01bb4e07389a52">connection</a>().<a class="code" href="classproton_1_1connection.html#aad60d14592ee9d34caca4c61214ecd27">open_receiver</a>(<span class="stringliteral">&quot;&quot;</span>, opts);</div><div class="line">    }</div></div><!-- fragment --></p>
<p>Now we need a function to send the next request from our list of requests. We set the <code>reply_to</code> address to be the dynamically assigned address of our receiver.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> send_request() {</div><div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a> req;</div><div class="line">        req.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>(requests.front());</div><div class="line">        req.<a class="code" href="classproton_1_1message.html#a4032b495d721bd6d29bfa33ebb8ac5fe">reply_to</a>(receiver.<a class="code" href="classproton_1_1receiver.html#a91a9e8a9445b29d83dd0514cd76503ae">source</a>().<a class="code" href="classproton_1_1source.html#a4744eb217c976c199b678bb5a0d55acf">address</a>());</div><div class="line">        sender.<a class="code" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830">send</a>(req);</div><div class="line">    }</div></div><!-- fragment --></p>
<p>We need to use the address assigned by the broker as the <code>reply_to</code> address of our requests, so we can't send them until our receiver has been set up. To do that, we add an <code><a class="el" href="classproton_1_1messaging__handler.html#a77f7e38659ee43ccb764e417ad6dd401" title="The remote peer opened the link. ">proton::messaging_handler::on_receiver_open()</a></code> method to our handler class and use that as the trigger to send our first request.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_receiver_open(<a class="code" href="classproton_1_1receiver.html">proton::receiver</a> &amp;) OVERRIDE {</div><div class="line">        send_request();</div><div class="line">    }</div></div><!-- fragment --></p>
<p>When we receive a reply, we send the next request.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a> &amp;d, <a class="code" href="classproton_1_1message.html">proton::message</a> &amp;response) OVERRIDE {</div><div class="line">        <span class="keywordflow">if</span> (requests.empty()) <span class="keywordflow">return</span>; <span class="comment">// Spurious extra message!</span></div><div class="line"></div><div class="line">        std::cout &lt;&lt; requests.front() &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; response.body() &lt;&lt; std::endl;</div><div class="line">        requests.erase(requests.begin());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!requests.empty()) {</div><div class="line">            send_request();</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            d.connection().close();</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></p>
<h2>Direct request and response </h2>
<p>We can avoid the intermediary process by writing a server that accepts connections directly, <a class="el" href="server_direct_8cpp-example.html">server_direct.cpp</a>. It involves the following changes to our original server:</p>
<p>Our server must generate unique <code>reply-to</code> addresses for links from the client that request a dynamic address (previously this was done by the broker). We use a simple counter.</p>
<p><div class="fragment"><div class="line">    std::string generate_address() {</div><div class="line">        std::ostringstream addr;</div><div class="line">        addr &lt;&lt; <span class="stringliteral">&quot;server&quot;</span> &lt;&lt; address_counter++;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> addr.str();</div><div class="line">    }</div></div><!-- fragment --></p>
<p>Next we need to handle incoming requests for links with dynamic addresses from the client. We give the link a unique address and record it in our <code>senders</code> map.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_sender_open(<a class="code" href="classproton_1_1sender.html">proton::sender</a> &amp;sender) OVERRIDE {</div><div class="line">        <span class="keywordflow">if</span> (sender.<a class="code" href="classproton_1_1sender.html#a91a9e8a9445b29d83dd0514cd76503ae">source</a>().<a class="code" href="classproton_1_1terminus.html#adcc4ef24adb8478230018c519aa636ec">dynamic</a>()) {</div><div class="line">            std::string addr = generate_address();</div><div class="line">            sender.<a class="code" href="classproton_1_1sender.html#a9e8555112049fc2b4945120b3c45f8ab">open</a>(<a class="code" href="classproton_1_1sender__options.html">proton::sender_options</a>().source(<a class="code" href="classproton_1_1source__options.html">proton::source_options</a>().address(addr)));</div><div class="line">            senders[addr] = sender;</div><div class="line">        }</div></div><!-- fragment --></p>
<p>Note that we are interested in <em>sender</em> links above because we are implementing the server. A <em>receiver</em> link created on the client corresponds to a <em>sender</em> link on the server.</p>
<p>Finally when we receive a message we look up its <code>reply_to</code> in our senders map and send the reply.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a> &amp;, <a class="code" href="classproton_1_1message.html">proton::message</a> &amp;m) OVERRIDE {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt; m.body() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        std::string reply_to = m.reply_to();</div><div class="line">        sender_map::iterator it = senders.find(reply_to);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (it == senders.end()) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;No link for reply_to: &quot;</span> &lt;&lt; reply_to &lt;&lt; std::endl;</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <a class="code" href="classproton_1_1sender.html">proton::sender</a> sender = it-&gt;second;</div><div class="line">            <a class="code" href="classproton_1_1message.html">proton::message</a> reply;</div><div class="line"></div><div class="line">            reply.<a class="code" href="classproton_1_1message.html#a2fda6a98616365e06f1d4a627d1a58ac">to</a>(reply_to);</div><div class="line">            reply.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>(to_upper(proton::get&lt;std::string&gt;(m.body())));</div><div class="line">            reply.<a class="code" href="classproton_1_1message.html#ad159656f1742235cd22a9c6aaabf9d2d">correlation_id</a>(m.correlation_id());</div><div class="line"></div><div class="line">            sender.<a class="code" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830">send</a>(reply);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
