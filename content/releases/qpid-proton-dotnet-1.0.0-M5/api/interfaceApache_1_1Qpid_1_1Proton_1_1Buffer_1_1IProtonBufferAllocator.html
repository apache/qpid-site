<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Proton DotNet: Apache.Qpid.Proton.Buffer.IProtonBufferAllocator Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Proton DotNet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceApache.html">Apache</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid.html">Qpid</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Buffer.html">Buffer</a></li><li class="navelem"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html">IProtonBufferAllocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Apache.Qpid.Proton.Buffer.IProtonBufferAllocator Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines the interface for a <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> allocator that can be used by the <a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a> library to allow customization of the buffer types used for IO and application level buffer management.  
 <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Apache.Qpid.Proton.Buffer.IProtonBufferAllocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.png" usemap="#Apache.Qpid.Proton.Buffer.IProtonBufferAllocator_map" alt=""/>
  <map id="Apache.Qpid.Proton.Buffer.IProtonBufferAllocator_map" name="Apache.Qpid.Proton.Buffer.IProtonBufferAllocator_map">
<area href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBufferAllocator.html" title="An buffer allocator instance that creates heap based buffer objects" alt="Apache.Qpid.Proton.Buffer.ProtonByteBufferAllocator" shape="rect" coords="0,56,319,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a62d36704b98b2674f679cdbba7c2ce22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a62d36704b98b2674f679cdbba7c2ce22">OutputBuffer</a> (long initialCapacity)</td></tr>
<tr class="memdesc:a62d36704b98b2674f679cdbba7c2ce22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new output <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with the given initial capacity and the maximum capacity should be that of the underlying buffer implementations limit. The buffer implementation should support growing the buffer on an as needed basis to allow writes without the user needing to code extra capacity and buffer reallocation checks.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a62d36704b98b2674f679cdbba7c2ce22">More...</a><br /></td></tr>
<tr class="separator:a62d36704b98b2674f679cdbba7c2ce22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0e86b8e7e27494de6f0f0140320d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a7e0e86b8e7e27494de6f0f0140320d82">OutputBuffer</a> (long initialCapacity, long maxCapacity)</td></tr>
<tr class="memdesc:a7e0e86b8e7e27494de6f0f0140320d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new output <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with the given initial capacity and the maximum capacity should that of the value specified by the caller.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a7e0e86b8e7e27494de6f0f0140320d82">More...</a><br /></td></tr>
<tr class="separator:a7e0e86b8e7e27494de6f0f0140320d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d22495fe244a3d6db636176d8595b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a63d22495fe244a3d6db636176d8595b8">Allocate</a> ()</td></tr>
<tr class="memdesc:a63d22495fe244a3d6db636176d8595b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with default initial capacity. The buffer implementation should support growing the buffer on an as needed basis to allow writes without the user needing to code extra capacity and buffer reallocation checks.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a63d22495fe244a3d6db636176d8595b8">More...</a><br /></td></tr>
<tr class="separator:a63d22495fe244a3d6db636176d8595b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7689838bb223bc9ba78897ed9942730b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a7689838bb223bc9ba78897ed9942730b">Allocate</a> (long initialCapacity)</td></tr>
<tr class="memdesc:a7689838bb223bc9ba78897ed9942730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with the given initial capacity and the maximum capacity should be that of the underlying buffer implementations limit.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a7689838bb223bc9ba78897ed9942730b">More...</a><br /></td></tr>
<tr class="separator:a7689838bb223bc9ba78897ed9942730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a19f3e5f9d52219274d1d9054cb643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a86a19f3e5f9d52219274d1d9054cb643">Allocate</a> (long initialCapacity, long maxCapacity)</td></tr>
<tr class="memdesc:a86a19f3e5f9d52219274d1d9054cb643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with the given initial capacity and the maximum capacity should that of the value specified by the caller.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a86a19f3e5f9d52219274d1d9054cb643">More...</a><br /></td></tr>
<tr class="separator:a86a19f3e5f9d52219274d1d9054cb643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0951ae9c640e324e91ccf8d15a5091e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a0951ae9c640e324e91ccf8d15a5091e0">Wrap</a> (byte[] array)</td></tr>
<tr class="memdesc:a0951ae9c640e324e91ccf8d15a5091e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> that wraps the given byte array.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a0951ae9c640e324e91ccf8d15a5091e0">More...</a><br /></td></tr>
<tr class="separator:a0951ae9c640e324e91ccf8d15a5091e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c8d2c4996afa79cf0a4f4cc3befbd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a27c8d2c4996afa79cf0a4f4cc3befbd1">Wrap</a> (byte[] array, int offset, int length)</td></tr>
<tr class="memdesc:a27c8d2c4996afa79cf0a4f4cc3befbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> that wraps the given portion of the byte array.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAllocator.html#a27c8d2c4996afa79cf0a4f4cc3befbd1">More...</a><br /></td></tr>
<tr class="separator:a27c8d2c4996afa79cf0a4f4cc3befbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the interface for a <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> allocator that can be used by the <a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a> library to allow customization of the buffer types used for IO and application level buffer management. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a63d22495fe244a3d6db636176d8595b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d22495fe244a3d6db636176d8595b8">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.IProtonBufferAllocator.Allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with default initial capacity. The buffer implementation should support growing the buffer on an as needed basis to allow writes without the user needing to code extra capacity and buffer reallocation checks. </p>
<p>It is not recommended that these buffers be backed by a pooled resource as there is no defined release point within the buffer API and if used by an AMQP engine they could be lost as buffers are copied or aggregated together.</p>
<dl class="section return"><dt>Returns</dt><dd>A new buffer instance that allocates default capacity</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBufferAllocator.html#a871c6ff5f2a1fbf2261650af2b6225f1">Apache.Qpid.Proton.Buffer.ProtonByteBufferAllocator</a>.</p>

</div>
</div>
<a id="a7689838bb223bc9ba78897ed9942730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7689838bb223bc9ba78897ed9942730b">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.IProtonBufferAllocator.Allocate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with the given initial capacity and the maximum capacity should be that of the underlying buffer implementations limit. </p>
<p>It is not recommended that these buffers be backed by a pooled resource as there is no defined release point within the buffer API and if used by an AMQP engine they could be lost as buffers are copied or aggregated together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>The initial capacity to use when creating the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer instance that has the given initial capacity</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBufferAllocator.html#a338d2407915ac06aa4428bd411e4b18e">Apache.Qpid.Proton.Buffer.ProtonByteBufferAllocator</a>.</p>

</div>
</div>
<a id="a86a19f3e5f9d52219274d1d9054cb643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a19f3e5f9d52219274d1d9054cb643">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.IProtonBufferAllocator.Allocate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with the given initial capacity and the maximum capacity should that of the value specified by the caller. </p>
<p>It is not recommended that these buffers be backed by a pooled resource as there is no defined release point within the buffer API and if used by an AMQP engine they could be lost as buffers are copied or aggregated together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>The initial capacity to use when creating the buffer</td></tr>
    <tr><td class="paramname">maxCapacity</td><td>The maximum capacity limit for the newly created buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer instance that has the given initial capacity limits</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBufferAllocator.html#ad46d82a3369704326e7c32bfcce4109f">Apache.Qpid.Proton.Buffer.ProtonByteBufferAllocator</a>.</p>

</div>
</div>
<a id="a62d36704b98b2674f679cdbba7c2ce22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d36704b98b2674f679cdbba7c2ce22">&#9670;&nbsp;</a></span>OutputBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.IProtonBufferAllocator.OutputBuffer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new output <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with the given initial capacity and the maximum capacity should be that of the underlying buffer implementations limit. The buffer implementation should support growing the buffer on an as needed basis to allow writes without the user needing to code extra capacity and buffer reallocation checks. </p>
<p>The returned buffer will be used for frame output from the <a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a> engine and can be a pooled buffer which the IO handler will then need to release once the buffer has been written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>The initial capacity to use when creating the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer instance that has the given initial capacity</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBufferAllocator.html#a87a74b36aed5fd62a247fac59b5996de">Apache.Qpid.Proton.Buffer.ProtonByteBufferAllocator</a>.</p>

</div>
</div>
<a id="a7e0e86b8e7e27494de6f0f0140320d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0e86b8e7e27494de6f0f0140320d82">&#9670;&nbsp;</a></span>OutputBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.IProtonBufferAllocator.OutputBuffer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new output <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> instance with the given initial capacity and the maximum capacity should that of the value specified by the caller. </p>
<p>The returned buffer will be used for frame output from the <a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a> engine and can be a pooled buffer which the IO handler will then need to release once the buffer has been written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>The initial capacity to use when creating the buffer</td></tr>
    <tr><td class="paramname">maxCapacity</td><td>The maximum capacity limit for the newly created buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer instance that has the given initial capacity limits</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBufferAllocator.html#a06ef098347d185b77e9b9fa46b641f48">Apache.Qpid.Proton.Buffer.ProtonByteBufferAllocator</a>.</p>

</div>
</div>
<a id="a0951ae9c640e324e91ccf8d15a5091e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0951ae9c640e324e91ccf8d15a5091e0">&#9670;&nbsp;</a></span>Wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.IProtonBufferAllocator.Wrap </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> that wraps the given byte array. </p>
<p>The capacity and maximum capacity for the resulting ProtonBuffer should equal to the length of the wrapped array and the returned array offset is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The byte array that will be wrapped</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer instance that wraps the given byte array</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBufferAllocator.html#a7a2a6cd931ae5643b64e31f9d6abe823">Apache.Qpid.Proton.Buffer.ProtonByteBufferAllocator</a>.</p>

</div>
</div>
<a id="a27c8d2c4996afa79cf0a4f4cc3befbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c8d2c4996afa79cf0a4f4cc3befbd1">&#9670;&nbsp;</a></span>Wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.IProtonBufferAllocator.Wrap </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> that wraps the given portion of the byte array. </p>
<p>The capacity and maximum capacity for the resulting ProtonBuffer should equal to the length of the wrapped array and the returned array offset is set by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The byte array that will be wrapped</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the byte array where the buffer starts</td></tr>
    <tr><td class="paramname">length</td><td>The length if the view into byte array that is accessible</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer instance that wraps the given byte array</dd></dl>

<p>Implemented in <a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBufferAllocator.html#ad4dc773c693930a1df31712f5e630d0f">Apache.Qpid.Proton.Buffer.ProtonByteBufferAllocator</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>src/Proton/Buffer/IProtonBufferAllocator.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
