<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Proton DotNet: Apache.Qpid.Proton.Buffer.ProtonByteBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Proton DotNet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceApache.html">Apache</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid.html">Qpid</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton.html">Proton</a></li><li class="navelem"><a class="el" href="namespaceApache_1_1Qpid_1_1Proton_1_1Buffer.html">Buffer</a></li><li class="navelem"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html">ProtonByteBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Apache.Qpid.Proton.Buffer.ProtonByteBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A proton buffer implementation that wraps a single heap allocated byte array and provides read and write operations on that array along with self resizing based on capacity limits.  
 <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Apache.Qpid.Proton.Buffer.ProtonByteBuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.png" usemap="#Apache.Qpid.Proton.Buffer.ProtonByteBuffer_map" alt=""/>
  <map id="Apache.Qpid.Proton.Buffer.ProtonByteBuffer_map" name="Apache.Qpid.Proton.Buffer.ProtonByteBuffer_map">
<area href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html" alt="Apache.Qpid.Proton.Buffer.IProtonBuffer" shape="rect" coords="474,56,780,80"/>
<area href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html" title="Provides a view of an individual component of a proton buffer during a call to the readable buffer pr..." alt="Apache.Qpid.Proton.Buffer.IReadableComponent" shape="rect" coords="790,56,1096,80"/>
<area href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html" alt="Apache.Qpid.Proton.Buffer.IWritableComponent" shape="rect" coords="1106,56,1412,80"/>
<area href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html" title="Interface for proton buffer primitive type accessors that can be used with custom types to extend or ..." alt="Apache.Qpid.Proton.Buffer.IProtonBufferAccessors" shape="rect" coords="948,0,1254,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a65ad1db3f8f2961d08e78d1f61f1634a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a65ad1db3f8f2961d08e78d1f61f1634a">ProtonByteBuffer</a> ()</td></tr>
<tr class="memdesc:a65ad1db3f8f2961d08e78d1f61f1634a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new proton byte buffer instance with default initial capacity and limited only by the size of a byte array in max capacity.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a65ad1db3f8f2961d08e78d1f61f1634a">More...</a><br /></td></tr>
<tr class="separator:a65ad1db3f8f2961d08e78d1f61f1634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db9f627a1057ea0f3eaddd58e543bf9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a5db9f627a1057ea0f3eaddd58e543bf9">ProtonByteBuffer</a> (long initialCapacity)</td></tr>
<tr class="memdesc:a5db9f627a1057ea0f3eaddd58e543bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new proton byte buffer instance with given initial capacity and limited only by the size of a byte array in max capacity.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a5db9f627a1057ea0f3eaddd58e543bf9">More...</a><br /></td></tr>
<tr class="separator:a5db9f627a1057ea0f3eaddd58e543bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eb40171cf802ce065073357ef280b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a18eb40171cf802ce065073357ef280b6">ProtonByteBuffer</a> (long initialCapacity, long maxCapacity)</td></tr>
<tr class="memdesc:a18eb40171cf802ce065073357ef280b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new proton byte buffer instance with given initial capacity and limited to a max capacity of the given amount.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a18eb40171cf802ce065073357ef280b6">More...</a><br /></td></tr>
<tr class="separator:a18eb40171cf802ce065073357ef280b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1cd7281bad0eda042f80e99981ba23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a2d1cd7281bad0eda042f80e99981ba23">ProtonByteBuffer</a> (byte[] backingArray)</td></tr>
<tr class="memdesc:a2d1cd7281bad0eda042f80e99981ba23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new proton byte buffer instance with given backing array whose size determines that largest the buffer can ever be.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a2d1cd7281bad0eda042f80e99981ba23">More...</a><br /></td></tr>
<tr class="separator:a2d1cd7281bad0eda042f80e99981ba23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9fde69201aeabc0c718762ba2303b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#abf9fde69201aeabc0c718762ba2303b0">ProtonByteBuffer</a> (byte[] backingArray, long maxCapacity)</td></tr>
<tr class="memdesc:abf9fde69201aeabc0c718762ba2303b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new proton byte buffer instance with given backing array as the starting backing store and uses the provided max capacity value to control how large the buffer could ever grow.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#abf9fde69201aeabc0c718762ba2303b0">More...</a><br /></td></tr>
<tr class="separator:abf9fde69201aeabc0c718762ba2303b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa512148d8402aa14cebd5aeb87e9ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a7aa512148d8402aa14cebd5aeb87e9ba">ProtonByteBuffer</a> (byte[] backingArray, int arrayOffset, long maxCapacity)</td></tr>
<tr class="memdesc:a7aa512148d8402aa14cebd5aeb87e9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new proton byte buffer instance with given backing array as the starting backing store and uses the provided max capacity value to control how large the buffer could ever grow.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a7aa512148d8402aa14cebd5aeb87e9ba">More...</a><br /></td></tr>
<tr class="separator:a7aa512148d8402aa14cebd5aeb87e9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecbd629f6a3154b34df50f5b432bcb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a7ecbd629f6a3154b34df50f5b432bcb6">ProtonByteBuffer</a> (byte[] backingArray, int arrayOffset, int capacity, long maxCapacity)</td></tr>
<tr class="memdesc:a7ecbd629f6a3154b34df50f5b432bcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new proton byte buffer instance with given backing array as the starting backing store and uses the provided max capacity value to control how large the buffer could ever grow.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a7ecbd629f6a3154b34df50f5b432bcb6">More...</a><br /></td></tr>
<tr class="separator:a7ecbd629f6a3154b34df50f5b432bcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af585e151af64dbbd27bc12392968b444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#af585e151af64dbbd27bc12392968b444">EnsureWritable</a> (long amount)</td></tr>
<tr class="memdesc:af585e151af64dbbd27bc12392968b444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the buffer ensure that there is enough allocated internal capacity such that the given number of bytes can be written without requiring additional allocations and that this amount does not exceed any total capacity restrictions for this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#af585e151af64dbbd27bc12392968b444">More...</a><br /></td></tr>
<tr class="separator:af585e151af64dbbd27bc12392968b444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce2d129a3a8f70234ac3baee3e1b7fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a1ce2d129a3a8f70234ac3baee3e1b7fc">Compact</a> ()</td></tr>
<tr class="memdesc:a1ce2d129a3a8f70234ac3baee3e1b7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards the read bytes, and moves the buffer contents to the beginning of the buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a1ce2d129a3a8f70234ac3baee3e1b7fc">More...</a><br /></td></tr>
<tr class="separator:a1ce2d129a3a8f70234ac3baee3e1b7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fedd3d38837f8ee145db4eb9008a43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0fedd3d38837f8ee145db4eb9008a43f">Reclaim</a> ()</td></tr>
<tr class="memdesc:a0fedd3d38837f8ee145db4eb9008a43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reclaims read buffer space and returns it to the operating system or other pooling mechanisms if those are in place, then compacts the remaining buffer contents. For a non-composite buffer this operation could consist of allocating a smaller buffer to house any remaining unread bytes and freeing the larger backing buffer in some cases or it may result in a no-op depending on the buffer implementation. For the composite buffer case this operation provides an API which allows for fully read buffer constituents to be released and returned to a memory pool or back to the O/S.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0fedd3d38837f8ee145db4eb9008a43f">More...</a><br /></td></tr>
<tr class="separator:a0fedd3d38837f8ee145db4eb9008a43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f81737b7f69d70ea245c4891d02cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a30f81737b7f69d70ea245c4891d02cb6">WriteSplit</a> (long offset)</td></tr>
<tr class="memdesc:a30f81737b7f69d70ea245c4891d02cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the buffer into two distinct buffers at the given index plus the current write offset. The returned buffer will retain the read offset and write offset of this buffer but will be truncated to match the capacity provided by the split index, which implies that they might both be set to the capacity if they were previously set to the split index. The returned buffer will set its read and write offsets to zero if they fell prior to the given index otherwise they will be truncated to match the new buffer capacity. Split buffers support the standard buffer operations including resizing to ensure writable regions which implies that a buffer resize on either will cause them to no longer reference the same underlying memory region. If buffer implementations implement pooling then they must ensure proper release of shared buffer regions once both buffers no longer reference them.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a30f81737b7f69d70ea245c4891d02cb6">More...</a><br /></td></tr>
<tr class="separator:a30f81737b7f69d70ea245c4891d02cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0777c671a3a2e609f776c878d636e692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0777c671a3a2e609f776c878d636e692">ReadSplit</a> (long offset)</td></tr>
<tr class="memdesc:a0777c671a3a2e609f776c878d636e692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the buffer into two distinct buffers at the given index plus the current read offset. The returned buffer will retain the read offset and write offset of this buffer but will be truncated to match the capacity provided by the split index, which implies that they might both be set to the capacity if they were previously set beyond the split index. The returned buffer will set its read and write offsets to zero if they fell prior to the given index otherwise they will be truncated to match the new buffer capacity. Split buffers support the standard buffer operations including resizing to ensure writable regions which implies that a buffer resize on either will cause them to no longer reference the same underlying memory region. If buffer implementations implement pooling then they must ensure proper release of shared buffer regions once both buffers no longer reference them.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0777c671a3a2e609f776c878d636e692">More...</a><br /></td></tr>
<tr class="separator:a0777c671a3a2e609f776c878d636e692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e17b377b794582bd89c28f23050d244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a7e17b377b794582bd89c28f23050d244">Split</a> ()</td></tr>
<tr class="memdesc:a7e17b377b794582bd89c28f23050d244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the buffer into two buffers at the write offset. The resulting buffer will comprise the read and readable portions of this buffer with the write offset and capacity set to the current write offset. This buffer will lose access to the split region and its read offset will be set to the current write offset. This buffer will also have its capacity reduced by the number of bytes in the returned buffer (i.e. the current number of read and readable bytes). Split buffers support the standard buffer operations including resizing to ensure writable regions which implies that a buffer resize on either will cause them to no longer reference the same underlying memory region. If buffer implementations implement pooling then they must ensure proper release of shared buffer regions once both buffers no longer reference them.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a7e17b377b794582bd89c28f23050d244">More...</a><br /></td></tr>
<tr class="separator:a7e17b377b794582bd89c28f23050d244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a2fb56b8f514d3f344b15ba7cd8b35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a86a2fb56b8f514d3f344b15ba7cd8b35">Split</a> (long offset)</td></tr>
<tr class="memdesc:a86a2fb56b8f514d3f344b15ba7cd8b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the buffer into two distinct buffers at the given index. The returned buffer will retain the read offset and write offset of this buffer but will be truncated to match the capacity provided by the split index, which implies that they might both be set to the capacity if they were previously set beyond the split index. The returned buffer will set its read and write offsets to zero if they fell prior to the given index otherwise they will be truncated to match the new buffer capacity. Split buffers support the standard buffer operations including resizing to ensure writable regions which implies that a buffer resize on either will cause them to no longer reference the same underlying memory region. If buffer implementations implement pooling then they must ensure proper release of shared buffer regions once both buffers no longer reference them.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a86a2fb56b8f514d3f344b15ba7cd8b35">More...</a><br /></td></tr>
<tr class="separator:a86a2fb56b8f514d3f344b15ba7cd8b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2e65e4110eae90c776bedad536937d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aca2e65e4110eae90c776bedad536937d">Reset</a> ()</td></tr>
<tr class="memdesc:aca2e65e4110eae90c776bedad536937d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the read and write offset values to zero.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aca2e65e4110eae90c776bedad536937d">More...</a><br /></td></tr>
<tr class="separator:aca2e65e4110eae90c776bedad536937d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c79e2076cb29946d99862f0cc090aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a4c79e2076cb29946d99862f0cc090aaf">SkipBytes</a> (long amount)</td></tr>
<tr class="memdesc:a4c79e2076cb29946d99862f0cc090aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the buffer read offset by the specified amount effectively skipping that number of bytes from being read.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a4c79e2076cb29946d99862f0cc090aaf">More...</a><br /></td></tr>
<tr class="separator:a4c79e2076cb29946d99862f0cc090aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6703a4dfd0feb26176b024bd783728b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae6703a4dfd0feb26176b024bd783728b">Fill</a> (byte value)</td></tr>
<tr class="memdesc:ae6703a4dfd0feb26176b024bd783728b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the buffer with the given byte value. This method does not respect the read offset nor the write offset but instead fills the entire backing buffer memory with the given value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae6703a4dfd0feb26176b024bd783728b">More...</a><br /></td></tr>
<tr class="separator:ae6703a4dfd0feb26176b024bd783728b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb648d1178b150897ae3df5fcba622d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aeb648d1178b150897ae3df5fcba622d2">Copy</a> ()</td></tr>
<tr class="memdesc:aeb648d1178b150897ae3df5fcba622d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of this buffer's readable bytes. Modifying the content of the returned buffer will not affect this buffers contents. The two buffers will maintain separate offsets. The returned copy has the write offset set to the length of the copy meaning that the entire copied region is read for reading.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aeb648d1178b150897ae3df5fcba622d2">More...</a><br /></td></tr>
<tr class="separator:aeb648d1178b150897ae3df5fcba622d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4344c52b553c334bdeddadc9184a2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae4344c52b553c334bdeddadc9184a2db">Copy</a> (long index, long length)</td></tr>
<tr class="memdesc:ae4344c52b553c334bdeddadc9184a2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of this buffer's readable bytes. Modifying the content of the returned buffer will not affect this buffers contents. The two buffers will maintain separate offsets. The amount and start of the data to be copied is provided by the index and length arguments. The returned copy has the write offset set to the length of the copy meaning that the entire copied region is read for reading.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae4344c52b553c334bdeddadc9184a2db">More...</a><br /></td></tr>
<tr class="separator:ae4344c52b553c334bdeddadc9184a2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a389b7d72771d5ab10fce435bbd5d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a83a389b7d72771d5ab10fce435bbd5d8">CopyInto</a> (long srcPos, byte[] dest, long destPos, long length)</td></tr>
<tr class="memdesc:a83a389b7d72771d5ab10fce435bbd5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given number of bytes from this buffer into the target byte buffer starting the read from the given position in this buffer and the write to at the given position in the destination buffer. The length parameter controls how many bytes are copied to the destination. This method does not modify the read or write offset values in this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a83a389b7d72771d5ab10fce435bbd5d8">More...</a><br /></td></tr>
<tr class="separator:a83a389b7d72771d5ab10fce435bbd5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93a87e59b3d210408beb081dbb0d0b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae93a87e59b3d210408beb081dbb0d0b9">CopyInto</a> (long srcPos, <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> dest, long destPos, long length)</td></tr>
<tr class="memdesc:ae93a87e59b3d210408beb081dbb0d0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given number of bytes from this buffer into the target byte buffer starting the read from the given position in this buffer and the write to at the given position in the destination buffer. The length parameter controls how many bytes are copied to the destination. This method does not modify the read or write offset values in this buffer nor those of the destination buffer. The destination write index is an absolute index value unrelated to the write offset of the target.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae93a87e59b3d210408beb081dbb0d0b9">More...</a><br /></td></tr>
<tr class="separator:ae93a87e59b3d210408beb081dbb0d0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b72990fd9cd1ac2fdb7df30649ff412"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a4b72990fd9cd1ac2fdb7df30649ff412">ForEachReadableComponent</a> (in int index, in Func&lt; int, <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html">IReadableComponent</a>, bool &gt; processor)</td></tr>
<tr class="memdesc:a4b72990fd9cd1ac2fdb7df30649ff412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the provided delegate for each readable component in this buffer and increments the provided index value for each invocation. The total number of buffers processed is returned to the caller. The delegate can stop processing at any time by returning false in which case this method will stop and return a negative value to indicate that processing stopped early and did not traverse all available components.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a4b72990fd9cd1ac2fdb7df30649ff412">More...</a><br /></td></tr>
<tr class="separator:a4b72990fd9cd1ac2fdb7df30649ff412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb7a1bddaaf6cca84ca07f53e792816"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0bb7a1bddaaf6cca84ca07f53e792816">ForEachWritableComponent</a> (in int index, in Func&lt; int, <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html">IWritableComponent</a>, bool &gt; processor)</td></tr>
<tr class="memdesc:a0bb7a1bddaaf6cca84ca07f53e792816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the provided delegate for each writable component in this buffer and increments the provided index value for each invocation. The total number of buffers processed is returned to the caller. The delegate can stop processing at any time by returning false in which case this method will stop and return a negative value to indicate that processing stopped early and did not traverse all available components.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0bb7a1bddaaf6cca84ca07f53e792816">More...</a><br /></td></tr>
<tr class="separator:a0bb7a1bddaaf6cca84ca07f53e792816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6959792ad296d7e94a03ba832704dd88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a6959792ad296d7e94a03ba832704dd88">GetBoolean</a> (long index)</td></tr>
<tr class="memdesc:a6959792ad296d7e94a03ba832704dd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single byte from the given index and returns a boolean value indicating if the byte was zero (false) or greater than zero (true).  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a6959792ad296d7e94a03ba832704dd88">More...</a><br /></td></tr>
<tr class="separator:a6959792ad296d7e94a03ba832704dd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec125ee5b15dbe988a60d0c77c323dd1"><td class="memItemLeft" align="right" valign="top">sbyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aec125ee5b15dbe988a60d0c77c323dd1">GetByte</a> (long index)</td></tr>
<tr class="memdesc:aec125ee5b15dbe988a60d0c77c323dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single signed byte from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aec125ee5b15dbe988a60d0c77c323dd1">More...</a><br /></td></tr>
<tr class="separator:aec125ee5b15dbe988a60d0c77c323dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81fcb30b1c6855a9c210f9f41b373c8"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ab81fcb30b1c6855a9c210f9f41b373c8">GetChar</a> (long index)</td></tr>
<tr class="memdesc:ab81fcb30b1c6855a9c210f9f41b373c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 2 byte char from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ab81fcb30b1c6855a9c210f9f41b373c8">More...</a><br /></td></tr>
<tr class="separator:ab81fcb30b1c6855a9c210f9f41b373c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac017287110276c3dfa48ec92173f1e29"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ac017287110276c3dfa48ec92173f1e29">GetDouble</a> (long index)</td></tr>
<tr class="memdesc:ac017287110276c3dfa48ec92173f1e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 8 byte double from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ac017287110276c3dfa48ec92173f1e29">More...</a><br /></td></tr>
<tr class="separator:ac017287110276c3dfa48ec92173f1e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab79535e1ef0262256c88e14785fbc45"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aab79535e1ef0262256c88e14785fbc45">GetFloat</a> (long index)</td></tr>
<tr class="memdesc:aab79535e1ef0262256c88e14785fbc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 4 byte float from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aab79535e1ef0262256c88e14785fbc45">More...</a><br /></td></tr>
<tr class="separator:aab79535e1ef0262256c88e14785fbc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35747aa5f68a63c224381c3c7ea3d850"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a35747aa5f68a63c224381c3c7ea3d850">GetInt</a> (long index)</td></tr>
<tr class="memdesc:a35747aa5f68a63c224381c3c7ea3d850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 4 byte int from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a35747aa5f68a63c224381c3c7ea3d850">More...</a><br /></td></tr>
<tr class="separator:a35747aa5f68a63c224381c3c7ea3d850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82edf32567d7ad98b865624bfc88209e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a82edf32567d7ad98b865624bfc88209e">GetLong</a> (long index)</td></tr>
<tr class="memdesc:a82edf32567d7ad98b865624bfc88209e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 8 byte long from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a82edf32567d7ad98b865624bfc88209e">More...</a><br /></td></tr>
<tr class="separator:a82edf32567d7ad98b865624bfc88209e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee6c04b55ad47912b693f156bffec74"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aaee6c04b55ad47912b693f156bffec74">GetShort</a> (long index)</td></tr>
<tr class="memdesc:aaee6c04b55ad47912b693f156bffec74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 2 byte short from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aaee6c04b55ad47912b693f156bffec74">More...</a><br /></td></tr>
<tr class="separator:aaee6c04b55ad47912b693f156bffec74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1d22a7b1fee3b18866d1511c720aeb"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0a1d22a7b1fee3b18866d1511c720aeb">GetUnsignedByte</a> (long index)</td></tr>
<tr class="memdesc:a0a1d22a7b1fee3b18866d1511c720aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single unsigned byte from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0a1d22a7b1fee3b18866d1511c720aeb">More...</a><br /></td></tr>
<tr class="separator:a0a1d22a7b1fee3b18866d1511c720aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec3aa2e1c9d68993fb6159c1d536a17"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a7ec3aa2e1c9d68993fb6159c1d536a17">GetUnsignedInt</a> (long index)</td></tr>
<tr class="memdesc:a7ec3aa2e1c9d68993fb6159c1d536a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 4 byte unsigned int from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a7ec3aa2e1c9d68993fb6159c1d536a17">More...</a><br /></td></tr>
<tr class="separator:a7ec3aa2e1c9d68993fb6159c1d536a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4e6c6bf38fdb0ff159b4ff377332b5"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a9a4e6c6bf38fdb0ff159b4ff377332b5">GetUnsignedLong</a> (long index)</td></tr>
<tr class="memdesc:a9a4e6c6bf38fdb0ff159b4ff377332b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 8 byte unsigned long from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a9a4e6c6bf38fdb0ff159b4ff377332b5">More...</a><br /></td></tr>
<tr class="separator:a9a4e6c6bf38fdb0ff159b4ff377332b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684ba0bd453e055478ce15fc35caa53c"><td class="memItemLeft" align="right" valign="top">ushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a684ba0bd453e055478ce15fc35caa53c">GetUnsignedShort</a> (long index)</td></tr>
<tr class="memdesc:a684ba0bd453e055478ce15fc35caa53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single 2 byte unsigned short from the given index and returns it.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a684ba0bd453e055478ce15fc35caa53c">More...</a><br /></td></tr>
<tr class="separator:a684ba0bd453e055478ce15fc35caa53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c93f813e800a586108f2f4668ea4054"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a8c93f813e800a586108f2f4668ea4054">ReadBoolean</a> ()</td></tr>
<tr class="memdesc:a8c93f813e800a586108f2f4668ea4054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next byte from the buffer and returns the boolean value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a8c93f813e800a586108f2f4668ea4054">More...</a><br /></td></tr>
<tr class="separator:a8c93f813e800a586108f2f4668ea4054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58124e1191b4fdc1a452b9b77111e9d5"><td class="memItemLeft" align="right" valign="top">sbyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a58124e1191b4fdc1a452b9b77111e9d5">ReadByte</a> ()</td></tr>
<tr class="memdesc:a58124e1191b4fdc1a452b9b77111e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a signed byte from the buffer and advance the read offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a58124e1191b4fdc1a452b9b77111e9d5">More...</a><br /></td></tr>
<tr class="separator:a58124e1191b4fdc1a452b9b77111e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd392778267a9a910b8da127faeb29bf"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#afd392778267a9a910b8da127faeb29bf">ReadChar</a> ()</td></tr>
<tr class="memdesc:afd392778267a9a910b8da127faeb29bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the two bytes from the buffer and returns the char value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#afd392778267a9a910b8da127faeb29bf">More...</a><br /></td></tr>
<tr class="separator:afd392778267a9a910b8da127faeb29bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb51fc67443963eb12a31b8b32a21802"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#abb51fc67443963eb12a31b8b32a21802">ReadDouble</a> ()</td></tr>
<tr class="memdesc:abb51fc67443963eb12a31b8b32a21802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next eight bytes from the buffer and returns the double value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#abb51fc67443963eb12a31b8b32a21802">More...</a><br /></td></tr>
<tr class="separator:abb51fc67443963eb12a31b8b32a21802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e4e46c6aa627639342f6de5a5c0ff4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a90e4e46c6aa627639342f6de5a5c0ff4">ReadFloat</a> ()</td></tr>
<tr class="memdesc:a90e4e46c6aa627639342f6de5a5c0ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next four bytes from the buffer and returns the float value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a90e4e46c6aa627639342f6de5a5c0ff4">More...</a><br /></td></tr>
<tr class="separator:a90e4e46c6aa627639342f6de5a5c0ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3f5c9f13e68cd04bfe3bbc694357c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a1a3f5c9f13e68cd04bfe3bbc694357c1">ReadInt</a> ()</td></tr>
<tr class="memdesc:a1a3f5c9f13e68cd04bfe3bbc694357c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next four bytes from the buffer and returns the int value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a1a3f5c9f13e68cd04bfe3bbc694357c1">More...</a><br /></td></tr>
<tr class="separator:a1a3f5c9f13e68cd04bfe3bbc694357c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce6dc54010df7685e77165f77f89e03"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#afce6dc54010df7685e77165f77f89e03">ReadLong</a> ()</td></tr>
<tr class="memdesc:afce6dc54010df7685e77165f77f89e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next eight bytes from the buffer and returns the long value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#afce6dc54010df7685e77165f77f89e03">More...</a><br /></td></tr>
<tr class="separator:afce6dc54010df7685e77165f77f89e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eae51338a30c697ba93b51810d07a88"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a4eae51338a30c697ba93b51810d07a88">ReadShort</a> ()</td></tr>
<tr class="memdesc:a4eae51338a30c697ba93b51810d07a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next two bytes from the buffer and returns the short value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a4eae51338a30c697ba93b51810d07a88">More...</a><br /></td></tr>
<tr class="separator:a4eae51338a30c697ba93b51810d07a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af816e6a26a3c78cdee9c91d3d51c560f"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#af816e6a26a3c78cdee9c91d3d51c560f">ReadUnsignedByte</a> ()</td></tr>
<tr class="memdesc:af816e6a26a3c78cdee9c91d3d51c560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a unsigned byte from the buffer and advance the read offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#af816e6a26a3c78cdee9c91d3d51c560f">More...</a><br /></td></tr>
<tr class="separator:af816e6a26a3c78cdee9c91d3d51c560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972e3168af8d5c1000a526282b07005d"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a972e3168af8d5c1000a526282b07005d">ReadUnsignedInt</a> ()</td></tr>
<tr class="memdesc:a972e3168af8d5c1000a526282b07005d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next four bytes from the buffer and returns the unsigned int value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a972e3168af8d5c1000a526282b07005d">More...</a><br /></td></tr>
<tr class="separator:a972e3168af8d5c1000a526282b07005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e28044a03a52d1781fe82268b925d98"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a1e28044a03a52d1781fe82268b925d98">ReadUnsignedLong</a> ()</td></tr>
<tr class="memdesc:a1e28044a03a52d1781fe82268b925d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next eight bytes from the buffer and returns the unsigned long value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a1e28044a03a52d1781fe82268b925d98">More...</a><br /></td></tr>
<tr class="separator:a1e28044a03a52d1781fe82268b925d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c2f77dc78b5160e9da1067db0ab512"><td class="memItemLeft" align="right" valign="top">ushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#af5c2f77dc78b5160e9da1067db0ab512">ReadUnsignedShort</a> ()</td></tr>
<tr class="memdesc:af5c2f77dc78b5160e9da1067db0ab512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next two bytes from the buffer and returns the unsigned short value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#af5c2f77dc78b5160e9da1067db0ab512">More...</a><br /></td></tr>
<tr class="separator:af5c2f77dc78b5160e9da1067db0ab512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea479cc7f3e02204fb9caaad8382914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a6ea479cc7f3e02204fb9caaad8382914">SetBoolean</a> (long index, bool value)</td></tr>
<tr class="memdesc:a6ea479cc7f3e02204fb9caaad8382914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given boolean value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a6ea479cc7f3e02204fb9caaad8382914">More...</a><br /></td></tr>
<tr class="separator:a6ea479cc7f3e02204fb9caaad8382914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ec03f8c5776c26da4c50affa205a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a07ec03f8c5776c26da4c50affa205a68">SetByte</a> (long index, sbyte value)</td></tr>
<tr class="memdesc:a07ec03f8c5776c26da4c50affa205a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given byte value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a07ec03f8c5776c26da4c50affa205a68">More...</a><br /></td></tr>
<tr class="separator:a07ec03f8c5776c26da4c50affa205a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bdaf52536adba4cf4b2bbffea80d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a10bdaf52536adba4cf4b2bbffea80d0e">SetChar</a> (long index, char value)</td></tr>
<tr class="memdesc:a10bdaf52536adba4cf4b2bbffea80d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 2 byte char value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a10bdaf52536adba4cf4b2bbffea80d0e">More...</a><br /></td></tr>
<tr class="separator:a10bdaf52536adba4cf4b2bbffea80d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b629b5c346c7e831c8062e11a6036df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a3b629b5c346c7e831c8062e11a6036df">SetDouble</a> (long index, double value)</td></tr>
<tr class="memdesc:a3b629b5c346c7e831c8062e11a6036df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 8 byte double value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a3b629b5c346c7e831c8062e11a6036df">More...</a><br /></td></tr>
<tr class="separator:a3b629b5c346c7e831c8062e11a6036df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb40ca4f7433a3269966bce55e2e499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aeeb40ca4f7433a3269966bce55e2e499">SetFloat</a> (long index, float value)</td></tr>
<tr class="memdesc:aeeb40ca4f7433a3269966bce55e2e499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 4 byte float value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aeeb40ca4f7433a3269966bce55e2e499">More...</a><br /></td></tr>
<tr class="separator:aeeb40ca4f7433a3269966bce55e2e499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecf46601630cd5961bc20cf0fec6b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#abecf46601630cd5961bc20cf0fec6b66">SetInt</a> (long index, int value)</td></tr>
<tr class="memdesc:abecf46601630cd5961bc20cf0fec6b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 4 byte int value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#abecf46601630cd5961bc20cf0fec6b66">More...</a><br /></td></tr>
<tr class="separator:abecf46601630cd5961bc20cf0fec6b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae079f5dafe627ca44c4234ae256c6b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae079f5dafe627ca44c4234ae256c6b46">SetLong</a> (long index, long value)</td></tr>
<tr class="memdesc:ae079f5dafe627ca44c4234ae256c6b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 8 byte long value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae079f5dafe627ca44c4234ae256c6b46">More...</a><br /></td></tr>
<tr class="separator:ae079f5dafe627ca44c4234ae256c6b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7dc84c78eb0d470fadb9982b6d3e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#add7dc84c78eb0d470fadb9982b6d3e99">SetShort</a> (long index, short value)</td></tr>
<tr class="memdesc:add7dc84c78eb0d470fadb9982b6d3e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 2 byte short value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#add7dc84c78eb0d470fadb9982b6d3e99">More...</a><br /></td></tr>
<tr class="separator:add7dc84c78eb0d470fadb9982b6d3e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88ebcfa36425434adbf3f5489ae28aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae88ebcfa36425434adbf3f5489ae28aa">SetUnsignedByte</a> (long index, byte value)</td></tr>
<tr class="memdesc:ae88ebcfa36425434adbf3f5489ae28aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given unsigned byte value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#ae88ebcfa36425434adbf3f5489ae28aa">More...</a><br /></td></tr>
<tr class="separator:ae88ebcfa36425434adbf3f5489ae28aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559fc4b47ef1954fa05645be52f236c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a559fc4b47ef1954fa05645be52f236c2">SetUnsignedInt</a> (long index, uint value)</td></tr>
<tr class="memdesc:a559fc4b47ef1954fa05645be52f236c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 4 byte unsigned int value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a559fc4b47ef1954fa05645be52f236c2">More...</a><br /></td></tr>
<tr class="separator:a559fc4b47ef1954fa05645be52f236c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8130d870e8b836801483b991961c3584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a8130d870e8b836801483b991961c3584">SetUnsignedLong</a> (long index, ulong value)</td></tr>
<tr class="memdesc:a8130d870e8b836801483b991961c3584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 8 byte unsigned long value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a8130d870e8b836801483b991961c3584">More...</a><br /></td></tr>
<tr class="separator:a8130d870e8b836801483b991961c3584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0dc07d9e076246d583bd92f1cb1a1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a3a0dc07d9e076246d583bd92f1cb1a1f">SetUnsignedShort</a> (long index, ushort value)</td></tr>
<tr class="memdesc:a3a0dc07d9e076246d583bd92f1cb1a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given 2 byte unsigned short value at the given location in the buffer backing store without modifying the write offset of this buffer.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a3a0dc07d9e076246d583bd92f1cb1a1f">More...</a><br /></td></tr>
<tr class="separator:a3a0dc07d9e076246d583bd92f1cb1a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0509ec19ca7ab24ec30df5ab1a88633c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0509ec19ca7ab24ec30df5ab1a88633c">WriteBoolean</a> (bool value)</td></tr>
<tr class="memdesc:a0509ec19ca7ab24ec30df5ab1a88633c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given boolean value into this buffer as a single byte and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0509ec19ca7ab24ec30df5ab1a88633c">More...</a><br /></td></tr>
<tr class="separator:a0509ec19ca7ab24ec30df5ab1a88633c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0671fd9b076da2c29f82b230f13f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a2d0671fd9b076da2c29f82b230f13f77">WriteByte</a> (sbyte value)</td></tr>
<tr class="memdesc:a2d0671fd9b076da2c29f82b230f13f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given byte value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a2d0671fd9b076da2c29f82b230f13f77">More...</a><br /></td></tr>
<tr class="separator:a2d0671fd9b076da2c29f82b230f13f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa418ee9e87e78667642a204ffd7a38fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aa418ee9e87e78667642a204ffd7a38fd">WriteDouble</a> (double value)</td></tr>
<tr class="memdesc:aa418ee9e87e78667642a204ffd7a38fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given eight byte double value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aa418ee9e87e78667642a204ffd7a38fd">More...</a><br /></td></tr>
<tr class="separator:aa418ee9e87e78667642a204ffd7a38fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8f280e4eea0593bb3a2cd8a00b3306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a6c8f280e4eea0593bb3a2cd8a00b3306">WriteFloat</a> (float value)</td></tr>
<tr class="memdesc:a6c8f280e4eea0593bb3a2cd8a00b3306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given four byte float value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a6c8f280e4eea0593bb3a2cd8a00b3306">More...</a><br /></td></tr>
<tr class="separator:a6c8f280e4eea0593bb3a2cd8a00b3306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884a8c379817beee6a4d29767a57155a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a884a8c379817beee6a4d29767a57155a">WriteInt</a> (int value)</td></tr>
<tr class="memdesc:a884a8c379817beee6a4d29767a57155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given four byte int value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a884a8c379817beee6a4d29767a57155a">More...</a><br /></td></tr>
<tr class="separator:a884a8c379817beee6a4d29767a57155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cac7c7f15c826afe91ea341ba308a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a8cac7c7f15c826afe91ea341ba308a0d">WriteLong</a> (long value)</td></tr>
<tr class="memdesc:a8cac7c7f15c826afe91ea341ba308a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given eight byte long value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a8cac7c7f15c826afe91ea341ba308a0d">More...</a><br /></td></tr>
<tr class="separator:a8cac7c7f15c826afe91ea341ba308a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeca8acebc57bca3ef57cce879dca21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#afeca8acebc57bca3ef57cce879dca21b">WriteShort</a> (short value)</td></tr>
<tr class="memdesc:afeca8acebc57bca3ef57cce879dca21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given two byte short value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#afeca8acebc57bca3ef57cce879dca21b">More...</a><br /></td></tr>
<tr class="separator:afeca8acebc57bca3ef57cce879dca21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d47f5f016a39ca946337281aacc8b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a82d47f5f016a39ca946337281aacc8b5">WriteUnsignedByte</a> (byte value)</td></tr>
<tr class="memdesc:a82d47f5f016a39ca946337281aacc8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given unsigned byte value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a82d47f5f016a39ca946337281aacc8b5">More...</a><br /></td></tr>
<tr class="separator:a82d47f5f016a39ca946337281aacc8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b00b322e7e5da7b4e07950810c971c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a3b00b322e7e5da7b4e07950810c971c5">WriteUnsignedInt</a> (uint value)</td></tr>
<tr class="memdesc:a3b00b322e7e5da7b4e07950810c971c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given four byte unsigned int value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a3b00b322e7e5da7b4e07950810c971c5">More...</a><br /></td></tr>
<tr class="separator:a3b00b322e7e5da7b4e07950810c971c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252059fc6762deab29eb738482e3ead7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a252059fc6762deab29eb738482e3ead7">WriteUnsignedLong</a> (ulong value)</td></tr>
<tr class="memdesc:a252059fc6762deab29eb738482e3ead7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given eight byte unsigned long value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a252059fc6762deab29eb738482e3ead7">More...</a><br /></td></tr>
<tr class="separator:a252059fc6762deab29eb738482e3ead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de34f33f22b7d58c02454122e89f3bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a6de34f33f22b7d58c02454122e89f3bb">WriteUnsignedShort</a> (ushort value)</td></tr>
<tr class="memdesc:a6de34f33f22b7d58c02454122e89f3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given two byte unsigned short value into this buffer and increases the write offset.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a6de34f33f22b7d58c02454122e89f3bb">More...</a><br /></td></tr>
<tr class="separator:a6de34f33f22b7d58c02454122e89f3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcc44ff17631451a9ea12881a2993b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aabcc44ff17631451a9ea12881a2993b0">WriteBytes</a> (byte[] source)</td></tr>
<tr class="memdesc:aabcc44ff17631451a9ea12881a2993b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of the given byte array into this buffer and advances the write offset by the number of bytes written.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aabcc44ff17631451a9ea12881a2993b0">More...</a><br /></td></tr>
<tr class="separator:aabcc44ff17631451a9ea12881a2993b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4209bf559eda9c806e156e053f18b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0c4209bf559eda9c806e156e053f18b7">WriteBytes</a> (byte[] source, long offset, long length)</td></tr>
<tr class="memdesc:a0c4209bf559eda9c806e156e053f18b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of the given byte array into this buffer and advances the write offset by the number of bytes written.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a0c4209bf559eda9c806e156e053f18b7">More...</a><br /></td></tr>
<tr class="separator:a0c4209bf559eda9c806e156e053f18b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e2b4738009ba86f7760e05cdc0639d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a49e2b4738009ba86f7760e05cdc0639d">WriteBytes</a> (<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> source)</td></tr>
<tr class="memdesc:a49e2b4738009ba86f7760e05cdc0639d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers the bytes from the source buffer to this buffer starting at the current write offset and continues until the source buffer becomes unreadable. The write index of this buffer is increased by the number of bytes read from the source. The method also increases the read offset of the source by the same amount as was written.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a49e2b4738009ba86f7760e05cdc0639d">More...</a><br /></td></tr>
<tr class="separator:a49e2b4738009ba86f7760e05cdc0639d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61972e75c5f5f254339b97ea61f2f54"><td class="memItemLeft" align="right" valign="top"><a id="ab61972e75c5f5f254339b97ea61f2f54"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CompareTo</b> (object obj)</td></tr>
<tr class="separator:ab61972e75c5f5f254339b97ea61f2f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4414a79b906673c57791978d85aecf"><td class="memItemLeft" align="right" valign="top"><a id="a1c4414a79b906673c57791978d85aecf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CompareTo</b> (<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> other)</td></tr>
<tr class="separator:a1c4414a79b906673c57791978d85aecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f46cecabbf5760acf74d2a91081c2e4"><td class="memItemLeft" align="right" valign="top"><a id="a3f46cecabbf5760acf74d2a91081c2e4"></a>
override int&#160;</td><td class="memItemRight" valign="bottom"><b>GetHashCode</b> ()</td></tr>
<tr class="separator:a3f46cecabbf5760acf74d2a91081c2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995c5e3f8e5ee00d237f53686e0433c"><td class="memItemLeft" align="right" valign="top"><a id="a8995c5e3f8e5ee00d237f53686e0433c"></a>
override bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (object other)</td></tr>
<tr class="separator:a8995c5e3f8e5ee00d237f53686e0433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54cfe1328bf2b8b69c9b973273848b"><td class="memItemLeft" align="right" valign="top"><a id="a1e54cfe1328bf2b8b69c9b973273848b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (<a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> other)</td></tr>
<tr class="separator:a1e54cfe1328bf2b8b69c9b973273848b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1e80d1d6d918c9bf8a18483ac82b49"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a9b1e80d1d6d918c9bf8a18483ac82b49">ToString</a> (Encoding encoding)</td></tr>
<tr class="memdesc:a9b1e80d1d6d918c9bf8a18483ac82b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coverts the readable bytes in this buffer into a string value using the Encoding value provided. The underlying read and write offset values are not modified as a result of this operation.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a9b1e80d1d6d918c9bf8a18483ac82b49">More...</a><br /></td></tr>
<tr class="separator:a9b1e80d1d6d918c9bf8a18483ac82b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22aca2cc82a37d8aed770525e43ca74"><td class="memItemLeft" align="right" valign="top"><a id="aa22aca2cc82a37d8aed770525e43ca74"></a>
override string&#160;</td><td class="memItemRight" valign="bottom"><b>ToString</b> ()</td></tr>
<tr class="separator:aa22aca2cc82a37d8aed770525e43ca74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a28f5dc92f3575668a9708a1eb2fb9d00"><td class="memItemLeft" align="right" valign="top">static readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a28f5dc92f3575668a9708a1eb2fb9d00">DefaultCapacity</a> = 64</td></tr>
<tr class="memdesc:a28f5dc92f3575668a9708a1eb2fb9d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default initial capacity when created without initial value.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#a28f5dc92f3575668a9708a1eb2fb9d00">More...</a><br /></td></tr>
<tr class="separator:a28f5dc92f3575668a9708a1eb2fb9d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff5b229b9e1712eff4d38076b70a3ff"><td class="memItemLeft" align="right" valign="top">static readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aaff5b229b9e1712eff4d38076b70a3ff">DefaultMaximumCapacity</a> = int.MaxValue</td></tr>
<tr class="memdesc:aaff5b229b9e1712eff4d38076b70a3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default max capacity based on maximum array size limit as this buffer is backed by a byte array.  <a href="classApache_1_1Qpid_1_1Proton_1_1Buffer_1_1ProtonByteBuffer.html#aaff5b229b9e1712eff4d38076b70a3ff">More...</a><br /></td></tr>
<tr class="separator:aaff5b229b9e1712eff4d38076b70a3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a9a9aa30e96a7cb037fafc5d8a6b47149"><td class="memItemLeft" align="right" valign="top"><a id="a9a9aa30e96a7cb037fafc5d8a6b47149"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>Capacity</b><code> [get]</code></td></tr>
<tr class="separator:a9a9aa30e96a7cb037fafc5d8a6b47149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7224f933f7a588f5ac44a64335bf63ff"><td class="memItemLeft" align="right" valign="top"><a id="a7224f933f7a588f5ac44a64335bf63ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReadable</b><code> [get]</code></td></tr>
<tr class="separator:a7224f933f7a588f5ac44a64335bf63ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f70b6cf7317c2d4d031e0aeccc4d67"><td class="memItemLeft" align="right" valign="top"><a id="a64f70b6cf7317c2d4d031e0aeccc4d67"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>ReadableBytes</b><code> [get]</code></td></tr>
<tr class="separator:a64f70b6cf7317c2d4d031e0aeccc4d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85d5a2e6867b6084e1f8647f99e127"><td class="memItemLeft" align="right" valign="top"><a id="a1a85d5a2e6867b6084e1f8647f99e127"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsWritable</b><code> [get]</code></td></tr>
<tr class="separator:a1a85d5a2e6867b6084e1f8647f99e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3a82e4e8c9c0f55f4d7c4c4d15f6d8"><td class="memItemLeft" align="right" valign="top"><a id="afa3a82e4e8c9c0f55f4d7c4c4d15f6d8"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>WritableBytes</b><code> [get]</code></td></tr>
<tr class="separator:afa3a82e4e8c9c0f55f4d7c4c4d15f6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96dc8e63b027721a7ae630e79147586"><td class="memItemLeft" align="right" valign="top"><a id="ab96dc8e63b027721a7ae630e79147586"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>ReadOffset</b><code> [get, set]</code></td></tr>
<tr class="separator:ab96dc8e63b027721a7ae630e79147586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ad390643ad03276aebf609bb9e0123"><td class="memItemLeft" align="right" valign="top"><a id="a03ad390643ad03276aebf609bb9e0123"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>WriteOffset</b><code> [get, set]</code></td></tr>
<tr class="separator:a03ad390643ad03276aebf609bb9e0123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d1e0dbeef760e76a24f32bcd132ef5"><td class="memItemLeft" align="right" valign="top"><a id="ab7d1e0dbeef760e76a24f32bcd132ef5"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>ComponentCount</b><code> [get]</code></td></tr>
<tr class="separator:ab7d1e0dbeef760e76a24f32bcd132ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf227d388267f232ac9f4824910be98"><td class="memItemLeft" align="right" valign="top"><a id="aacf227d388267f232ac9f4824910be98"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>ReadableComponentCount</b><code> [get]</code></td></tr>
<tr class="separator:aacf227d388267f232ac9f4824910be98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cce4baff5561cfdce9c44d204a3ca45"><td class="memItemLeft" align="right" valign="top"><a id="a5cce4baff5561cfdce9c44d204a3ca45"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>WritableComponentCount</b><code> [get]</code></td></tr>
<tr class="separator:a5cce4baff5561cfdce9c44d204a3ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785c88bb2150e3dccc0b5e88096f322c"><td class="memItemLeft" align="right" valign="top"><a id="a785c88bb2150e3dccc0b5e88096f322c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasReadableArray</b><code> [get]</code></td></tr>
<tr class="separator:a785c88bb2150e3dccc0b5e88096f322c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82d82c261384ebb3a66c24600ab62e3"><td class="memItemLeft" align="right" valign="top"><a id="aa82d82c261384ebb3a66c24600ab62e3"></a>
byte[]&#160;</td><td class="memItemRight" valign="bottom"><b>ReadableArray</b><code> [get]</code></td></tr>
<tr class="separator:aa82d82c261384ebb3a66c24600ab62e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777d35666d19bb858c5c87598160f1e8"><td class="memItemLeft" align="right" valign="top"><a id="a777d35666d19bb858c5c87598160f1e8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ReadableArrayOffset</b><code> [get]</code></td></tr>
<tr class="separator:a777d35666d19bb858c5c87598160f1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e7007bfcefa2a865c122941677b94a"><td class="memItemLeft" align="right" valign="top"><a id="a91e7007bfcefa2a865c122941677b94a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ReadableArrayLength</b><code> [get]</code></td></tr>
<tr class="separator:a91e7007bfcefa2a865c122941677b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a5afe4743120c24ef678670978855c"><td class="memItemLeft" align="right" valign="top"><a id="a09a5afe4743120c24ef678670978855c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasWritableArray</b><code> [get]</code></td></tr>
<tr class="separator:a09a5afe4743120c24ef678670978855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb70ceb78e33845f3503c8470a3ec80"><td class="memItemLeft" align="right" valign="top"><a id="a3fb70ceb78e33845f3503c8470a3ec80"></a>
byte[]&#160;</td><td class="memItemRight" valign="bottom"><b>WritableArray</b><code> [get]</code></td></tr>
<tr class="separator:a3fb70ceb78e33845f3503c8470a3ec80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb0035f2ae696887127c42c35eb4c9c"><td class="memItemLeft" align="right" valign="top"><a id="a2cb0035f2ae696887127c42c35eb4c9c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>WritableArrayOffset</b><code> [get]</code></td></tr>
<tr class="separator:a2cb0035f2ae696887127c42c35eb4c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195cf5c2d372c15f86f5d563fddce7c1"><td class="memItemLeft" align="right" valign="top"><a id="a195cf5c2d372c15f86f5d563fddce7c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>WritableArrayLength</b><code> [get]</code></td></tr>
<tr class="separator:a195cf5c2d372c15f86f5d563fddce7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">Apache.Qpid.Proton.Buffer.IProtonBuffer</a></td></tr>
<tr class="memitem:ad66e20f0e5eda9dd91f5a95a44448c63 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#ad66e20f0e5eda9dd91f5a95a44448c63">Capacity</a><code> [get]</code></td></tr>
<tr class="memdesc:ad66e20f0e5eda9dd91f5a95a44448c63 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current capacity of this buffer instance which is the total amount of bytes that could be written before additional buffer capacity would be needed to allow more buffer writes. The remaining amount of writable bytes at any given time is the buffer capacity minus the write offset.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#ad66e20f0e5eda9dd91f5a95a44448c63">More...</a><br /></td></tr>
<tr class="separator:ad66e20f0e5eda9dd91f5a95a44448c63 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9d5568cc763054acae3ef64c085378 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#afe9d5568cc763054acae3ef64c085378">IsReadable</a><code> [get]</code></td></tr>
<tr class="memdesc:afe9d5568cc763054acae3ef64c085378 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current read offset is less than the current write offset meaning there are bytes available for reading.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#afe9d5568cc763054acae3ef64c085378">More...</a><br /></td></tr>
<tr class="separator:afe9d5568cc763054acae3ef64c085378 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24fa3dc40bde695f5780f029b71de15 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#ab24fa3dc40bde695f5780f029b71de15">ReadableBytes</a><code> [get]</code></td></tr>
<tr class="memdesc:ab24fa3dc40bde695f5780f029b71de15 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes that can currently be read from this buffer.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#ab24fa3dc40bde695f5780f029b71de15">More...</a><br /></td></tr>
<tr class="separator:ab24fa3dc40bde695f5780f029b71de15 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48093d07b14ddf86f0ad2ef1d767f446 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a48093d07b14ddf86f0ad2ef1d767f446">IsWritable</a><code> [get]</code></td></tr>
<tr class="memdesc:a48093d07b14ddf86f0ad2ef1d767f446 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if write offset is less than the current buffer capacity limit.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a48093d07b14ddf86f0ad2ef1d767f446">More...</a><br /></td></tr>
<tr class="separator:a48093d07b14ddf86f0ad2ef1d767f446 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab870dbd9210b3290b97fd8eee5eb8a59 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#ab870dbd9210b3290b97fd8eee5eb8a59">WritableBytes</a><code> [get]</code></td></tr>
<tr class="memdesc:ab870dbd9210b3290b97fd8eee5eb8a59 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes that can currently be written from this buffer.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#ab870dbd9210b3290b97fd8eee5eb8a59">More...</a><br /></td></tr>
<tr class="separator:ab870dbd9210b3290b97fd8eee5eb8a59 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071836b17919ceda9d202bf11686c727 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a071836b17919ceda9d202bf11686c727">ReadOffset</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a071836b17919ceda9d202bf11686c727 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the current read offset in this buffer. If the read offset is set to a value larger than the current write offset an exception is thrown.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a071836b17919ceda9d202bf11686c727">More...</a><br /></td></tr>
<tr class="separator:a071836b17919ceda9d202bf11686c727 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4baa8ae0d35ea54e39c25594e47ed5 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a0f4baa8ae0d35ea54e39c25594e47ed5">WriteOffset</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a0f4baa8ae0d35ea54e39c25594e47ed5 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the current write offset in this buffer. If the write offset is set to a value less than the current read offset or larger than the current buffer capacity an exception is thrown.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a0f4baa8ae0d35ea54e39c25594e47ed5">More...</a><br /></td></tr>
<tr class="separator:a0f4baa8ae0d35ea54e39c25594e47ed5 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6351dc69ca0d859e56f953a78e5455 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a5a6351dc69ca0d859e56f953a78e5455">ComponentCount</a><code> [get]</code></td></tr>
<tr class="memdesc:a5a6351dc69ca0d859e56f953a78e5455 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of component buffers in this buffer. If this is not a composite buffer instance then the count will always be one. For a composite buffer this will be the count of the current number of component buffers contained within.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a5a6351dc69ca0d859e56f953a78e5455">More...</a><br /></td></tr>
<tr class="separator:a5a6351dc69ca0d859e56f953a78e5455 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8acee44b205fa61519603ec599addb inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#afa8acee44b205fa61519603ec599addb">ReadableComponentCount</a><code> [get]</code></td></tr>
<tr class="memdesc:afa8acee44b205fa61519603ec599addb inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of component buffers in this buffer that are readable and would be provided to calls to the for each readable buffer API. If this is not a composite buffer instance then the count will be at most one. For a composite buffer this will be the count of the current number of component buffers contained within that are readable.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#afa8acee44b205fa61519603ec599addb">More...</a><br /></td></tr>
<tr class="separator:afa8acee44b205fa61519603ec599addb inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac345932afa511777c950977562418c9 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#aac345932afa511777c950977562418c9">WritableComponentCount</a><code> [get]</code></td></tr>
<tr class="memdesc:aac345932afa511777c950977562418c9 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of component buffers in this buffer that are writable and would be provided to calls to the for each writable buffer API. If this is not a composite buffer instance then the count will be at most one. For a composite buffer this will be the count of the current number of component buffers contained within that are writable.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#aac345932afa511777c950977562418c9">More...</a><br /></td></tr>
<tr class="separator:aac345932afa511777c950977562418c9 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a></td></tr>
<tr class="memitem:ad725007eec40b6a3d7f7faa2ca1c8df1 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#ad725007eec40b6a3d7f7faa2ca1c8df1">this[long i]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ad725007eec40b6a3d7f7faa2ca1c8df1 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed access to single unsigned byte values within the buffer which does not modify the read or write index value. The given index must adhere to the same constraints as the get byte and set byte level APIs in this buffer class.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#ad725007eec40b6a3d7f7faa2ca1c8df1">More...</a><br /></td></tr>
<tr class="separator:ad725007eec40b6a3d7f7faa2ca1c8df1 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html">Apache.Qpid.Proton.Buffer.IReadableComponent</a></td></tr>
<tr class="memitem:a7e4fa735079934185a392fb6d4a36fa3 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html#a7e4fa735079934185a392fb6d4a36fa3">HasReadableArray</a><code> [get]</code></td></tr>
<tr class="memdesc:a7e4fa735079934185a392fb6d4a36fa3 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the component is back by a byte array that has readable bytes.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html#a7e4fa735079934185a392fb6d4a36fa3">More...</a><br /></td></tr>
<tr class="separator:a7e4fa735079934185a392fb6d4a36fa3 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc42d261f43cf22a8c88d4a72dfc1c inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="memItemLeft" align="right" valign="top">byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html#a05cc42d261f43cf22a8c88d4a72dfc1c">ReadableArray</a><code> [get]</code></td></tr>
<tr class="memdesc:a05cc42d261f43cf22a8c88d4a72dfc1c inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the readable array that backs this component if one exists otherwise throw an invalid operation exception to indicate that there is no readable byte array.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html#a05cc42d261f43cf22a8c88d4a72dfc1c">More...</a><br /></td></tr>
<tr class="separator:a05cc42d261f43cf22a8c88d4a72dfc1c inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b86d98d87534ac5b2964130aefe925 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html#ae6b86d98d87534ac5b2964130aefe925">ReadableArrayOffset</a><code> [get]</code></td></tr>
<tr class="memdesc:ae6b86d98d87534ac5b2964130aefe925 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the offset into the readable backing array if one exists otherwise throws an invalid operation exception to indicate that there is no readable byte array.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html#ae6b86d98d87534ac5b2964130aefe925">More...</a><br /></td></tr>
<tr class="separator:ae6b86d98d87534ac5b2964130aefe925 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bf6e809b2dd557e3b4b12e157e5fb5 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html#af7bf6e809b2dd557e3b4b12e157e5fb5">ReadableArrayLength</a><code> [get]</code></td></tr>
<tr class="memdesc:af7bf6e809b2dd557e3b4b12e157e5fb5 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the usable length of the readable backing array if one exists otherwise throws an invalid operation exception to indicate that there is no readable byte array.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html#af7bf6e809b2dd557e3b4b12e157e5fb5">More...</a><br /></td></tr>
<tr class="separator:af7bf6e809b2dd557e3b4b12e157e5fb5 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html">Apache.Qpid.Proton.Buffer.IWritableComponent</a></td></tr>
<tr class="memitem:a403c93a4fd6bdcf8dbde9e4a5801804e inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html#a403c93a4fd6bdcf8dbde9e4a5801804e">HasWritableArray</a><code> [get]</code></td></tr>
<tr class="memdesc:a403c93a4fd6bdcf8dbde9e4a5801804e inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the component is back by a byte array that has writable bytes.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html#a403c93a4fd6bdcf8dbde9e4a5801804e">More...</a><br /></td></tr>
<tr class="separator:a403c93a4fd6bdcf8dbde9e4a5801804e inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017387d838157aaab1dac82e34bc8d89 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="memItemLeft" align="right" valign="top">byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html#a017387d838157aaab1dac82e34bc8d89">WritableArray</a><code> [get]</code></td></tr>
<tr class="memdesc:a017387d838157aaab1dac82e34bc8d89 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Writable array that backs this component if one exists otherwise throw an invalid operation exception to indicate that there is no writable byte array.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html#a017387d838157aaab1dac82e34bc8d89">More...</a><br /></td></tr>
<tr class="separator:a017387d838157aaab1dac82e34bc8d89 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5c6ba7f4c3fab0b129dff0193ec520 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html#a6f5c6ba7f4c3fab0b129dff0193ec520">WritableArrayOffset</a><code> [get]</code></td></tr>
<tr class="memdesc:a6f5c6ba7f4c3fab0b129dff0193ec520 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the offset into the writable backing array if one exists otherwise throws an invalid operation exception to indicate that there is no writable byte array.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html#a6f5c6ba7f4c3fab0b129dff0193ec520">More...</a><br /></td></tr>
<tr class="separator:a6f5c6ba7f4c3fab0b129dff0193ec520 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca1fc5d5585923458ae9b1d5ae83942 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html#aaca1fc5d5585923458ae9b1d5ae83942">WritableArrayLength</a><code> [get]</code></td></tr>
<tr class="memdesc:aaca1fc5d5585923458ae9b1d5ae83942 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the usable length of the writable backing array if one exists otherwise throws an invalid operation exception to indicate that there is no writable byte array.  <a href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html#aaca1fc5d5585923458ae9b1d5ae83942">More...</a><br /></td></tr>
<tr class="separator:aaca1fc5d5585923458ae9b1d5ae83942 inherit properties_interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A proton buffer implementation that wraps a single heap allocated byte array and provides read and write operations on that array along with self resizing based on capacity limits. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a65ad1db3f8f2961d08e78d1f61f1634a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ad1db3f8f2961d08e78d1f61f1634a">&#9670;&nbsp;</a></span>ProtonByteBuffer() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ProtonByteBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new proton byte buffer instance with default initial capacity and limited only by the size of a byte array in max capacity. </p>

</div>
</div>
<a id="a5db9f627a1057ea0f3eaddd58e543bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db9f627a1057ea0f3eaddd58e543bf9">&#9670;&nbsp;</a></span>ProtonByteBuffer() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ProtonByteBuffer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new proton byte buffer instance with given initial capacity and limited only by the size of a byte array in max capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>The initial capacity of this buffer</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18eb40171cf802ce065073357ef280b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18eb40171cf802ce065073357ef280b6">&#9670;&nbsp;</a></span>ProtonByteBuffer() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ProtonByteBuffer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new proton byte buffer instance with given initial capacity and limited to a max capacity of the given amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>The initial capacity of this buffer</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d1cd7281bad0eda042f80e99981ba23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1cd7281bad0eda042f80e99981ba23">&#9670;&nbsp;</a></span>ProtonByteBuffer() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ProtonByteBuffer </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>backingArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new proton byte buffer instance with given backing array whose size determines that largest the buffer can ever be. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backingArray</td><td>The actual byte array that backs this buffer</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf9fde69201aeabc0c718762ba2303b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9fde69201aeabc0c718762ba2303b0">&#9670;&nbsp;</a></span>ProtonByteBuffer() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ProtonByteBuffer </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>backingArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new proton byte buffer instance with given backing array as the starting backing store and uses the provided max capacity value to control how large the buffer could ever grow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backingArray</td><td>The actual byte array that backs this buffer</td></tr>
    <tr><td class="paramname">maxCapacity</td><td>The maximum capacity this buffer can grow to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aa512148d8402aa14cebd5aeb87e9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa512148d8402aa14cebd5aeb87e9ba">&#9670;&nbsp;</a></span>ProtonByteBuffer() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ProtonByteBuffer </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>backingArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new proton byte buffer instance with given backing array as the starting backing store and uses the provided max capacity value to control how large the buffer could ever grow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backingArray</td><td>The actual byte array that backs this buffer</td></tr>
    <tr><td class="paramname">arrayOffset</td><td>The offset into the backing array where the buffer starts</td></tr>
    <tr><td class="paramname">maxCapacity</td><td>The maximum capacity this buffer can grow to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ecbd629f6a3154b34df50f5b432bcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecbd629f6a3154b34df50f5b432bcb6">&#9670;&nbsp;</a></span>ProtonByteBuffer() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ProtonByteBuffer </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>backingArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new proton byte buffer instance with given backing array as the starting backing store and uses the provided max capacity value to control how large the buffer could ever grow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backingArray</td><td>The actual byte array that backs this buffer</td></tr>
    <tr><td class="paramname">arrayOffset</td><td>The offset index into the backing array where the buffer starts</td></tr>
    <tr><td class="paramname">capacity</td><td>The capacity limit for this view of the assigned array</td></tr>
    <tr><td class="paramname">maxCapacity</td><td>The maximum capacity this buffer can grow to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1ce2d129a3a8f70234ac3baee3e1b7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce2d129a3a8f70234ac3baee3e1b7fc">&#9670;&nbsp;</a></span>Compact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.Compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards the read bytes, and moves the buffer contents to the beginning of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a9e9bca6e31529ac544ff1240e837680a">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="aeb648d1178b150897ae3df5fcba622d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb648d1178b150897ae3df5fcba622d2">&#9670;&nbsp;</a></span>Copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.Copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of this buffer's readable bytes. Modifying the content of the returned buffer will not affect this buffers contents. The two buffers will maintain separate offsets. The returned copy has the write offset set to the length of the copy meaning that the entire copied region is read for reading. </p>
<dl class="section return"><dt>Returns</dt><dd>A new buffer with a copy of the readable bytes in this buffer</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a4e34ec6f249c3188a3ca11cf965f1a1f">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="ae4344c52b553c334bdeddadc9184a2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4344c52b553c334bdeddadc9184a2db">&#9670;&nbsp;</a></span>Copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.Copy </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of this buffer's readable bytes. Modifying the content of the returned buffer will not affect this buffers contents. The two buffers will maintain separate offsets. The amount and start of the data to be copied is provided by the index and length arguments. The returned copy has the write offset set to the length of the copy meaning that the entire copied region is read for reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The read offset where the copy begins</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer with a copy of the readable bytes in the specified region</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a2aacd63bf925e46bfb10991b4a5670dd">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a83a389b7d72771d5ab10fce435bbd5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a389b7d72771d5ab10fce435bbd5d8">&#9670;&nbsp;</a></span>CopyInto() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.CopyInto </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given number of bytes from this buffer into the target byte buffer starting the read from the given position in this buffer and the write to at the given position in the destination buffer. The length parameter controls how many bytes are copied to the destination. This method does not modify the read or write offset values in this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcPos</td><td>Position in this buffer to begin the copy from</td></tr>
    <tr><td class="paramname">dest</td><td>Destination buffer where the copied bytes are written</td></tr>
    <tr><td class="paramname">destPos</td><td>Position in the destination where the write begins</td></tr>
    <tr><td class="paramname">length</td><td>Number of byte to copy to the destination</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This buffer instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td></td></tr>
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td></td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a41a8a013dfa52854e15a197e60671d1d">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="ae93a87e59b3d210408beb081dbb0d0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93a87e59b3d210408beb081dbb0d0b9">&#9670;&nbsp;</a></span>CopyInto() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.CopyInto </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given number of bytes from this buffer into the target byte buffer starting the read from the given position in this buffer and the write to at the given position in the destination buffer. The length parameter controls how many bytes are copied to the destination. This method does not modify the read or write offset values in this buffer nor those of the destination buffer. The destination write index is an absolute index value unrelated to the write offset of the target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcPos</td><td>Position in this buffer to begin the copy from</td></tr>
    <tr><td class="paramname">dest</td><td>Destination buffer where the copied bytes are written</td></tr>
    <tr><td class="paramname">destPos</td><td>Position in the destination where the write begins</td></tr>
    <tr><td class="paramname">length</td><td>Number of byte to copy to the destination</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This buffer instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td></td></tr>
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td></td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a32c170ccd46b5fb32fbf88323932d50e">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="af585e151af64dbbd27bc12392968b444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af585e151af64dbbd27bc12392968b444">&#9670;&nbsp;</a></span>EnsureWritable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.EnsureWritable </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>amount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the buffer ensure that there is enough allocated internal capacity such that the given number of bytes can be written without requiring additional allocations and that this amount does not exceed any total capacity restrictions for this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>the number of bytes that should be available fro writing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This buffer instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>If the requested amount exceeds capacity restrictions</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#ab173585f0d8585926d4b516d9dc83568">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="ae6703a4dfd0feb26176b024bd783728b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6703a4dfd0feb26176b024bd783728b">&#9670;&nbsp;</a></span>Fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.Fill </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the buffer with the given byte value. This method does not respect the read offset nor the write offset but instead fills the entire backing buffer memory with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The byte value to assign each byte in the backing store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This buffer instance.</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#aa4919f89324410a3d598c3413ad4c3fd">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a4b72990fd9cd1ac2fdb7df30649ff412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b72990fd9cd1ac2fdb7df30649ff412">&#9670;&nbsp;</a></span>ForEachReadableComponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ForEachReadableComponent </td>
          <td>(</td>
          <td class="paramtype">in int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in Func&lt; int, <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IReadableComponent.html">IReadableComponent</a>, bool &gt;&#160;</td>
          <td class="paramname"><em>processor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the provided delegate for each readable component in this buffer and increments the provided index value for each invocation. The total number of buffers processed is returned to the caller. The delegate can stop processing at any time by returning false in which case this method will stop and return a negative value to indicate that processing stopped early and did not traverse all available components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>a starting index which is increment after each call</td></tr>
    <tr><td class="paramname">processor</td><td>The delegate that will receive the components</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of components processed or negative if stopped early.</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a16128227e8ef3f6161f2d6b8f826140b">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a0bb7a1bddaaf6cca84ca07f53e792816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb7a1bddaaf6cca84ca07f53e792816">&#9670;&nbsp;</a></span>ForEachWritableComponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ForEachWritableComponent </td>
          <td>(</td>
          <td class="paramtype">in int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in Func&lt; int, <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IWritableComponent.html">IWritableComponent</a>, bool &gt;&#160;</td>
          <td class="paramname"><em>processor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the provided delegate for each writable component in this buffer and increments the provided index value for each invocation. The total number of buffers processed is returned to the caller. The delegate can stop processing at any time by returning false in which case this method will stop and return a negative value to indicate that processing stopped early and did not traverse all available components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>a starting index which is increment after each call</td></tr>
    <tr><td class="paramname">processor</td><td>The delegate that will receive the components</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of components processed or negative if stopped early.</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a01fc21814ec3dac24561c1a5713dba4f">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a6959792ad296d7e94a03ba832704dd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6959792ad296d7e94a03ba832704dd88">&#9670;&nbsp;</a></span>GetBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetBoolean </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single byte from the given index and returns a boolean value indicating if the byte was zero (false) or greater than zero (true). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean value of the byte at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a67f3bb2699b9d10174fb0588dd9c03d9">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="aec125ee5b15dbe988a60d0c77c323dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec125ee5b15dbe988a60d0c77c323dd1">&#9670;&nbsp;</a></span>GetByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sbyte Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetByte </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single signed byte from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#abddb50f85a8ee9a4dc1c4388a0150e0c">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="ab81fcb30b1c6855a9c210f9f41b373c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81fcb30b1c6855a9c210f9f41b373c8">&#9670;&nbsp;</a></span>GetChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetChar </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 2 byte char from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the char value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a494f8102bcc0a8f02fa2d8b1f83c8222">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="ac017287110276c3dfa48ec92173f1e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac017287110276c3dfa48ec92173f1e29">&#9670;&nbsp;</a></span>GetDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetDouble </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 8 byte double from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the double value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#afc596b3498f5308102795afda5c506ef">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="aab79535e1ef0262256c88e14785fbc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab79535e1ef0262256c88e14785fbc45">&#9670;&nbsp;</a></span>GetFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetFloat </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 4 byte float from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the float value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#ab661f5eaf580454bdce1b1f496ccc5f7">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a35747aa5f68a63c224381c3c7ea3d850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35747aa5f68a63c224381c3c7ea3d850">&#9670;&nbsp;</a></span>GetInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetInt </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 4 byte int from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a27a3f9b8842d43071c2e3d45bd033677">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a82edf32567d7ad98b865624bfc88209e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82edf32567d7ad98b865624bfc88209e">&#9670;&nbsp;</a></span>GetLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetLong </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 8 byte long from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a9d73544ff8a7d76091d0e155a38bd619">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="aaee6c04b55ad47912b693f156bffec74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee6c04b55ad47912b693f156bffec74">&#9670;&nbsp;</a></span>GetShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetShort </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 2 byte short from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the short value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#ada1cfa2dcf757ec3e5d8643f9ecc5982">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a0a1d22a7b1fee3b18866d1511c720aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1d22a7b1fee3b18866d1511c720aeb">&#9670;&nbsp;</a></span>GetUnsignedByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetUnsignedByte </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single unsigned byte from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a268b8d2564324fa7c4733eba13766457">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a7ec3aa2e1c9d68993fb6159c1d536a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec3aa2e1c9d68993fb6159c1d536a17">&#9670;&nbsp;</a></span>GetUnsignedInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetUnsignedInt </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 4 byte unsigned int from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a924e05f676c1c111f120565e5f432d06">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a9a4e6c6bf38fdb0ff159b4ff377332b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4e6c6bf38fdb0ff159b4ff377332b5">&#9670;&nbsp;</a></span>GetUnsignedLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetUnsignedLong </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 8 byte unsigned long from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a8dc8290ef3cf39fc30349e0f1425d409">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a684ba0bd453e055478ce15fc35caa53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684ba0bd453e055478ce15fc35caa53c">&#9670;&nbsp;</a></span>GetUnsignedShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ushort Apache.Qpid.Proton.Buffer.ProtonByteBuffer.GetUnsignedShort </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single 2 byte unsigned short from the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the short value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#add33ded6eea6f3cfd431f401de714317">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a8c93f813e800a586108f2f4668ea4054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c93f813e800a586108f2f4668ea4054">&#9670;&nbsp;</a></span>ReadBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadBoolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next byte from the buffer and returns the boolean value. </p>
<dl class="section return"><dt>Returns</dt><dd>the boolean value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a7e369a78fd0e0de6b5b7564df69ac062">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a58124e1191b4fdc1a452b9b77111e9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58124e1191b4fdc1a452b9b77111e9d5">&#9670;&nbsp;</a></span>ReadByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sbyte Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a signed byte from the buffer and advance the read offset. </p>
<dl class="section return"><dt>Returns</dt><dd>The value read from the buffer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the buffer has no more readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#acbbc7feea154d9af93a37339a9676f94">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="afd392778267a9a910b8da127faeb29bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd392778267a9a910b8da127faeb29bf">&#9670;&nbsp;</a></span>ReadChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the two bytes from the buffer and returns the char value. </p>
<dl class="section return"><dt>Returns</dt><dd>the char value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a66432aecd9e93c6b8495950c763aef58">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="abb51fc67443963eb12a31b8b32a21802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb51fc67443963eb12a31b8b32a21802">&#9670;&nbsp;</a></span>ReadDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next eight bytes from the buffer and returns the double value. </p>
<dl class="section return"><dt>Returns</dt><dd>the double value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#aab45e9e0e1a2e9a2e79cfa134f0dbba0">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a90e4e46c6aa627639342f6de5a5c0ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e4e46c6aa627639342f6de5a5c0ff4">&#9670;&nbsp;</a></span>ReadFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next four bytes from the buffer and returns the float value. </p>
<dl class="section return"><dt>Returns</dt><dd>the float value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a5d3156d634994dabfde848accb647b4b">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a1a3f5c9f13e68cd04bfe3bbc694357c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3f5c9f13e68cd04bfe3bbc694357c1">&#9670;&nbsp;</a></span>ReadInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next four bytes from the buffer and returns the int value. </p>
<dl class="section return"><dt>Returns</dt><dd>the int value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#acfb078c7ac2546ca114a54ecfa6d774f">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="afce6dc54010df7685e77165f77f89e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce6dc54010df7685e77165f77f89e03">&#9670;&nbsp;</a></span>ReadLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next eight bytes from the buffer and returns the long value. </p>
<dl class="section return"><dt>Returns</dt><dd>the long value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a26a8a311b66c10c9e239f369a62c6032">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a4eae51338a30c697ba93b51810d07a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eae51338a30c697ba93b51810d07a88">&#9670;&nbsp;</a></span>ReadShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadShort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next two bytes from the buffer and returns the short value. </p>
<dl class="section return"><dt>Returns</dt><dd>the short value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a09d887d925043e090aa6c5622417ed7a">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a0777c671a3a2e609f776c878d636e692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0777c671a3a2e609f776c878d636e692">&#9670;&nbsp;</a></span>ReadSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadSplit </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the buffer into two distinct buffers at the given index plus the current read offset. The returned buffer will retain the read offset and write offset of this buffer but will be truncated to match the capacity provided by the split index, which implies that they might both be set to the capacity if they were previously set beyond the split index. The returned buffer will set its read and write offsets to zero if they fell prior to the given index otherwise they will be truncated to match the new buffer capacity. Split buffers support the standard buffer operations including resizing to ensure writable regions which implies that a buffer resize on either will cause them to no longer reference the same underlying memory region. If buffer implementations implement pooling then they must ensure proper release of shared buffer regions once both buffers no longer reference them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset to split beyond the current read offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer that access the front portion of the buffer split</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#aba3ce684d8bc18eff174454036aec4ef">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="af816e6a26a3c78cdee9c91d3d51c560f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af816e6a26a3c78cdee9c91d3d51c560f">&#9670;&nbsp;</a></span>ReadUnsignedByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadUnsignedByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a unsigned byte from the buffer and advance the read offset. </p>
<dl class="section return"><dt>Returns</dt><dd>The value read from the buffer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the buffer has no more readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a7fd1e33d81fffca6534549f576e0a150">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a972e3168af8d5c1000a526282b07005d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972e3168af8d5c1000a526282b07005d">&#9670;&nbsp;</a></span>ReadUnsignedInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadUnsignedInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next four bytes from the buffer and returns the unsigned int value. </p>
<dl class="section return"><dt>Returns</dt><dd>the unsigned int value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#ac6ddb6631f833c14e2617db4b30de1f9">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a1e28044a03a52d1781fe82268b925d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e28044a03a52d1781fe82268b925d98">&#9670;&nbsp;</a></span>ReadUnsignedLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadUnsignedLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next eight bytes from the buffer and returns the unsigned long value. </p>
<dl class="section return"><dt>Returns</dt><dd>the unsigned long value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a0e5edaacb12fb2e271d6a0bdd84865c8">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="af5c2f77dc78b5160e9da1067db0ab512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c2f77dc78b5160e9da1067db0ab512">&#9670;&nbsp;</a></span>ReadUnsignedShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ushort Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ReadUnsignedShort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next two bytes from the buffer and returns the unsigned short value. </p>
<dl class="section return"><dt>Returns</dt><dd>the unsigned short value at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough readable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a435944cb521dc3cdea4bd6825871abbb">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a0fedd3d38837f8ee145db4eb9008a43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fedd3d38837f8ee145db4eb9008a43f">&#9670;&nbsp;</a></span>Reclaim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.Reclaim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reclaims read buffer space and returns it to the operating system or other pooling mechanisms if those are in place, then compacts the remaining buffer contents. For a non-composite buffer this operation could consist of allocating a smaller buffer to house any remaining unread bytes and freeing the larger backing buffer in some cases or it may result in a no-op depending on the buffer implementation. For the composite buffer case this operation provides an API which allows for fully read buffer constituents to be released and returned to a memory pool or back to the O/S. </p>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a9260e7737c81b37f0c43f7d16bdba20f">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="aca2e65e4110eae90c776bedad536937d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2e65e4110eae90c776bedad536937d">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the read and write offset values to zero. </p>
<dl class="section return"><dt>Returns</dt><dd>This buffer instance.</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a170b9b5f5e746734e498bf929a16549f">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a6ea479cc7f3e02204fb9caaad8382914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea479cc7f3e02204fb9caaad8382914">&#9670;&nbsp;</a></span>SetBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetBoolean </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given boolean value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a0264e40335e1fd086302f5a11b7449cb">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a07ec03f8c5776c26da4c50affa205a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ec03f8c5776c26da4c50affa205a68">&#9670;&nbsp;</a></span>SetByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetByte </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given byte value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#ab9ac2b8383541a245555a69097401cf3">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a10bdaf52536adba4cf4b2bbffea80d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bdaf52536adba4cf4b2bbffea80d0e">&#9670;&nbsp;</a></span>SetChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetChar </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 2 byte char value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a5dfe2d0d6cc27a1ebae3514853f2e524">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a3b629b5c346c7e831c8062e11a6036df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b629b5c346c7e831c8062e11a6036df">&#9670;&nbsp;</a></span>SetDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetDouble </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 8 byte double value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a3d21aef1d546242950038fa1ca6b9cd0">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="aeeb40ca4f7433a3269966bce55e2e499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb40ca4f7433a3269966bce55e2e499">&#9670;&nbsp;</a></span>SetFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetFloat </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 4 byte float value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a3cf4e44bb7081862322580094cbdad22">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="abecf46601630cd5961bc20cf0fec6b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecf46601630cd5961bc20cf0fec6b66">&#9670;&nbsp;</a></span>SetInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetInt </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 4 byte int value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a27ac6d5b0a5322603d052eed769829eb">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="ae079f5dafe627ca44c4234ae256c6b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae079f5dafe627ca44c4234ae256c6b46">&#9670;&nbsp;</a></span>SetLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetLong </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 8 byte long value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#aca75d734fda017b5ebddc186d6de124b">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="add7dc84c78eb0d470fadb9982b6d3e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7dc84c78eb0d470fadb9982b6d3e99">&#9670;&nbsp;</a></span>SetShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetShort </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 2 byte short value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#abed9cd5b8e56cedca976b3e151536a69">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="ae88ebcfa36425434adbf3f5489ae28aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88ebcfa36425434adbf3f5489ae28aa">&#9670;&nbsp;</a></span>SetUnsignedByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetUnsignedByte </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given unsigned byte value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a071d1d22a72209da193ad422dd3288b9">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a559fc4b47ef1954fa05645be52f236c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559fc4b47ef1954fa05645be52f236c2">&#9670;&nbsp;</a></span>SetUnsignedInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetUnsignedInt </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 4 byte unsigned int value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a9ef7bf65e6f953197d4ae9ce6fbcd3dc">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a8130d870e8b836801483b991961c3584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8130d870e8b836801483b991961c3584">&#9670;&nbsp;</a></span>SetUnsignedLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetUnsignedLong </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 8 byte unsigned long value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a58fe0350c543162431f0ded36eff905a">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a3a0dc07d9e076246d583bd92f1cb1a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0dc07d9e076246d583bd92f1cb1a1f">&#9670;&nbsp;</a></span>SetUnsignedShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SetUnsignedShort </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the given 2 byte unsigned short value at the given location in the buffer backing store without modifying the write offset of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the buffer where the write should occur</td></tr>
    <tr><td class="paramname">value</td><td>The value to be written at the specified index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the index is negative or larger than buffer capacity</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#aafdf0f13c77ef405fd0e1608898eb0fd">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a4c79e2076cb29946d99862f0cc090aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c79e2076cb29946d99862f0cc090aaf">&#9670;&nbsp;</a></span>SkipBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.SkipBytes </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>amount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the buffer read offset by the specified amount effectively skipping that number of bytes from being read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The number of bytes to skip</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If the amount is negative or larger than readable size</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a48952f07b1d51891f76974b80c52df87">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a7e17b377b794582bd89c28f23050d244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e17b377b794582bd89c28f23050d244">&#9670;&nbsp;</a></span>Split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.Split </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the buffer into two buffers at the write offset. The resulting buffer will comprise the read and readable portions of this buffer with the write offset and capacity set to the current write offset. This buffer will lose access to the split region and its read offset will be set to the current write offset. This buffer will also have its capacity reduced by the number of bytes in the returned buffer (i.e. the current number of read and readable bytes). Split buffers support the standard buffer operations including resizing to ensure writable regions which implies that a buffer resize on either will cause them to no longer reference the same underlying memory region. If buffer implementations implement pooling then they must ensure proper release of shared buffer regions once both buffers no longer reference them. </p>
<dl class="section return"><dt>Returns</dt><dd>A new buffer that access the front portion of the buffer split</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#acae3a5f39a75855252ad922ca9c2065c">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a86a2fb56b8f514d3f344b15ba7cd8b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a2fb56b8f514d3f344b15ba7cd8b35">&#9670;&nbsp;</a></span>Split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.Split </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the buffer into two distinct buffers at the given index. The returned buffer will retain the read offset and write offset of this buffer but will be truncated to match the capacity provided by the split index, which implies that they might both be set to the capacity if they were previously set beyond the split index. The returned buffer will set its read and write offsets to zero if they fell prior to the given index otherwise they will be truncated to match the new buffer capacity. Split buffers support the standard buffer operations including resizing to ensure writable regions which implies that a buffer resize on either will cause them to no longer reference the same underlying memory region. If buffer implementations implement pooling then they must ensure proper release of shared buffer regions once both buffers no longer reference them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in this buffer where the split occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer that access the front portion of the buffer split</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a4326c640d62c909fdd6ed24202add322">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a9b1e80d1d6d918c9bf8a18483ac82b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1e80d1d6d918c9bf8a18483ac82b49">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string Apache.Qpid.Proton.Buffer.ProtonByteBuffer.ToString </td>
          <td>(</td>
          <td class="paramtype">Encoding&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Coverts the readable bytes in this buffer into a string value using the Encoding value provided. The underlying read and write offset values are not modified as a result of this operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>The encoding to use to convert the readable bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string value of the readable bytes as converted by the provided Encoding</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a4a53e9991dea44bac8a13757025401f0">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a0509ec19ca7ab24ec30df5ab1a88633c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0509ec19ca7ab24ec30df5ab1a88633c">&#9670;&nbsp;</a></span>WriteBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteBoolean </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given boolean value into this buffer as a single byte and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#af3098b7281ec6ab8ac69dc65ade1f207">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a2d0671fd9b076da2c29f82b230f13f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0671fd9b076da2c29f82b230f13f77">&#9670;&nbsp;</a></span>WriteByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteByte </td>
          <td>(</td>
          <td class="paramtype">sbyte&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given byte value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a6e5b361f9dfa2fd871e49fac59cb3e0a">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="aabcc44ff17631451a9ea12881a2993b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcc44ff17631451a9ea12881a2993b0">&#9670;&nbsp;</a></span>WriteBytes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteBytes </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the contents of the given byte array into this buffer and advances the write offset by the number of bytes written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The byte buffer to be written into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#abbdc44cbc36ca9126dab0a8af935f9ce">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a0c4209bf559eda9c806e156e053f18b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4209bf559eda9c806e156e053f18b7">&#9670;&nbsp;</a></span>WriteBytes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteBytes </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the contents of the given byte array into this buffer and advances the write offset by the number of bytes written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The byte buffer to be written into this buffer</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the source buffer to start the write</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes from the source buffer to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a67567a96165c61ac62ebfe824005aefd">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a49e2b4738009ba86f7760e05cdc0639d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e2b4738009ba86f7760e05cdc0639d">&#9670;&nbsp;</a></span>WriteBytes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers the bytes from the source buffer to this buffer starting at the current write offset and continues until the source buffer becomes unreadable. The write index of this buffer is increased by the number of bytes read from the source. The method also increases the read offset of the source by the same amount as was written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The byte buffer to be written into this buffer</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#aa0784e8f5a446e90b9ae57f16e3283ba">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="aa418ee9e87e78667642a204ffd7a38fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa418ee9e87e78667642a204ffd7a38fd">&#9670;&nbsp;</a></span>WriteDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteDouble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given eight byte double value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a2d784f8150ca88326e3a97ca9d3bea85">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a6c8f280e4eea0593bb3a2cd8a00b3306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8f280e4eea0593bb3a2cd8a00b3306">&#9670;&nbsp;</a></span>WriteFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given four byte float value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a56282ad18642407f0bcc904601559629">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a884a8c379817beee6a4d29767a57155a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884a8c379817beee6a4d29767a57155a">&#9670;&nbsp;</a></span>WriteInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given four byte int value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a1f5b6f52076a07a76722dc009689d388">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a8cac7c7f15c826afe91ea341ba308a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cac7c7f15c826afe91ea341ba308a0d">&#9670;&nbsp;</a></span>WriteLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteLong </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given eight byte long value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a440972781cc188e4c4298965e1c1f59b">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="afeca8acebc57bca3ef57cce879dca21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeca8acebc57bca3ef57cce879dca21b">&#9670;&nbsp;</a></span>WriteShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteShort </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given two byte short value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a47b46607343045f604e74a5fc8eb9f2e">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a30f81737b7f69d70ea245c4891d02cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f81737b7f69d70ea245c4891d02cb6">&#9670;&nbsp;</a></span>WriteSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteSplit </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the buffer into two distinct buffers at the given index plus the current write offset. The returned buffer will retain the read offset and write offset of this buffer but will be truncated to match the capacity provided by the split index, which implies that they might both be set to the capacity if they were previously set to the split index. The returned buffer will set its read and write offsets to zero if they fell prior to the given index otherwise they will be truncated to match the new buffer capacity. Split buffers support the standard buffer operations including resizing to ensure writable regions which implies that a buffer resize on either will cause them to no longer reference the same underlying memory region. If buffer implementations implement pooling then they must ensure proper release of shared buffer regions once both buffers no longer reference them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset to split beyond the current write offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer that access the front portion of the buffer split</dd></dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html#a5de1edd80e6b1d0ebc7b18845ecfc8b1">Apache.Qpid.Proton.Buffer.IProtonBuffer</a>.</p>

</div>
</div>
<a id="a82d47f5f016a39ca946337281aacc8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d47f5f016a39ca946337281aacc8b5">&#9670;&nbsp;</a></span>WriteUnsignedByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteUnsignedByte </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given unsigned byte value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a9ef10c994eb0d7b9171a9489a18cfdec">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a3b00b322e7e5da7b4e07950810c971c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b00b322e7e5da7b4e07950810c971c5">&#9670;&nbsp;</a></span>WriteUnsignedInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteUnsignedInt </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given four byte unsigned int value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a482682e4697278cd89d1ab9278a50fd9">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a252059fc6762deab29eb738482e3ead7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252059fc6762deab29eb738482e3ead7">&#9670;&nbsp;</a></span>WriteUnsignedLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteUnsignedLong </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given eight byte unsigned long value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a6bb52912187f9a02f9ea31146d662487">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<a id="a6de34f33f22b7d58c02454122e89f3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de34f33f22b7d58c02454122e89f3bb">&#9670;&nbsp;</a></span>WriteUnsignedShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBuffer.html">IProtonBuffer</a> Apache.Qpid.Proton.Buffer.ProtonByteBuffer.WriteUnsignedShort </td>
          <td>(</td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given two byte unsigned short value into this buffer and increases the write offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write into this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this buffer instance</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>If there are not enough writable bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceApache_1_1Qpid_1_1Proton_1_1Buffer_1_1IProtonBufferAccessors.html#a23efc406af67426c4bc40ba05dd47866">Apache.Qpid.Proton.Buffer.IProtonBufferAccessors</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a28f5dc92f3575668a9708a1eb2fb9d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f5dc92f3575668a9708a1eb2fb9d00">&#9670;&nbsp;</a></span>DefaultCapacity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly int Apache.Qpid.Proton.Buffer.ProtonByteBuffer.DefaultCapacity = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default initial capacity when created without initial value. </p>

</div>
</div>
<a id="aaff5b229b9e1712eff4d38076b70a3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff5b229b9e1712eff4d38076b70a3ff">&#9670;&nbsp;</a></span>DefaultMaximumCapacity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly int Apache.Qpid.Proton.Buffer.ProtonByteBuffer.DefaultMaximumCapacity = int.MaxValue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default max capacity based on maximum array size limit as this buffer is backed by a byte array. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Proton/Buffer/ProtonByteBuffer.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
