<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qpid Proton C++ API: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">0.36.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tutorial_page.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a brief guide to to the fundamentals of building messaging applications using Qpid Proton C++.</p>
<p>Proton provides an "event-driven" programming model, where you implement a subclass of <code><a class="el" href="classproton_1_1messaging__handler.html" title="Handler for Proton messaging events.">proton::messaging_handler</a></code> and override functions that react to various AMQP events (connections opening and closing, messages being delivered, and so on).</p>
<p>The examples below show how to implement handlers for clients and servers and how to run them using the <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code>, a portable, easy-to-use way to build single-threaded clients or servers.</p>
<p>Some of the examples require an AMQP <em>broker</em> that can receive, store, and send messages. <a class="el" href="broker_8cpp-example.html">broker.cpp</a> defines a simple example broker. If run without arguments, it listens on <code>0.0.0.0:5672</code>, the standard AMQP port on all network interfaces. To use a different port or network interface, use the <code>-a</code> option. </p><pre class="fragment">broker -a &lt;host&gt;:&lt;port&gt;
</pre><p> Instead of the example broker, you can use any AMQP 1.0-compliant broker. You must configure your broker to have a queue (or topic) named "examples".</p>
<p>The <code>helloworld</code> examples take an optional URL argument. The other examples take an option <code>-a URL</code>. A URL looks like this: </p><pre class="fragment">HOST:PORT/ADDRESS
</pre><p> It usually defaults to <code>127.0.0.1:5672/examples</code>, but you can change this if your broker is on a different host or port, or you want to use a different queue or topic name (the ADDRESS part of the URL).</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Hello World!</h2>
<p></p>
<p>Tradition dictates that we start with Hello World! This example sends a message to a broker and then receives the same message back. In a realistic system the sender and receiver would normally be in different processes. The complete example is <a class="el" href="helloworld_8cpp-example.html">helloworld.cpp</a></p>
<p>We will include the following classes. <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code> runs an event loop which dispatches events to a <code><a class="el" href="classproton_1_1messaging__handler.html" title="Handler for Proton messaging events.">proton::messaging_handler</a></code>. This allows a <em>reactive</em> style of programming which is well suited to messaging applications. <code><a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer.">proton::connection</a></code> and <code><a class="el" href="classproton_1_1delivery.html" title="A received message.">proton::delivery</a></code> are AMQP entities used in the handler functions. <code><a class="el" href="classproton_1_1url.html" title="Deprecated - Use a third-party URL library.">proton::url</a></code> is a simple parser for the URL format mentioned above.</p>
<div class="fragment"></div><!-- fragment --><p> We will define a class <code>hello_world</code> which is a subclass of <code><a class="el" href="classproton_1_1messaging__handler.html" title="Handler for Proton messaging events.">proton::messaging_handler</a></code> and overrides functions to handle the events of interest in sending and receiving a message.</p>
<div class="fragment"></div><!-- fragment --><p> <code><a class="el" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824" title="The container event loop is starting.">proton::messaging_handler::on_container_start()</a></code> is called when the event loop first starts. We handle that by establishing a connection and creating a sender and a receiver.</p>
<div class="fragment"></div><!-- fragment --><p> <code><a class="el" href="classproton_1_1messaging__handler.html#a86c9509ba3ce1925150c5b7a9a937c94" title="A message can be sent.">proton::messaging_handler::on_sendable()</a></code> is called when the message can be transferred over the associated sender link to the remote peer. We create a <code><a class="el" href="classproton_1_1message.html" title="An AMQP message.">proton::message</a></code>, set the message body to <code>"Hello
World!"</code>, and send the message. Then we close the sender, since we only want to send one message. Closing the sender will prevent further calls to <code><a class="el" href="classproton_1_1messaging__handler.html#a86c9509ba3ce1925150c5b7a9a937c94" title="A message can be sent.">proton::messaging_handler::on_sendable()</a></code>.</p>
<div class="fragment"></div><!-- fragment --><p> <code><a class="el" href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb" title="A message is received.">proton::messaging_handler::on_message()</a></code> is called when a message is received. We just print the body of the message and close the connection, as we only want one message.</p>
<div class="fragment"></div><!-- fragment --><p> The message body is a <code><a class="el" href="classproton_1_1value.html" title="A holder for any AMQP value, simple or complex.">proton::value</a></code>. See <a class="el" href="types_page.html">AMQP and C++ types</a> for more on how to extract the message body as type-safe C++ values.</p>
<p>Our <code>main</code> function creates an instance of the <code>hello_world</code> handler and a <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code> using that handler. Calling <code><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in the current thread.">proton::container::run()</a></code> sets things in motion and returns when we close the connection. It may throw an exception, which will be a subclass of <code><a class="el" href="structproton_1_1error.html" title="The base Proton error.">proton::error</a></code>. That in turn is a subclass of <code>std::exception</code>.</p>
<div class="fragment"></div><!-- fragment --> <h2><a class="anchor" id="autotoc_md17"></a>
Asynchronous send and receive</h2>
<p>Of course, these <code>Hello World!</code> examples are very artificial, communicating as they do over a network connection but with the same process. A more realistic example involves communication between separate processes, which could indeed be running on completely separate machines.</p>
<p>Let's separate the sender from the receiver, and transfer more than a single message between them.</p>
<p>We'll start with a simple sender, <a class="el" href="simple_send_8cpp-example.html">simple_send.cpp</a>.</p>
<p></p>
<p>As with the previous example, we define the application logic in a class that handles events. Because we are transferring more than one message, we need to keep track of how many we have sent. We'll use a <code>sent</code> member variable for that. The <code>total</code> member variable will hold the number of messages we want to send.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>simple_send : <span class="keyword">public</span> <a class="code" href="classproton_1_1messaging__handler.html">proton::messaging_handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    std::string url;</div>
<div class="line">    std::string user;</div>
<div class="line">    std::string password;</div>
<div class="line">    <span class="keywordtype">bool</span> reconnect;</div>
<div class="line">    <a class="code" href="classproton_1_1sender.html">proton::sender</a> sender;</div>
<div class="line">    <span class="keywordtype">int</span> sent;</div>
<div class="line">    <span class="keywordtype">int</span> confirmed;</div>
<div class="line">    <span class="keywordtype">int</span> total;</div>
<div class="ttc" id="aclassproton_1_1messaging__handler_html"><div class="ttname"><a href="classproton_1_1messaging__handler.html">proton::messaging_handler</a></div><div class="ttdoc">Handler for Proton messaging events.</div><div class="ttdef"><b>Definition:</b> messaging_handler.hpp:69</div></div>
<div class="ttc" id="aclassproton_1_1sender_html"><div class="ttname"><a href="classproton_1_1sender.html">proton::sender</a></div><div class="ttdoc">A channel for sending messages.</div><div class="ttdef"><b>Definition:</b> sender.hpp:40</div></div>
</div><!-- fragment --><p> As before, we use the <code><a class="el" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824" title="The container event loop is starting.">proton::messaging_handler::on_container_start()</a></code> event to establish our sender link over which we will transfer messages.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c)<span class="keyword"> override </span>{</div>
<div class="line">        <a class="code" href="classproton_1_1connection__options.html">proton::connection_options</a> co;</div>
<div class="line">        <span class="keywordflow">if</span> (!user.empty()) co.<a class="code" href="classproton_1_1connection__options.html#a10afa48d580025f71f0a6dd31bd1de24">user</a>(user);</div>
<div class="line">        <span class="keywordflow">if</span> (!password.empty()) co.<a class="code" href="classproton_1_1connection__options.html#a78a90a1387cf91915dbe39b888955d75">password</a>(password);</div>
<div class="line">        <span class="keywordflow">if</span> (reconnect) co.<a class="code" href="classproton_1_1connection__options.html#ad053f0ac823eefd100731c1b5248e7e8">reconnect</a>(<a class="code" href="classproton_1_1reconnect__options.html">proton::reconnect_options</a>());</div>
<div class="line">        sender = c.<a class="code" href="classproton_1_1container.html#adfbfd13668611a525bb44328d7a3b1e8">open_sender</a>(url, co);</div>
<div class="line">    }</div>
<div class="ttc" id="aclassproton_1_1connection__options_html"><div class="ttname"><a href="classproton_1_1connection__options.html">proton::connection_options</a></div><div class="ttdoc">Options for creating a connection.</div><div class="ttdef"><b>Definition:</b> connection_options.hpp:67</div></div>
<div class="ttc" id="aclassproton_1_1connection__options_html_a10afa48d580025f71f0a6dd31bd1de24"><div class="ttname"><a href="classproton_1_1connection__options.html#a10afa48d580025f71f0a6dd31bd1de24">proton::connection_options::user</a></div><div class="ttdeci">connection_options &amp; user(const std::string &amp;)</div><div class="ttdoc">Set the user name used to authenticate the connection.</div></div>
<div class="ttc" id="aclassproton_1_1connection__options_html_a78a90a1387cf91915dbe39b888955d75"><div class="ttname"><a href="classproton_1_1connection__options.html#a78a90a1387cf91915dbe39b888955d75">proton::connection_options::password</a></div><div class="ttdeci">connection_options &amp; password(const std::string &amp;)</div><div class="ttdoc">Set the password used to authenticate the connection.</div></div>
<div class="ttc" id="aclassproton_1_1connection__options_html_ad053f0ac823eefd100731c1b5248e7e8"><div class="ttname"><a href="classproton_1_1connection__options.html#ad053f0ac823eefd100731c1b5248e7e8">proton::connection_options::reconnect</a></div><div class="ttdeci">connection_options &amp; reconnect(const reconnect_options &amp;)</div><div class="ttdoc">Unsettled API - Set reconnect timing options.</div></div>
<div class="ttc" id="aclassproton_1_1container_html"><div class="ttname"><a href="classproton_1_1container.html">proton::container</a></div><div class="ttdoc">A top-level container of connections, sessions, and links.</div><div class="ttdef"><b>Definition:</b> container.hpp:49</div></div>
<div class="ttc" id="aclassproton_1_1container_html_adfbfd13668611a525bb44328d7a3b1e8"><div class="ttname"><a href="classproton_1_1container.html#adfbfd13668611a525bb44328d7a3b1e8">proton::container::open_sender</a></div><div class="ttdeci">returned&lt; sender &gt; open_sender(const std::string &amp;addr_url)</div><div class="ttdoc">Open a connection and sender for addr_url.</div></div>
<div class="ttc" id="aclassproton_1_1reconnect__options_html"><div class="ttname"><a href="classproton_1_1reconnect__options.html">proton::reconnect_options</a></div><div class="ttdoc">Unsettled API - Options for reconnect and failover after connection loss.</div><div class="ttdef"><b>Definition:</b> reconnect_options.hpp:49</div></div>
</div><!-- fragment --><p> AMQP defines a credit-based flow-control mechanism. Flow control allows the receiver to control how many messages it is prepared to receive at a given time and thus prevents any component being overwhelmed by the number of messages it is sent.</p>
<p>In the <code><a class="el" href="classproton_1_1messaging__handler.html#a86c9509ba3ce1925150c5b7a9a937c94" title="A message can be sent.">proton::messaging_handler::on_sendable()</a></code> callback, we check that our sender has credit before sending messages. We also check that we haven't already sent the required number of messages.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_sendable(<a class="code" href="classproton_1_1sender.html">proton::sender</a> &amp;s)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">while</span> (s.<a class="code" href="classproton_1_1link.html#afd27bd11ba72d7df51c44f71b15749eb">credit</a>() &amp;&amp; sent &lt; total) {</div>
<div class="line">            <a class="code" href="classproton_1_1message.html">proton::message</a> msg;</div>
<div class="line">            std::map&lt;std::string, int&gt; m;</div>
<div class="line">            m[<span class="stringliteral">&quot;sequence&quot;</span>] = sent + 1;</div>
<div class="line"> </div>
<div class="line">            msg.<a class="code" href="classproton_1_1message.html#a84811758e758988a802673edca6b77cb">id</a>(sent + 1);</div>
<div class="line">            msg.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>(m);</div>
<div class="line"> </div>
<div class="line">            s.<a class="code" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830">send</a>(msg);</div>
<div class="line">            sent++;</div>
<div class="line">        }</div>
<div class="ttc" id="aclassproton_1_1link_html_afd27bd11ba72d7df51c44f71b15749eb"><div class="ttname"><a href="classproton_1_1link.html#afd27bd11ba72d7df51c44f71b15749eb">proton::link::credit</a></div><div class="ttdeci">int credit() const</div><div class="ttdoc">Credit available on the link.</div></div>
<div class="ttc" id="aclassproton_1_1message_html"><div class="ttname"><a href="classproton_1_1message.html">proton::message</a></div><div class="ttdoc">An AMQP message.</div><div class="ttdef"><b>Definition:</b> message.hpp:50</div></div>
<div class="ttc" id="aclassproton_1_1message_html_a84811758e758988a802673edca6b77cb"><div class="ttname"><a href="classproton_1_1message.html#a84811758e758988a802673edca6b77cb">proton::message::id</a></div><div class="ttdeci">void id(const message_id &amp;)</div><div class="ttdoc">Set the message ID.</div></div>
<div class="ttc" id="aclassproton_1_1message_html_ae9af642f154a68ec0eb8e715ecaf95ae"><div class="ttname"><a href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">proton::message::body</a></div><div class="ttdeci">void body(const value &amp;x)</div><div class="ttdoc">Set the body. Equivalent to body() = x.</div></div>
<div class="ttc" id="aclassproton_1_1sender_html_a214eb30b24e6831d016a47b9dddda830"><div class="ttname"><a href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830">proton::sender::send</a></div><div class="ttdeci">tracker send(const message &amp;m)</div><div class="ttdoc">Send a message on the sender.</div></div>
<div class="line">    }</div>
</div><!-- fragment --><p> The <code><a class="el" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830" title="Send a message on the sender.">proton::sender::send()</a></code> call above is asynchronous. When it returns, the message has not yet actually been transferred across the network to the receiver. By handling the <code><a class="el" href="classproton_1_1messaging__handler.html#a4e61812588fe6fbde253b41f7c02e993" title="The receiving peer accepted a transfer.">proton::messaging_handler::on_tracker_accept()</a></code> event, we can get notified when the receiver has received and accepted the message. In our example we use this event to track the confirmation of the messages we have sent. We only close the connection and exit when the receiver has received all the messages we wanted to send.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_tracker_accept(<a class="code" href="classproton_1_1tracker.html">proton::tracker</a> &amp;t)<span class="keyword"> override </span>{</div>
<div class="line">        confirmed++;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (confirmed == total) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;all messages confirmed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            t.<a class="code" href="classproton_1_1transfer.html#aff302bb6016f2ae29f01bb4e07389a52">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">        }</div>
<div class="ttc" id="aclassproton_1_1connection_html_a5ae591df94fc66ccb85cbb6565368bca"><div class="ttname"><a href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">proton::connection::close</a></div><div class="ttdeci">void close()</div><div class="ttdoc">Close the connection.</div></div>
<div class="ttc" id="aclassproton_1_1tracker_html"><div class="ttname"><a href="classproton_1_1tracker.html">proton::tracker</a></div><div class="ttdoc">A tracker for a sent message.</div><div class="ttdef"><b>Definition:</b> tracker.hpp:41</div></div>
<div class="ttc" id="aclassproton_1_1transfer_html_aff302bb6016f2ae29f01bb4e07389a52"><div class="ttname"><a href="classproton_1_1transfer.html#aff302bb6016f2ae29f01bb4e07389a52">proton::transfer::connection</a></div><div class="ttdeci">class connection connection() const</div><div class="ttdoc">Return the connection for this transfer.</div></div>
<div class="line">    }</div>
</div><!-- fragment --><p> If we are disconnected after a message is sent and before it has been confirmed by the receiver, it is said to be "in doubt". We don't know whether or not it was received. In this example, we will handle that by resending any in-doubt messages. This is known as an "at-least-once" guarantee, since each message should eventually be received at least once, though a given message may be received more than once (i.e., duplicates are possible). In the <code><a class="el" href="classproton_1_1messaging__handler.html#a8a60c2f6628f44a9587deea8c8729f0f" title="The final event for a connection: there will be no more reconnect attempts and no more event function...">proton::messaging_handler::on_transport_close()</a></code> callback, we reset the sent count to reflect only those that have been confirmed. The library will automatically try to reconnect for us, and when our sender is sendable again, we can restart from the point we know the receiver got to.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_transport_close(<a class="code" href="classproton_1_1transport.html">proton::transport</a> &amp;)<span class="keyword"> override </span>{</div>
<div class="line">        sent = confirmed;</div>
<div class="line">    }</div>
<div class="ttc" id="aclassproton_1_1transport_html"><div class="ttname"><a href="classproton_1_1transport.html">proton::transport</a></div><div class="ttdoc">A network channel supporting an AMQP connection.</div><div class="ttdef"><b>Definition:</b> transport.hpp:37</div></div>
</div><!-- fragment --> <p>Now let's look at the corresponding receiver, <a class="el" href="simple_recv_8cpp-example.html">simple_recv.cpp</a>.</p>
<p>This time we'll use an <code>expected</code> member variable for for the number of messages we expect and a <code>received</code> variable to count how many we have received so far.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>simple_recv : <span class="keyword">public</span> <a class="code" href="classproton_1_1messaging__handler.html">proton::messaging_handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    std::string url;</div>
<div class="line">    std::string user;</div>
<div class="line">    std::string password;</div>
<div class="line">    <a class="code" href="classproton_1_1receiver.html">proton::receiver</a> receiver;</div>
<div class="line">    <span class="keywordtype">int</span> expected;</div>
<div class="line">    <span class="keywordtype">int</span> received;</div>
<div class="ttc" id="aclassproton_1_1receiver_html"><div class="ttname"><a href="classproton_1_1receiver.html">proton::receiver</a></div><div class="ttdoc">A channel for receiving messages.</div><div class="ttdef"><b>Definition:</b> receiver.hpp:41</div></div>
</div><!-- fragment --><p> We handle <code><a class="el" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824" title="The container event loop is starting.">proton::messaging_handler::on_container_start()</a></code> by creating our receiver, much like we did for the sender.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c)<span class="keyword"> override </span>{</div>
<div class="line">        <a class="code" href="classproton_1_1connection__options.html">proton::connection_options</a> co;</div>
<div class="line">        <span class="keywordflow">if</span> (!user.empty()) co.<a class="code" href="classproton_1_1connection__options.html#a10afa48d580025f71f0a6dd31bd1de24">user</a>(user);</div>
<div class="line">        <span class="keywordflow">if</span> (!password.empty()) co.<a class="code" href="classproton_1_1connection__options.html#a78a90a1387cf91915dbe39b888955d75">password</a>(password);</div>
<div class="line">        receiver = c.<a class="code" href="classproton_1_1container.html#a15df75d582af4ed83f0ffab9dcce84bf">open_receiver</a>(url, co);</div>
<div class="line">    }</div>
<div class="ttc" id="aclassproton_1_1container_html_a15df75d582af4ed83f0ffab9dcce84bf"><div class="ttname"><a href="classproton_1_1container.html#a15df75d582af4ed83f0ffab9dcce84bf">proton::container::open_receiver</a></div><div class="ttdeci">returned&lt; receiver &gt; open_receiver(const std::string &amp;addr_url)</div><div class="ttdoc">Open a connection and receiver for addr_url.</div></div>
</div><!-- fragment --><p> We also handle the <code><a class="el" href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb" title="A message is received.">proton::messaging_handler::on_message()</a></code> event for received messages and print the message out as in the <code>Hello World!</code> examples. However, we add some logic to allow the receiver to wait for a given number of messages and then close the connection and exit. We also add some logic to check for and ignore duplicates, using a simple sequential ID scheme.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a> &amp;d, <a class="code" href="classproton_1_1message.html">proton::message</a> &amp;msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (!msg.<a class="code" href="classproton_1_1message.html#a84811758e758988a802673edca6b77cb">id</a>().empty() &amp;&amp; proton::coerce&lt;int&gt;(msg.<a class="code" href="classproton_1_1message.html#a84811758e758988a802673edca6b77cb">id</a>()) &lt; received) {</div>
<div class="line">            <span class="keywordflow">return</span>; <span class="comment">// Ignore if no id or duplicate</span></div>
<div class="line">        }</div>
<div class="ttc" id="aclassproton_1_1delivery_html"><div class="ttname"><a href="classproton_1_1delivery.html">proton::delivery</a></div><div class="ttdoc">A received message.</div><div class="ttdef"><b>Definition:</b> delivery.hpp:40</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md18"></a>
Direct send and receive</h2>
<p>Sending between these two examples requires an intermediary broker since neither accepts incoming connections. AMQP allows us to send messages directly between two processes. In that case, one or other of the processes needs to accept incoming connections. Let's create a modified version of the receiving example that does this with <a class="el" href="direct_recv_8cpp-example.html">direct_recv.cpp</a>.</p>
<p></p>
<p>There are only two differences here. Instead of initiating a link (and implicitly a connection), we listen for incoming connections.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c)<span class="keyword"> override </span>{</div>
<div class="line">        listener = c.<a class="code" href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524">listen</a>(url, listen_handler);</div>
<div class="line">    }</div>
<div class="ttc" id="aclassproton_1_1container_html_a9e138b28e9589583915cf5c5e0e7a524"><div class="ttname"><a href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524">proton::container::listen</a></div><div class="ttdeci">listener listen(const std::string &amp;listen_url, listen_handler &amp;handler)</div><div class="ttdoc">Listen for new connections on listen_url.</div></div>
</div><!-- fragment --><p> When we have received all the expected messages, we then stop listening for incoming connections by calling <code><a class="el" href="classproton_1_1listener.html#a8c528baf37154d347366083f0f816846" title="Stop listening on the address provided to the call to container::listen that returned this listener.">proton::listener::stop()</a></code></p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a> &amp;d, <a class="code" href="classproton_1_1message.html">proton::message</a> &amp;msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (proton::coerce&lt;int&gt;(msg.<a class="code" href="classproton_1_1message.html#a84811758e758988a802673edca6b77cb">id</a>()) &lt; received) {</div>
<div class="line">            <span class="keywordflow">return</span>; <span class="comment">// Ignore duplicate</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (expected == 0 || received &lt; expected) {</div>
<div class="line">            std::cout &lt;&lt; msg.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>() &lt;&lt; std::endl;</div>
<div class="line">            received++;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (received == expected) {</div>
<div class="line">            d.<a class="code" href="classproton_1_1delivery.html#aeb4319de46c92afec4ebbb3116d67c39">receiver</a>().<a class="code" href="classproton_1_1link.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">            d.<a class="code" href="classproton_1_1transfer.html#aff302bb6016f2ae29f01bb4e07389a52">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">            listener.stop();</div>
<div class="line">        }</div>
<div class="ttc" id="aclassproton_1_1delivery_html_aeb4319de46c92afec4ebbb3116d67c39"><div class="ttname"><a href="classproton_1_1delivery.html#aeb4319de46c92afec4ebbb3116d67c39">proton::delivery::receiver</a></div><div class="ttdeci">class receiver receiver() const</div><div class="ttdoc">Return the receiver for this delivery.</div></div>
<div class="ttc" id="aclassproton_1_1link_html_a5ae591df94fc66ccb85cbb6565368bca"><div class="ttname"><a href="classproton_1_1link.html#a5ae591df94fc66ccb85cbb6565368bca">proton::link::close</a></div><div class="ttdeci">void close()</div><div class="ttdoc">Close the endpoint.</div></div>
<div class="line">    }</div>
</div><!-- fragment --><p> You can use the <a class="el" href="simple_send_8cpp-example.html">simple_send.cpp</a> example to send to this receiver directly. (Note: you will need to stop any broker that is listening on the 5672 port, or else change the port used by specifying a different address to each example via the <code>-a</code> command-line switch).</p>
<p>We can also modify the sender to allow the original receiver to connect to it, in <a class="el" href="direct_send_8cpp-example.html">direct_send.cpp</a>. Again, that requires just two modifications:</p>
<p></p>
<p>As with the modified receiver, instead of initiating establishment of a link, we listen for incoming connections.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c)<span class="keyword"> override </span>{</div>
<div class="line">        listener = c.<a class="code" href="classproton_1_1container.html#a9e138b28e9589583915cf5c5e0e7a524">listen</a>(url, listen_handler);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> When we have received confirmation of all the messages we sent, we call <code>container::listener::stop()</code> to exit.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_tracker_accept(<a class="code" href="classproton_1_1tracker.html">proton::tracker</a> &amp;t)<span class="keyword"> override </span>{</div>
<div class="line">        confirmed++;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (confirmed == total) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;all messages confirmed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            t.<a class="code" href="classproton_1_1transfer.html#aff302bb6016f2ae29f01bb4e07389a52">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">            listener.stop();</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p> To try this modified sender, run the original <a class="el" href="simple_recv_8cpp-example.html">simple_recv.cpp</a> against it.</p>
<p>The symmetry in the underlying AMQP wire protocol that enables this is quite unique and elegant, and in reflecting this the Proton API provides a flexible toolkit for implementing all sorts of interesting intermediaries.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Request and response</h2>
<p>A common pattern is to send a request message and expect a response message in return. AMQP has special support for this pattern. Let's have a look at a simple example. We'll start with <a class="el" href="server_8cpp-example.html">server.cpp</a>, the program that will process the request and send the response. Note that we are still using a broker in this example.</p>
<p>Our server will provide a very simple service: it will respond with the body of the request converted to uppercase.</p>
 <div class="fragment"><div class="line"><span class="keyword">class </span>server : <span class="keyword">public</span> <a class="code" href="classproton_1_1messaging__handler.html">proton::messaging_handler</a> {</div>
<div class="line">    std::string conn_url_;</div>
<div class="line">    std::string addr_;</div>
<div class="line">    <a class="code" href="classproton_1_1connection.html">proton::connection</a> conn_;</div>
<div class="line">    std::map&lt;std::string, proton::sender&gt; senders_;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    server(<span class="keyword">const</span> std::string&amp; u, <span class="keyword">const</span> std::string&amp; a) :</div>
<div class="line">        conn_url_(u), addr_(a) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824">on_container_start</a>(<a class="code" href="classproton_1_1container.html">proton::container</a>&amp; c)<span class="keyword"> override </span>{</div>
<div class="line">        conn_ = c.<a class="code" href="classproton_1_1container.html#adbd9ed231804512a47cca3c81f00cdf1">connect</a>(conn_url_);</div>
<div class="line">        conn_.<a class="code" href="classproton_1_1connection.html#aad60d14592ee9d34caca4c61214ecd27">open_receiver</a>(addr_);</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Server connected to &quot;</span> &lt;&lt; conn_url_ &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string to_upper(<span class="keyword">const</span> std::string&amp; s) {</div>
<div class="line">        std::string uc(s);</div>
<div class="line">        <span class="keywordtype">size_t</span> l = uc.size();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;l; i++) {</div>
<div class="line">            uc[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(std::toupper(uc[i]));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> uc;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb">on_message</a>(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a>&amp;, <a class="code" href="classproton_1_1message.html">proton::message</a>&amp; m)<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt; m.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        std::string reply_to = m.<a class="code" href="classproton_1_1message.html#a4032b495d721bd6d29bfa33ebb8ac5fe">reply_to</a>();</div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a> reply;</div>
<div class="line"> </div>
<div class="line">        reply.<a class="code" href="classproton_1_1message.html#a2fda6a98616365e06f1d4a627d1a58ac">to</a>(reply_to);</div>
<div class="line">        reply.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>(to_upper(proton::get&lt;std::string&gt;(m.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>())));</div>
<div class="line">        reply.<a class="code" href="classproton_1_1message.html#ad159656f1742235cd22a9c6aaabf9d2d">correlation_id</a>(m.<a class="code" href="classproton_1_1message.html#ad159656f1742235cd22a9c6aaabf9d2d">correlation_id</a>());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!senders_[reply_to]) {</div>
<div class="line">            senders_[reply_to] = conn_.<a class="code" href="classproton_1_1connection.html#ae8eece4fd4b9e1a2531ca12d2ab57a32">open_sender</a>(reply_to);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        senders_[reply_to].<a class="code" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830">send</a>(reply);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassproton_1_1connection_html"><div class="ttname"><a href="classproton_1_1connection.html">proton::connection</a></div><div class="ttdoc">A connection to a remote AMQP peer.</div><div class="ttdef"><b>Definition:</b> connection.hpp:47</div></div>
<div class="ttc" id="aclassproton_1_1connection_html_aad60d14592ee9d34caca4c61214ecd27"><div class="ttname"><a href="classproton_1_1connection.html#aad60d14592ee9d34caca4c61214ecd27">proton::connection::open_receiver</a></div><div class="ttdeci">receiver open_receiver(const std::string &amp;addr)</div><div class="ttdoc">Open a receiver for addr on default_session().</div></div>
<div class="ttc" id="aclassproton_1_1connection_html_ae8eece4fd4b9e1a2531ca12d2ab57a32"><div class="ttname"><a href="classproton_1_1connection.html#ae8eece4fd4b9e1a2531ca12d2ab57a32">proton::connection::open_sender</a></div><div class="ttdeci">sender open_sender(const std::string &amp;addr)</div><div class="ttdoc">Open a sender for addr on default_session().</div></div>
<div class="ttc" id="aclassproton_1_1container_html_adbd9ed231804512a47cca3c81f00cdf1"><div class="ttname"><a href="classproton_1_1container.html#adbd9ed231804512a47cca3c81f00cdf1">proton::container::connect</a></div><div class="ttdeci">returned&lt; connection &gt; connect(const std::string &amp;conn_url, const connection_options &amp;conn_opts)</div><div class="ttdoc">Connect to conn_url and send an open request to the remote peer.</div></div>
<div class="ttc" id="aclassproton_1_1message_html_a2fda6a98616365e06f1d4a627d1a58ac"><div class="ttname"><a href="classproton_1_1message.html#a2fda6a98616365e06f1d4a627d1a58ac">proton::message::to</a></div><div class="ttdeci">void to(const std::string &amp;)</div><div class="ttdoc">Set the destination address.</div></div>
<div class="ttc" id="aclassproton_1_1message_html_a4032b495d721bd6d29bfa33ebb8ac5fe"><div class="ttname"><a href="classproton_1_1message.html#a4032b495d721bd6d29bfa33ebb8ac5fe">proton::message::reply_to</a></div><div class="ttdeci">void reply_to(const std::string &amp;)</div><div class="ttdoc">Set the address for replies.</div></div>
<div class="ttc" id="aclassproton_1_1message_html_ad159656f1742235cd22a9c6aaabf9d2d"><div class="ttname"><a href="classproton_1_1message.html#ad159656f1742235cd22a9c6aaabf9d2d">proton::message::correlation_id</a></div><div class="ttdeci">void correlation_id(const message_id &amp;)</div><div class="ttdoc">Set the ID for matching related messages.</div></div>
<div class="ttc" id="aclassproton_1_1messaging__handler_html_a584c9daeadf4322801f58e054017fecb"><div class="ttname"><a href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb">proton::messaging_handler::on_message</a></div><div class="ttdeci">virtual void on_message(delivery &amp;, message &amp;)</div><div class="ttdoc">A message is received.</div></div>
<div class="ttc" id="aclassproton_1_1messaging__handler_html_a9188622c33638e076d2214080129c824"><div class="ttname"><a href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824">proton::messaging_handler::on_container_start</a></div><div class="ttdeci">virtual void on_container_start(container &amp;)</div><div class="ttdoc">The container event loop is starting.</div></div>
</div><!-- fragment --><p> The code here is not too different from the simple receiver example. However, when we receive a request in <code><a class="el" href="classproton_1_1messaging__handler.html#a584c9daeadf4322801f58e054017fecb" title="A message is received.">proton::messaging_handler::on_message</a></code>, we look at the <code><a class="el" href="classproton_1_1message.html#a4032b495d721bd6d29bfa33ebb8ac5fe" title="Set the address for replies.">proton::message::reply_to</a></code> address and create a sender with that address for the response. We'll cache the senders in case we get further requests with the same <code>reply_to</code>.</p>
<p>Now let's create a simple <a class="el" href="client_8cpp-example.html">client.cpp</a> to test this service out.</p>
<p></p>
<p>Our client takes a list of strings to send as requests.</p>
<div class="fragment"><div class="line">    client(<span class="keyword">const</span> std::string &amp;u, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; r) : url(u), requests(r) {}</div>
</div><!-- fragment --><p> Since we will be sending and receiving, we create a sender and a receiver in <code><a class="el" href="classproton_1_1messaging__handler.html#a9188622c33638e076d2214080129c824" title="The container event loop is starting.">proton::messaging_handler::on_container_start</a></code>. Our receiver has a blank address and sets the <code>dynamic</code> flag to true, which means we expect the remote end (the broker or server) to assign a unique address for us.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_container_start(<a class="code" href="classproton_1_1container.html">proton::container</a> &amp;c)<span class="keyword"> override </span>{</div>
<div class="line">        sender = c.<a class="code" href="classproton_1_1container.html#adfbfd13668611a525bb44328d7a3b1e8">open_sender</a>(url);</div>
<div class="line">        <span class="comment">// Create a receiver requesting a dynamically created queue</span></div>
<div class="line">        <span class="comment">// for the message source.</span></div>
<div class="line">        receiver_options opts = receiver_options().source(source_options().dynamic(<span class="keyword">true</span>));</div>
<div class="line">        receiver = sender.<a class="code" href="classproton_1_1link.html#aff302bb6016f2ae29f01bb4e07389a52">connection</a>().<a class="code" href="classproton_1_1connection.html#aad60d14592ee9d34caca4c61214ecd27">open_receiver</a>(<span class="stringliteral">&quot;&quot;</span>, opts);</div>
<div class="line">    }</div>
<div class="ttc" id="aclassproton_1_1link_html_aff302bb6016f2ae29f01bb4e07389a52"><div class="ttname"><a href="classproton_1_1link.html#aff302bb6016f2ae29f01bb4e07389a52">proton::link::connection</a></div><div class="ttdeci">class connection connection() const</div><div class="ttdoc">The connection that owns this link.</div></div>
</div><!-- fragment --><p> Now we need a function to send the next request from our list of requests. We set the <code>reply_to</code> address to be the dynamically assigned address of our receiver.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> send_request() {</div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a> req;</div>
<div class="line">        req.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>(requests.front());</div>
<div class="line">        req.<a class="code" href="classproton_1_1message.html#a4032b495d721bd6d29bfa33ebb8ac5fe">reply_to</a>(receiver.<a class="code" href="classproton_1_1receiver.html#a91a9e8a9445b29d83dd0514cd76503ae">source</a>().<a class="code" href="classproton_1_1source.html#a4744eb217c976c199b678bb5a0d55acf">address</a>());</div>
<div class="line">        sender.<a class="code" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830">send</a>(req);</div>
<div class="line">    }</div>
<div class="ttc" id="aclassproton_1_1receiver_html_a91a9e8a9445b29d83dd0514cd76503ae"><div class="ttname"><a href="classproton_1_1receiver.html#a91a9e8a9445b29d83dd0514cd76503ae">proton::receiver::source</a></div><div class="ttdeci">class source source() const</div><div class="ttdoc">Get the source node.</div></div>
<div class="ttc" id="aclassproton_1_1source_html_a4744eb217c976c199b678bb5a0d55acf"><div class="ttname"><a href="classproton_1_1source.html#a4744eb217c976c199b678bb5a0d55acf">proton::source::address</a></div><div class="ttdeci">std::string address() const</div><div class="ttdoc">The address of the source.</div></div>
</div><!-- fragment --><p> We need to use the address assigned by the broker as the <code>reply_to</code> address of our requests, so we can't send them until our receiver has been set up. To do that, we add an <code><a class="el" href="classproton_1_1messaging__handler.html#a77f7e38659ee43ccb764e417ad6dd401" title="The remote peer opened the link.">proton::messaging_handler::on_receiver_open()</a></code> method to our handler class and use that as the trigger to send our first request.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_receiver_open(<a class="code" href="classproton_1_1receiver.html">proton::receiver</a> &amp;)<span class="keyword"> override </span>{</div>
<div class="line">        send_request();</div>
<div class="line">    }</div>
</div><!-- fragment --><p> When we receive a reply, we send the next request.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a> &amp;d, <a class="code" href="classproton_1_1message.html">proton::message</a> &amp;response)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (requests.empty()) <span class="keywordflow">return</span>; <span class="comment">// Spurious extra message!</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; requests.front() &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; response.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>() &lt;&lt; std::endl;</div>
<div class="line">        requests.erase(requests.begin());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!requests.empty()) {</div>
<div class="line">            send_request();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            d.<a class="code" href="classproton_1_1transfer.html#aff302bb6016f2ae29f01bb4e07389a52">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md20"></a>
Direct request and response</h2>
<p>We can avoid the intermediary process by writing a server that accepts connections directly, <a class="el" href="server_direct_8cpp-example.html">server_direct.cpp</a>. It involves the following changes to our original server:</p>
<p></p>
<p>Our server must generate unique <code>reply-to</code> addresses for links from the client that request a dynamic address (previously this was done by the broker). We use a simple counter.</p>
<div class="fragment"><div class="line">    std::string generate_address() {</div>
<div class="line">        std::ostringstream addr;</div>
<div class="line">        addr &lt;&lt; <span class="stringliteral">&quot;server&quot;</span> &lt;&lt; address_counter++;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> addr.str();</div>
<div class="line">    }</div>
</div><!-- fragment --><p> Next we need to handle incoming requests for links with dynamic addresses from the client. We give the link a unique address and record it in our <code>senders</code> map.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_sender_open(<a class="code" href="classproton_1_1sender.html">proton::sender</a> &amp;sender)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (sender.<a class="code" href="classproton_1_1sender.html#a91a9e8a9445b29d83dd0514cd76503ae">source</a>().<a class="code" href="classproton_1_1terminus.html#adcc4ef24adb8478230018c519aa636ec">dynamic</a>()) {</div>
<div class="line">            std::string addr = generate_address();</div>
<div class="line">            sender.<a class="code" href="classproton_1_1sender.html#a9e8555112049fc2b4945120b3c45f8ab">open</a>(<a class="code" href="classproton_1_1sender__options.html">proton::sender_options</a>().source(<a class="code" href="classproton_1_1source__options.html">proton::source_options</a>().address(addr)));</div>
<div class="line">            senders[addr] = sender;</div>
<div class="line">        }</div>
<div class="ttc" id="aclassproton_1_1sender__options_html"><div class="ttname"><a href="classproton_1_1sender__options.html">proton::sender_options</a></div><div class="ttdoc">Options for creating a sender.</div><div class="ttdef"><b>Definition:</b> sender_options.hpp:60</div></div>
<div class="ttc" id="aclassproton_1_1sender_html_a91a9e8a9445b29d83dd0514cd76503ae"><div class="ttname"><a href="classproton_1_1sender.html#a91a9e8a9445b29d83dd0514cd76503ae">proton::sender::source</a></div><div class="ttdeci">class source source() const</div><div class="ttdoc">Get the source node.</div></div>
<div class="ttc" id="aclassproton_1_1sender_html_a9e8555112049fc2b4945120b3c45f8ab"><div class="ttname"><a href="classproton_1_1sender.html#a9e8555112049fc2b4945120b3c45f8ab">proton::sender::open</a></div><div class="ttdeci">void open()</div><div class="ttdoc">Open the sender.</div></div>
<div class="ttc" id="aclassproton_1_1source__options_html"><div class="ttname"><a href="classproton_1_1source__options.html">proton::source_options</a></div><div class="ttdoc">Options for creating a source node for a sender or receiver.</div><div class="ttdef"><b>Definition:</b> source_options.hpp:44</div></div>
<div class="ttc" id="aclassproton_1_1terminus_html_adcc4ef24adb8478230018c519aa636ec"><div class="ttname"><a href="classproton_1_1terminus.html#adcc4ef24adb8478230018c519aa636ec">proton::terminus::dynamic</a></div><div class="ttdeci">bool dynamic() const</div><div class="ttdoc">True if the remote node is created dynamically.</div></div>
</div><!-- fragment --><p> Note that we are interested in <em>sender</em> links above because we are implementing the server. A <em>receiver</em> link created on the client corresponds to a <em>sender</em> link on the server.</p>
<p>Finally when we receive a message we look up its <code>reply_to</code> in our senders map and send the reply.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1delivery.html">proton::delivery</a> &amp;, <a class="code" href="classproton_1_1message.html">proton::message</a> &amp;m)<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt; m.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        std::string reply_to = m.<a class="code" href="classproton_1_1message.html#a4032b495d721bd6d29bfa33ebb8ac5fe">reply_to</a>();</div>
<div class="line">        sender_map::iterator it = senders.find(reply_to);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (it == senders.end()) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;No link for reply_to: &quot;</span> &lt;&lt; reply_to &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <a class="code" href="classproton_1_1sender.html">proton::sender</a> sender = it-&gt;second;</div>
<div class="line">            <a class="code" href="classproton_1_1message.html">proton::message</a> reply;</div>
<div class="line"> </div>
<div class="line">            reply.<a class="code" href="classproton_1_1message.html#a2fda6a98616365e06f1d4a627d1a58ac">to</a>(reply_to);</div>
<div class="line">            reply.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>(to_upper(proton::get&lt;std::string&gt;(m.<a class="code" href="classproton_1_1message.html#ae9af642f154a68ec0eb8e715ecaf95ae">body</a>())));</div>
<div class="line">            reply.<a class="code" href="classproton_1_1message.html#ad159656f1742235cd22a9c6aaabf9d2d">correlation_id</a>(m.<a class="code" href="classproton_1_1message.html#ad159656f1742235cd22a9c6aaabf9d2d">correlation_id</a>());</div>
<div class="line"> </div>
<div class="line">            sender.<a class="code" href="classproton_1_1sender.html#a214eb30b24e6831d016a47b9dddda830">send</a>(reply);</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --></div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
